#!/usr/bin/perl
########################################################################
#
# $Id: gaIdke-post-merge 1.1 $
# $IdBlockFurtherExpansion$
#
# Git filters to implement RCS $Id: keyword expansion
#
# post-merge <p1>
#         <p1> Flag indicating whether the merge was a squash-merge.
#
#         Called after a 'git merge' or a 'git pull' - I presume because
#         'git pull' is equivalent to 'git fetch; git merge FETCH_HEAD.
#
#         The problem when 'smudge' is executed after a 'git pull' for
#         the modified files, HEAD has not been adjusted yet to the position
#         after the rebase. This is the situation after 'git fetch':
#
#               d--e         <-- FETCH_HEAD
#         a--b--c            <-- HEAD
#
#         This is the situation after the merge at which point modified
#         files are checked out and smudged incorrectly, because HEAD
#         still points at the old commit and 'smudge' uses 'git log',
#         which starts looking at HEAD and thus cannot find the commits
#         d' and e' which contain the details for the modified files.
#
#               d'--e'       <-- FETCH_HEAD
#               /
#         a--b--c            <-- HEAD
#
#         This is the situation after files have been checked out and
#         a rebase has been done. At this point 'post-merge' is called
#         and the newly fetched files can be smudged correctly.
#
#         a--b--c--d'--e'    <-- HEAD
#               ^--------------- ORIG_HEAD
#
#         Use 'git diff-tree' to obtain the list of modified files.
#
########################################################################

$i = 0;
open(SMUDGE, "git diff-tree -r --name-only --no-commit-id ORIG_HEAD HEAD |") or die "can't fork: $!";
while (defined($path = <SMUDGE>)) {
    chomp $path;
    if ($i++ == 0) {
	print STDOUT "post-merge\n";
    }
    print STDOUT " $path\n";
    qx(git checkout HEAD $path);
}
close SMUDGE;
if ($i > 0) {
    print STDOUT "$i files smudged\n";
}
