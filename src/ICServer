#!/usr/bin/perl -w -P

########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	ICServer
#
#	Server which can accept any number of iC I/O clients
#	and initially one iC controller (planned are many)
#
#	John E. Wulff	28-May-2000
#
#	Protocol between I/O and ICT clients and server:
#
#	Registration:	UnitID
#			X0 .. X31  from bit  I/O to server
#			B0 .. B31  from byte I/O to server
#			W0 .. W30  from word I/O to server
#			C0         from ICT to server
#
#	I/O values:	Value
#			0 .. 255   from bit/byte I/O to server
#			0 .. 65535 from word I/O to server
#
#			UnitID.Value
#			X0.0 .. X31.255   from server to ICT bit
#			B0.0 .. B31.255   from server to ICT byte
#			W0.0 .. W30.65535 from server to ICT word
#
#	The same formats are used from server to I/O and ICT to server.
#	The direction of transmission determines if an I/O messages
#	is input or output.
#
#	Each I/O value message constitutes an event which updates
#	that value at the sink. Several messages may be grouped
#	and seperated by comma (,)
#
#	Byte source and sink Units may be X0 X1 X2 .. X31 B0 B1 B2 .. B31
#	Word source and sink Units must be even W0 W2 W4 .. W30
#
#	The Server receives messages from the I/Os, identifies the
#	UnitID under which that I/O is registered and prefixes the
#	UnitID and a full stop to the message and sends it on to the ICT.
#
#	Messages received from the ICT are stripped of the leading
#	UnitID and comma. The rest is sent to the I/O Unit corresponding
#	to the UnitID stripped from the message.
#
#	For measuring reaction times the Module Time::HiRes may be used.
#	This activates the -m option.
#	Make sure you have downloaded and installed Time::HiRes from CPAN
#	Uncomment the C++ comment in the next line
#//define TIME_HIRES
#
########################################################################

use Msg;
use strict;

my %UnitIDs = ();
my %Connections = ();
my %Values = ();
my $connICT;

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:	@<<<<<<< [-tmh] [-s <host>] [-p <port>] [<list of client calls>]
	$named
	-s host	address of server - clients must specify the same address
		     unless (default '0.0.0.0' which accepts any client)
	-p port	service port of server for all clients  (default '8778')
	-t	trace messages for debugging
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-h	help, ouput this Usage text only
	NOTE:	if a client call has arguments, the call must be quoted
		eg: @<<<<<<< 'DemoBox X1'
		$named
Copyright (C) 2000-2001  John E. Wulff		<john@je-wulff.de>
							  '@'
$Id: ICServer,v 1.18 2001/03/02 12:57:20 jw Exp $
.

use vars qw($opt_t $opt_m $opt_s $opt_p $opt_h);
require "getopts.pl";
&Getopts('tms:p:h');			# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
#ifdef TIME_HIRES 

my ($t0, $t1);
if ($opt_m) {
    use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
    $t0 = [gettimeofday];	# start of program
}
#endif

########################################################################
#
#	Server
#
########################################################################

my $host = defined $opt_s ? $opt_s : '0.0.0.0';
my $port = defined $opt_p ? $opt_p : 8778;

Msg->new_server($host, $port, \&login_proc);
print "Server created. Waiting for events\n";

########################################################################
#
#	Start clients named in argument list
#
########################################################################

my $pid;
ARG: while ($ARGV = shift @ARGV) {
    FORK: {
	sleep 1 if defined $pid;
	next ARG if ($pid = fork);
	if (defined $pid) {	# $pid is zero if defined
	    # dispatch child process
	    my @call = split " ", $ARGV;
	    splice @call, 1, 0, '-p', $opt_p if defined $opt_p;
	    splice @call, 1, 0, '-t' if defined $opt_t;
	    splice @call, 1, 0, '-m' if defined $opt_m;
	    print "@call\n";
	    exec @call;
	    exit;		# child process cannot be executed
	} elsif ($! =~ /No more process/) {
	    # EAGAIN, recoverable fork error
	    sleep 5;
	    redo FORK;
	} else {
	    # weird fork error
	    die "Can't fork: $!\n";
	}
    }
}

Msg->event_loop();

########################################################################
#
#	Login procedure
#
########################################################################

sub login_proc {
    my ($conn, $host, $port) = @_;
    print "Connection $host:$port at server\n";
    # Unconditionally accept an incoming connection request
    $UnitIDs{$conn} = undef;
    return \&rcvd_msg_from_client;
}

########################################################################
#
#	Receive message from client
#
########################################################################

sub rcvd_msg_from_client {
    my ($conn, $msg, $err) = @_;
#ifdef TIME_HIRES 
    my ($sec, $usec);
    if ($opt_m) {
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
    }
#endif
    if (defined $msg) {
	my $unitID = $UnitIDs{$conn};
	my $len = length $msg;
#	print "($len)$msg", defined $unitID ? " $unitID\n" : "\n";
	if ($len == 0) {
	    if (defined $unitID and exists $Connections{$unitID}) {
		delete $Connections{$unitID};
		delete $UnitIDs{$conn};
		$conn->disconnect();
		if ($unitID =~ /^C/) {
		    $connICT = undef;
		} elsif (defined $connICT) {
		    # pass clear input message to ICT
		    print "I$unitID 0 to C0\n" if $opt_t;
		    $connICT->send_now("$unitID.0");
		}
		print "$unitID has disconnected\n";
	    }
	} elsif ($msg =~ /^[XBWC]\d+$/) {	# X0 X1 .. B0 .. W0 .. C0
	    my ($con1, $uID, $value, $mes1);
	    if (exists $Connections{$msg}) {
		delete $UnitIDs{$conn};
		$conn->disconnect();
		print "Trying to attach a device twice - disconnected\n";
	    } else {
		if ($msg =~ /^C/) {
		    if (defined $connICT) {
			delete $UnitIDs{$conn};
			$conn->disconnect();
			print "Trying to attach a second ICT - disconnected\n";
			return;
		    }
		    $connICT = $conn;		# the ICT connection
		    # new ICT connected - reset all the attached I/Os
		    foreach $con1 (sort keys %UnitIDs) {
			$uID = $UnitIDs{$con1};
			if (defined $uID) {
			    if ($uID =~ /^[BWX]/) {
				if (defined $Connections{$uID}) {
				    print "$msg R to $uID\n" if $opt_t;
				    $Connections{$uID}->send_now("R");
				} else {
				    print "$msg R to dummy $uID\n" if $opt_t;
				}
				$Values{$uID} = 0;	# save latest bit or analog value
			    }
			}
		    }
		}
		$UnitIDs{$conn} = $msg;
		$Connections{$msg} = $conn;
		print "Registered $msg at server\n";
		if ($msg =~ /^[BWX]/) {			# saved bit or analog value from ICT
		    $value = $Values{$msg};
		    if ($value) {
			print "ICS $value to Q$msg\n" if $opt_t;
			$Connections{$msg}->send_now("$value");
		    }
		}
	    }
	} elsif ($msg =~ /^[BWX]/) {			# bit or analog value messages from ICT
	    for my $msg1 (split /,/, $msg) {		# break up multiple value messages
		my ($uID, $value, $rest) = split /\./, $msg1, 3;
		if ($unitID eq 'C0' and defined $value and not defined $rest) {
		    if (defined $Connections{$uID}) {
			print "$unitID $value to Q$uID\n" if $opt_t;
			$Connections{$uID}->send_now("$value");
		    } else {
			print "$unitID $value to dummy Q$uID\n" if $opt_t;
		    }
		    $Values{$uID} = $value;		# save latest bit or analog value
		} else {
		    print "ERROR: $msg1 from Unit $unitID ?? ignored\n";
		}
	    }
	} elsif (defined $connICT) {			# value messages from I/O
	    # pass message to ICT (without checking syntax)
	    print "I$unitID $msg to C0\n" if $opt_t;
	    $connICT->send_now("$unitID.$msg");
	} else {
	    print "I$unitID $msg to dummy C0\n" if $opt_t;
	}
    }
#ifdef TIME_HIRES 
    if ($opt_m) {
	$t0 = [gettimeofday];
    }
#endif
}
