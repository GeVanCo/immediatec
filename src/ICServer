#!/usr/bin/perl -w

########################################################################
#
#	ICServer
#
#	Server which can accept any number of I/O clients
#	and initially one controller (planned are many)
#
#	John E. Wulff	28-May-2000
#
#	Protocol between I/O and PPLC clients and server:
#
#	Registration:	UnitID
#			X0 .. X31  from bit  I/O to server
#			B0 .. B31  from byte I/O to server
#			W0 .. W30  from word I/O to server
#			P0         from PPLC and server
#
#	I/O values:	Index,Value	
#			0,0 .. 7,1     from bit  I/O to server
#			0,0 .. 0,255   from byte I/O to server
#			0,0 .. 0,65535 from word I/O to server
#
#			UnitID,Index,Value	
#			X0,0,0 .. X31,7,1     from server to PPLC bit
#			B0,0,0 .. B31,0,255   from server to PPLC byte
#			W0,0,0 .. W30,0,65535 from server to PPLC word
#
#	The same formats are used from server to I/O and PPLC to server.
#	The direction of transmission determines if an I/O messages
#	is input or output.
#
#	Each I/O value message constitutes an event which updates
#	that value at the sink. Several messages may be grouped
#	and seperated by semi-colons (;) { TODO - not yet implemented }
#
#	Byte and Word sources and sinks only have Index 0.
#	Word source and sink Units must be even (W0 W2 W4 .. W30)
#
#	The Server receives messages from the I/O's, identifies the
#	UnitID under which that I/O is registered and prefixes the
#	UnitID and a comma to the message and sends it on to the PPLC.
#
#	Messages received from the PPLC are stripped of the leading
#	UnitID and comma. The rest is sent to the I/O Unit corresponding
#	to the UnitID stripped from the message.
#
########################################################################

use Msg;
use strict;

my %UnitIDs = ();
my %Connections = ();
my %Values = ();
my $connPPLC;

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:	@<<<<<<< [-th] [-s <host>] [-p <port>] [<list of client calls>]
	$named
	-s host	ID of server (default '0.0.0.0')
	-p port	service port for server and all clients
		(default '8778')
	-t	trace messages for debugging
	-h	help, ouput this Usage text only
	NOTE:	if a client call has arguments the call
		must be quoted. eg: 'DemoBox X0'
$Id: ICServer,v 1.13 2001/01/23 23:04:13 jw Exp $
.

use vars qw($opt_t $opt_s $opt_p $opt_h);
require "getopts.pl";
&Getopts('ts:p:h');			# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

########################################################################
#
#	Server
#
########################################################################

my $host = defined $opt_s ? $opt_s : '0.0.0.0';
my $port = defined $opt_p ? $opt_p : 8778;

Msg->new_server($host, $port, \&login_proc);
print "Server created. Waiting for events\n";

########################################################################
#
#	Start clients named in argument list
#
########################################################################

my $pid;
ARG: while ($ARGV = shift @ARGV) {
    FORK: {
	sleep 1 if defined $pid;
	next ARG if ($pid = fork);
	if (defined $pid) {	# $pid is zero if defined
	    # dispatch child process
	    my @call = split " ", $ARGV;
	    splice @call, 1, 0, '-p', $opt_p if defined $opt_p;
	    splice @call, 1, 0, '-t' if defined $opt_t;
	    print "@call\n";
	    exec @call;
	    exit;		# child process can't be executed
	} elsif ($! =~ /No more process/) {
	    # EAGAIN, recoverable fork error
	    sleep 5;
	    redo FORK;
	} else {
	    # weird fork error
	    die "Can't fork: $!\n";
	}
    }
}

Msg->event_loop();

########################################################################
#
#	Login procedure
#
########################################################################

sub login_proc {
    my ($conn, $host, $port) = @_;
    print "Connection $host:$port at server\n";
    # Unconditionally accept an incoming connection request
    $UnitIDs{$conn} = undef;
    return \&rcvd_msg_from_client;
}

########################################################################
#
#	Receive message from client
#
########################################################################

sub rcvd_msg_from_client {
    my ($conn, $msg, $err) = @_;
    if (defined $msg) {
	my $unitID = $UnitIDs{$conn};
	my $len = length $msg;
# print "($len)$msg", defined $unitID ? " $unitID\n" : "\n";
	if ($len == 0) {
	    if (defined $unitID and exists $Connections{$unitID}) {
		delete $Connections{$unitID};
		delete $UnitIDs{$conn};
		$conn->disconnect();
		if ($unitID =~ /^P/) {
		    $connPPLC = undef;
		} elsif (defined $connPPLC) {
		    # pass clear input message to PPLC
		    print "I$unitID 0 to P0\n" if $opt_t;
		    $connPPLC->send_now("$unitID,0");
		}
		print "$unitID has disconnected\n";
	    }
	} elsif ($msg =~ /^[XBWP]\d+$/) {	# X0 X1 .. B0 .. W0 .. P0
	    my ($con1, $uID, $value, $mes1);
	    if (exists $Connections{$msg}) {
		delete $UnitIDs{$conn};
		$conn->disconnect();
		print "Trying to attach a device twice - disconnected\n";
	    } else {
		if ($msg =~ /^P/) {
		    if (defined $connPPLC) {
			delete $UnitIDs{$conn};
			$conn->disconnect();
			print "Trying to attach a second PPLC - disconnected\n";
			return;
		    }
		    $connPPLC = $conn;		# the PPLC connection
		    # new PPLC connected - reset all the attached I/Os
		    foreach $con1 (sort keys %UnitIDs) {
			$uID = $UnitIDs{$con1};
			if (defined $uID) {
			    if ($uID =~ /^[BWX]/) {
				if (defined $Connections{$uID}) {
				    print "$msg R to $uID\n" if $opt_t;
				    $Connections{$uID}->send_now("R");
				} else {
				    print "$msg R to dummy $uID\n" if $opt_t;
				}
				$Values{$uID} = 0;	# save latest bit or analog value
			    }
			}
		    }
		}
		$UnitIDs{$conn} = $msg;
		$Connections{$msg} = $conn;
		print "Registered $msg at server\n";
		if ($msg =~ /^[BWX]/) {			# saved bit or analog value from PPLC
		    $value = $Values{$msg};
		    if ($value) {
			print "ICS $value to Q$msg\n" if $opt_t;
			$Connections{$msg}->send_now("$value");
		    }
		}
	    }
	} elsif ($msg =~ /^[BWX]/) {			# bit or analog value messages from PPLC
	    my ($uID, $value, $rest) = split /,/, $msg, 3;
	    if ($unitID eq 'P0' and defined $value and not defined $rest) {
		if (defined $Connections{$uID}) {
		    print "$unitID $value to Q$uID\n" if $opt_t;
		    $Connections{$uID}->send_now("$value");
		} else {
		    print "$unitID $value to dummy Q$uID\n" if $opt_t;
		}
		$Values{$uID} = $value;			# save latest analog value
	    } else {
		print "ERROR: $msg from Unit $unitID ?? ignored\n";
	    }
	} elsif (defined $connPPLC) {			# value messages from I/O
	    # pass message to PPLC (without checking syntax)
	    print "I$unitID $msg to P0\n" if $opt_t;
	    $connPPLC->send_now("$unitID,$msg");
	} else {
	    print "I$unitID $msg to dummy P0\n" if $opt_t;
	}
    }
}
