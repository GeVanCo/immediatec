#!/usr/bin/perl
use strict;
########################################################################
#	iCman developed from
#--------------------------------------------------------------
# perlman: man page viewer in Perl
#--------------------------------------------------------------
# in "Advanced Perl Programming"
#     by Sriram Srinivasan
#
#	modified by John E. Wulff to act as a HELP viewer
#	for iC Project widgets and all other man pages
#--------------------------------------------------------------
#	Changes from perlman:
# 1	Make Text window READ-ONLY
# 2	Use the search algorithm developed for iClive which moves
#	the text to 'see' the text that has been found.
# 3	Implement a history with previous and next buttons [<=] [=>]
# 4	Handle apropos topics with '-k <key>'
# 5	Dynamic change of font size with Alt- Alt+ and [-] [+] buttons
# 6	Handle whatis with '-f <page>'
########################################################################
use Tk;			# The graphical user interface toolkit perl/Tk
			##                   by Nick Ing-Simmons
use warnings;
use Encode;		# http://perlmonks.org/node_id=698074
my $enc = 'utf-8';	# suggested by Kardan
# use utf8;		# <- makes everything worse

my $named = $0; $named =~ s#.*[/\\]##;
use vars qw($opt_c $opt_n $opt_k $opt_f $opt_F $opt_l $opt_w $opt_g $opt_r $opt_T $opt_X $opt_h);
my $ofh = select(STDERR);	# save old file handle
$= = 100;			# stop page overflow (default 60 lines)
select($ofh);			# retore old file handle

format STDERR =
Usage:
@<<<< [ -cnrTh][ -k <key>][ -f <page>][ -F <font>][ -l <num>][ -w <num>]
 $named
      [ -g <geometry>][ [<section>] <manpage> ...] ...
    -k key  display the output of man -k <key> (apropos) which provides
            man page links to the topic described by <key>.
    -f page display the output of man -f <page> (whatis)
    -F font font or font size to use in Text window (default '14')
    -l num  height of the Text window (default @<)
					$opt_l
    -w num  width  of the Text window (default @<)
					$opt_w
    -g geom geometry for main window
    -c      build a new cache of section names (default: use cache)
    -n      no fork of initial window (used in internal fork call)
            (default is to fork the initial window)
    -r      restore last session with manpage and search history
    -T      trace output static debug messages
    -h      help, ouput this Usage text only

    Manpage arguments may be of the form <section> <manpage>, which is
    the classical call for 'man'. <manpage>(<section>) may be used as
    an alternative, but this form must be quoted for the shell.  In
    either case <section> must be a valid section name.

    One or more manpage arguments may be used - these are placed in
    the history. If no manpage arguments are specified or if the -r
    option is used, the last session is restored with all its manpage
    and search history. The first manpage in the history is opened.
    This is either the first manpage argument or the first manpage
    in the previous session history.

 Menu buttons:                   Action                      Accelerator
    [man] Show  a new manpage - in this window                   RETURN
                (followed by an optional section in parentheses)
                Alternatively show a list of topics matching a key
                with '-k <key>' or 'apropos <key>' entered in the
                show window.
                Double-clicking on a word in the text which is the
                name of another man page will also open that page.
       Open     a new window - to show selected manpage         Alt-RET
       Quit     quit the program.                                   q

    [ <= ]      Load the previous manpage in the history.           p
    [ => ]      Load the next manpage in the history.               n
            Holding either of these buttons down briefly will
            open a menu of history items which can be selected.

    [Headings]  Skip to one of the headings in the manpage.
    [Sections]  Load the index for one of the manpage sections.

    [ / ]       Put focus in Search Entry window if cleared.        /
                    (simulates vi)                            or  Alt-/
                Else start or continue a search of text in
                the Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options and a history of previous searches.
       Search down       or                                      RETURN
                displays a new group of hits.
       Search up         or                                   Shift-RET
                reverses the direction of scrolling.
       Clear             or                                    Ctrl-RET
                clears hits and the search Entry window.
     <>Go to line        or                                     Alt-RET
                goes to the line entered in the Entry window.
     <>Exact match
     <>Ignore case
     <>Regexp match
     <>Rgexp+ignore case

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Help]      Display the @<<<< man page.                         h
			    $named

Copyright (C) 2000-2012  John E. Wulff          <immediateC@gmail.com>
							  '@'
The core of this program is from from 'perlman' by Sriram Srinivasan
published in 'Advanced Perl Programming' - gratefully acknowledged.
$Id: iCman,v 1.15 2012/11/24 04:50:34 jw Exp $ uses Tk-@<<<<<<<<<
						    $Tk::VERSION
.

########################################################################
#	Global variables
########################################################################

my $menu_headings;	# "Headings" MenuButton
my $ignore_case;	# 1 if check-button on in Search menu
my $match_type;		# '-regexp' or '-exact'.
my $mainWindow;		# Main window
my $text;		# Main text widget
my %sections;		# Maps section ('1', '3' ,'3n' etc.)
my $info = '';		# info messages in status bar
my @dynamicHistory = ();# maintain a history of man pages viewed
my $hi = 0;		# history index
my $pi = 0;		# previous index
my $opt = '';
my $searchText = '';

# has to be global, 'our' not portable yet
my (@hits, @groups, $gi, $gl, $centre, $lineCnt);
my $prevText = '';
my $prevMatch = '';

########################################################################
#
#	Handle signals
#
#	Perl-Tk applications cannot catch a HUP or TERM signal sent by the
#	Linux system at LOGOUT or SHUTDOWN, because the underlying X-Server
#	is already brought down by the HUP and seems to halt all Tk applications
#	at that point in time
#
#	The following is an extract from the XSERVER(1) man page:
#
#	The X server attaches special meaning to the following signals:
#
#	SIGHUP
#	    This signal causes the server to close all existing connections,
#	    free all resources, and restore all defaults. It is sent by
#	    the display manager whenever the main user's main application
#	    (usually an xterm or window manager) exits to force the server
#	    to clean up and prepare for the next user.
#	SIGTERM
#	    This signal causes the server to exit cleanly.
#
########################################################################

$SIG{HUP} = \&quit_program;	# catch signal from signal 1
$SIG{TERM} = \&quit_program;	# catch signal from signal 15

$SIG{PIPE} = \&catch_sig;	# catch signal in pipe from man

########################################################################
#	Command line options
########################################################################

use Getopt::Std;		# replace require "getopts.pl";
getopts('cnk:f:F:l:w:g:rTXh');	# sets $opt_h if -h etc

exit -1 if $opt_X;		# $named -X called in forked process if first exec fails
$opt_l = 35 unless $opt_l;	# if any higher on 768 pixel high screen, status bar is hidden
$opt_w = 80 unless $opt_w;	# just allows all buttons to fit in the top menu bar
				# also gives a bit more room for oversize texts
if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my ($fontSize, $font_t, $boldfont_t, $font, $boldfont);
if (defined $opt_F) {
    if ($opt_F =~ /^\d+$/) {
	$fontSize = $opt_F;
    } else {
	$font_t = $opt_F;
    }
}
unless ($font_t) {
    if ($ENV{COMSPEC}) {	# defined on Windows 98 and Windows XP
	$fontSize = 12 unless $fontSize;
	$font_t = "{Lucida Console} fontSize normal";
    } else {			# Linux
	$fontSize = 14 unless $fontSize;
	$font_t = "-adobe-courier-medium-r-normal--fontSize-100-100-100-m-90-iso8859-1";
    }
}
if ($font_t =~ /medium/) {
    $boldfont_t = $font_t;
    $boldfont_t =~ s/medium/bold/;
} else {
    $boldfont_t = "-adobe-courier-bold-r-normal--fontSize-100-100-100-m-90-iso8859-1";
}
change_font(0, 0);		# set initial font size to $fontSize

no warnings;
print "fontSize = '$fontSize'\nfont     = '$font'\nboldfont = '$boldfont'\n" if $opt_T;
use warnings;

scout_man_dirs();
to_background() unless $opt_n;	# run window as a  forked process

########################################################################
#	Analyse command line ARGV
########################################################################
my $section = '';
my $sectionFlag = 0;
if ($opt_k) {
    push @dynamicHistory, "-k $opt_k";	# apropos: man -k <key>
}
if ($opt_f) {
    push @dynamicHistory, "-f $opt_f";	# whatis:  man -f <page>
}
print "$named: \@ARGV '@ARGV'\n" if $opt_T;
while (@ARGV) {
    my $man = shift @ARGV;
    if ($man and $man =~ /^\d+x\d+(\+\d+\+\d+)?$/) {
	$opt_g = $man;		# iCman restored after logout and restore
    }
    elsif (is_valid_section("($man)")) {
	$section = $man;	# argumments: 1 man (classical man call)
	$sectionFlag = 1;
    }
    elsif ($section ne '') {	# allows section 0
	push @dynamicHistory, "$man($section)";
	$sectionFlag = 0;
    }
    else {
	push @dynamicHistory, "$man";	# argument: man or man(1)
    }
}

########################################################################
#	Main Window
########################################################################

$mainWindow = MainWindow->new();
if ($opt_g) {
    if ($opt_g =~ /^(\d+x\d+)?([+-]\d+[+-]\d+)?$/) {
	$mainWindow->geometry($opt_g);
    } else {
	warn "WARNING: bad geometry '$opt_g' - ignored\n";
	$opt_g = '';
    }
}
$mainWindow->title("$named");
$mainWindow->protocol('WM_DELETE_WINDOW', \&quit_program);	# Windows (X) pressed

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack(-side => 'top', -fill => 'x');

########################################################################
#	Man Button
########################################################################
my $menuMan = $menuBar->Menubutton(-text               => 'man',
				   -relief             => 'raised',
				   -borderwidth        => 2,
				   -takefocus          => 1,
				   -highlightthickness => 1,
				   -tearoff            => 1,	# tear off line 0
				  )->pack(-side => 'left', -padx => 2);

$menuMan->command(-label       => 'Show in this window',		# 1
		   -accelerator => 'Return',
		   -command     => [ \&show_man, 0, undef, undef, 0 ]); # overlay
$menuMan->command(-label       => 'Open a new window',			# 2
		   -accelerator => 'Alt-Ret',
		   -command     => [ \&show_man, 0, undef, undef, 1 ]); # fork
$menuMan->command(-label       => 'Quit',				# 3
		   -accelerator => 'q',
		   -command     => [ \&quit_program ]);			# quit

########################################################################
#	Man entry window
########################################################################
my $entryMan = $menuBar->Entry(-width       => 16,
			       )->pack(-side => 'left', -padx => 2);

####### Man entry bindings #############################################
$entryMan->bind('<Key-Return>',		[ \&show_man, undef, undef, 0 ]); # overlay
$entryMan->bind('<Alt-Key-Return>',	[ \&show_man, undef, undef, 1 ]); # fork
$entryMan->bind('<Alt-Key-plus>',	[ \&change_font, 2     ]); # increase font
$entryMan->bind('<Alt-Key-minus>',	[ \&change_font, -2    ]); # decrease font
$entryMan->bind('<Alt-Key-q>',		[ \&quit_program ]);

########################################################################
#	Previous man page button
########################################################################
my $prevButton = $menuBar->Button(-text        => '<=',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -state       => 'disabled',
				  -command     => [ \&show_man, '', -1, ,1 ],	# Release-1
				 )->pack(-side => 'left', -padx => 2);
$prevButton->bind('<ButtonPress-1>',	[ \&ManMenu, \$prevButton, ]);

########################################################################
#	Next man page button
########################################################################
my $nextButton = $menuBar->Button(-text        => '=>',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -state       => 'disabled',
				  -command     => [ \&show_man, '', 1, ,1 ],	# Release-1
				 )->pack(-side => 'left', -padx => 2);
$nextButton->bind('<ButtonPress-1>',	[ \&ManMenu, \$nextButton, ]);

my $manMenu = $mainWindow->Menu();	# filled dynamically
my $manTimer;
my $manMenuStart = 0;		# first dynamic entry:  # 0
my $manMenuLim   = 30;		# number of dynamic entries (fairly large)

########################################################################
#	Headings menu
########################################################################
$menu_headings = $menuBar->Menubutton(-text => 'Headings',
				      -relief => 'raised',
				      -borderwidth => 2,
				      -takefocus   => 1,
				      -highlightthickness => 1,
				     )->pack(-side => 'left', -padx => 2);

########################################################################
#	Sections menu
########################################################################
my $menu_sections = $menuBar->Menubutton(-text => 'Sections',
					 -relief => 'raised',
					 -borderwidth => 2,
					 -takefocus   => 1,
					 -highlightthickness => 1,
					)->pack(-side => 'left', -padx => 2);
# Populate sections menu with keys of % sections
my $section_name;
foreach $section_name (sort keys %sections) {
    $menu_sections->command (
	     -label => "($section_name)",
	     -command => [\&show_section_contents, $section_name]);
}

########################################################################
#	Search button
########################################################################
my $searchButton = $menuBar->Button(-text        => '/',
				    -relief      => 'raised',
				    -borderwidth => 2,
				    -command     => [ \&search_text, 0, undef, 0 ],	# Release-1
				   )->pack(-side => 'left', -padx => 2);
$searchButton->bind('<ButtonPress-1>',	[ \&SearchMenu, \$searchButton, ]);

########################################################################
#	Search menu
########################################################################

my $searchMenu = $mainWindow->Menu();	# filled dynamically
my $searchTimer;
my $matchType = "-exact";		# default, alternatives -nocase -regexp

$searchMenu->command(-label       => 'Search down',			# 1
		     -accelerator => 'Return',
		     -command     => [ \&search_text, 1, undef, 0 ]);
$searchMenu->command(-label       => 'Search up',			# 2
		     -accelerator => 'Shift-Ret',
		     -command     => [ \&search_text, 1, undef, 1 ]);
$searchMenu->command(-label       => 'Clear',				# 3
		     -accelerator => 'Ctrl-Ret',
		     -command     => [ \&search_text, 1, '',    0 ]);
########################################################################
#	Goto line number
########################################################################
$searchMenu->radiobutton(-label    => 'Go to line',			# 4
			 -accelerator => 'Alt-Ret',
			 -value    => 'g',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 2 ]);
########################################################################
#	Exact match
########################################################################
$searchMenu->radiobutton(-label    => 'Exact match',			# 5
			 -value    => '-exact',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Ignore case
########################################################################
$searchMenu->radiobutton(-label    => 'Ignore case',			# 6
			 -value    => '-nocase',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match
########################################################################
$searchMenu->radiobutton(-label    => 'Regexp match',			# 7
			 -value    => '-regexp',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match - Ignore case
########################################################################
$searchMenu->radiobutton(-label    => 'Regexp Ignore case',		# 8
			 -value    => 'ri',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
$searchMenu->separator();						# 9
my $searchMenuStart  = 10;			# first dynamic entry:  #10
my @dynamicSearches  = ();			# maintain local dynamic entries
my $searchMenuLim    = 10;			# number of dynamic entries

########################################################################
#	Search entry
########################################################################
my $entrySearch = $menuBar->Entry(-width        => 16,
				  -textvariable => \$searchText,
				 )->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom in button
########################################################################
$menuBar->Button(-text        => '-',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', -2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom out button
########################################################################
$menuBar->Button(-text        => '+',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', 2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Help button
########################################################################
$menuBar->Button(-text        => 'Help',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => \&show_help,
		)->pack(-side => 'right', -padx => 2);

########################################################################
#	Ini data for man and search menu lists
########################################################################
my %iniMenuData = (
    history	=> [
	$manMenu,		# menuRef,	man menu
	\@dynamicHistory,	# entriesArray,	maintain local dynamic entries
	$manMenuStart,	# menuPos,	start of dynamic entries
	$manMenuLim,	# entriesLim,	number of dynamic entries
	\&open_file,		# commandRef,	call back for open file
    ],
    searches	=> [
	$searchMenu,		# menuRef,	search menu
	\@dynamicSearches,	# entriesArray,	maintain local dynamic entries
	$searchMenuStart,	# menuPos,	start of dynamic entries
	$searchMenuLim,		# entriesLim,	number of dynamic entries
	\&search_text,		# commandRef,	call back for search text
    ],
);

my %matchExtensions = (
    -exact	=> '',
    -nocase	=> '	i',
    -regexp	=> '	r',
    ri		=> '	ri',
    g		=> '	g',
);
my %matchRestores = (
    e		=> '-exact',
    i		=> '-nocase',
    r		=> '-regexp',
    ri		=> 'ri',
    g		=> 'g',
);

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
				 -relief       => 'ridge',
				)->pack(-side => 'bottom', -fill => 'x');

########################################################################
#	Text window
########################################################################
$text = $mainWindow->Scrolled('Text',
			      -scrollbars => 'osoe',
			      -setgrid    => 2,
			      -background => 'cornsilk1',
			      -wrap       => 'none',
			      -font       => $font,
			     )->pack( -fill => 'both', -expand => 1);
unless ($opt_g) {
    $text->configure (-width  => $opt_w);
    $text->configure (-height => $opt_l);
}

my $yScrollbar = $text->Subwidget('yscrollbar');
my $xScrollbar = $text->Subwidget('xscrollbar');

$text->configure (-cursor => 'left_ptr');
# Use xterm-color settings for attributes if available
my $colorUL = $text->cget (-foreground);
my $colorBD = $colorUL;
# foreach my $xrdb (`xrdb -q`) {
#     $xrdb =~ m/\*(colorBD|colorUL)\s*:\s*(\S+)/ || next;
#     $1 eq "colorBD" ? $colorBD : $colorUL = $2;
# }
$text->tagConfigure('section', -font => $boldfont, -foreground => $colorBD);
$text->tagConfigure('bd',  -font => $boldfont);
$text->tagConfigure('ul',  -underline => 1,    -foreground => $colorUL);

####### Key and Mouse button bindings ##################################
####### Search entry bindings ##########################################
$entrySearch->bind('<Key-Return>',		[ \&search_now, undef, 0  ]); # search down
$entrySearch->bind('<Shift-Key-Return>',	[ \&search_now, undef, 1  ]); # search up
$entrySearch->bind('<Control-Key-Return>',	[ \&search_now, '',    0  ]); # clear
$entrySearch->bind('<Alt-Key-Return>',		[ \&search_now, undef, 2  ]); # go to line
$entrySearch->bind('<Key-Down>',		[ \&scroll_text, 1        ]); # scroll down
$entrySearch->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$entrySearch->bind('<Key-Next>',		[ \&scroll_text, $opt_l-2 ]); # next page
$entrySearch->bind('<Key-Prior>',		[ \&scroll_text,-$opt_l+2 ]); # prior page
$entrySearch->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$entrySearch->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
$entrySearch->bind('<Alt-Key-q>',		[ \&quit_program          ]);
$entrySearch->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
####### Text window bindings ###########################################
$text      ->bind('<Button-1>',			[ \&report_cursor         ]); # report cursor position
$text      ->bind('<Key-q>',			[ \&quit_program          ]);
$text      ->bind('<Alt-Key-q>',		[ \&quit_program          ]);
$text      ->bind('<Double-1>',			[ \&pick_word, 0,         ]); # follow a text link
# $text      ->bind('<Shift-Double-1>',		[ \&pick_word, 1,         ]); # follow a text link to a new window
####### Y-Scrollbar bindings ###########################################
$yScrollbar->bind('<Key-p>',			[ \&show_man, -1          ]); # previous history entry
$yScrollbar->bind('<Key-n>',			[ \&show_man, 1           ]); # next history entry
$yScrollbar->bind('<Key-h>',			[ \&show_help             ]);
$yScrollbar->bind('<Key-q>',			[ \&quit_program          ]);
$yScrollbar->bind('<Alt-Key-q>',		[ \&quit_program          ]);
$yScrollbar->bind('<Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Key-Right>',		[ \&scroll_x_text, 1      ]); # scroll right
$yScrollbar->bind('<Key-Left>',			[ \&scroll_x_text, -1     ]); # scroll left
$yScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$yScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
####### Search entry bindings ##########################################
$yScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$yScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$yScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear
$yScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
$yScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$yScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
####### X-Scrollbar bindings ###########################################
$xScrollbar->bind('<Key-Down>',			[ \&scroll_text, 1        ]); # scroll down
$xScrollbar->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$xScrollbar->bind('<Key-Next>',			[ \&scroll_text, $opt_l-2 ]); # next page
$xScrollbar->bind('<Key-Prior>',		[ \&scroll_text, -$opt_l+2]); # prior page
$xScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$xScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
####### Search entry bindings ##########################################
$xScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$xScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$xScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear
$xScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
$xScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$xScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
####### Useful line to determine Key binding symbols ###################
# $yScrollbar->bind('<KeyPress>' => sub { my $k =$Tk::event->K ; my $n = $Tk::event->N; info_display('black', "KeySym=$k, numeric=$n"); });

########################################################################
#	Initialise program
########################################################################
if ($sectionFlag) {
    info_display('red', "ERROR: last argument '$section' is a section");
    warn "ERROR: last argument '$section' is a section";
}
# set MAN_KEEP_FORMATTING to make 'man' output bold and underline codes
$ENV{MAN_KEEP_FORMATTING} = 1;	# set for duration of this execution

if ($opt_r or not @dynamicHistory) {
    ini_program();		# restore last session
}
if (@dynamicHistory) {
    if (@dynamicHistory > 1 - $sectionFlag) {
	$nextButton->configure(-state => 'normal');
    }
    show_man('', 1) unless $sectionFlag;	# show first argument
}

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################
$mainWindow->repeat(1000, sub {});	# do a few perl ops every second to catch signals
MainLoop();
exit(0);

####### End of main program ############################################

########################################################################
#	Catch miscellaneous signals
########################################################################

sub catch_sig {
    my $signame = shift;
    die "$named: Somebody sent me a SIG$signame: $!";
} # catch_sig

########################################################################
#
#	Display information on the info bar
#	(make sure all displays to info bar go via this routine)
#	Parameter 1:	colour (change if $message ne '')
#	Parameter 2:	message text
#
########################################################################

sub info_display {
    my ($colour, $message) = @_;
    $infoBar->configure(-foreground => $colour) if $message ne '';
    $info = $message;	# display now
} # info_display

########################################################################
#
#	Report the cursor position in the info bar
#
########################################################################

sub report_cursor {
    my $cursor = $text->index('insert');		# '27.0'
    $cursor =~ m/(\d+)\.(\d+)/;
    my $x = $2 + 1;
    info_display('black', "line $1, char $x");		# 'line 27 char 1'
} # report_cursor

########################################################################
#
#	Position window so that index is at its centre if possible
#	Parameter 1:	index into $text
#
########################################################################

sub seeCentre {
    my ($index) = @_;
    # re-compute window details in case text and/or window has changed
    $text->yview('moveto', 0);		# window to top left of text so bbox works
    my ($x, $y, $w, $lineHeight) = $text->bbox("1.0");
    print "bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
    my $h = $text->height;		# current height of display window in pixels
    my $height = int($h/$lineHeight);	# current height of display window in lines
    $index =~ /(\d+)\.(\d+)/;
    $y = int ($1 - ($height / 2));
    $y = 0 if $y < 0;
    $text->yview('moveto', $y / $lineCnt);
} # seeCentre

########################################################################
#
#	Show a new manual page
#	parameter 1:	dummy for key bindings
#	parameter 2:	hFlag if not true use showEntry text
#			else 1/-1 get next/previous history entry
#	parameter 3:	buttonFlag if true command is from next/previous button
#	parameter 4:	forkFlag if true Shift-RETURN from show->bind (fork)
#
########################################################################

sub show_man {
    my ($entry, $hFlag, $buttonFlag, $forkFlag) = @_;
    my ($ret, $man, $section, $cmdLine, $i, $s);
no warnings;
    print "show_man: \$hFlag=$hFlag, \$hi=$hi, \@dynamicHistory '@dynamicHistory'\n" if $opt_T;
use warnings;
    if ($buttonFlag) {
	ManCancel();			# do this first - no delays yet
    }
    if ($hFlag) {
	if ($hFlag == 1) {
	    if ($hi >= @dynamicHistory) {
		info_display('red', "History exhausted");
		return;			# happens with 'n' key
	    }
	    $entry = $dynamicHistory[$hi++];	# next history entry
	} else {
	    if ($hi < 2) {
		info_display('red', "History exhausted");
		return;			# happens with 'p' key
	    }
	    $hi -= 2;
	    $entry = $dynamicHistory[$hi++];	# previous history entry
	}
	print "show_man: history entry: '$entry'\n" if $opt_T;
	$entryMan->delete('0', 'end');
	$entryMan->insert('end', $entry);
    } else {
	$entry = $entryMan->get();	# get entry from $entryMan
	print "show_man: show entry: '$entry'\n" if $opt_T;
    }
    if ($entry =~ /^(-[fk]|\w+)\s+([\w:+.-]+)/) {
	if ($1 eq '-k' or $1 eq 'apropos') {
	    ($opt, $man, $section) = ('-k', $2, '');
	} elsif ($1 eq '-f' or $1 eq 'whatis') {
	    ($opt, $man, $section) = ('-f', $2, '');
	} elsif (is_valid_section("($1)")) {
	    ($opt, $man, $section) = ('', $2, "($1)");
	} else {
	    ($opt, $man, $section) = ('', $2, '');
	}
    } elsif ($entry =~ /^([\w:+.-]*)\s*(\(.*\))?/) {
	($opt, $man, $section) = ('', $1, $2);
    }
    if ($opt or not $section or not is_valid_section($section)) {
        $section = '';
    }
no warnings;
    print "$entry: kopt = '$opt' man = '$man' section = '$section' forkFlag = '$forkFlag'\n" if $opt_T;
use warnings;
    if ($forkFlag) {			# hFlag cannot be set
	my @call = ($0, '-n', $man);
	$section =~ s/[()]//g;	# remove parens (will pass '' unchanged)
	$section = $opt if $opt;
	splice @call, 2, 0, $section if $section ne '';
	print "fork_and_exec(@call)\n" if $opt_T;
	fork_and_exec(@call);		# open the page in a new iCman window
	return;
    }
    # UI is clean now. Open the file
    ($s = $section) =~ s/[()]//g;	# remove parens (will pass '' unchanged)
    $cmdLine = $opt ? "man $opt $man 2>/dev/null | sort -u |"	# output of apropos or whatis
			 : "man $s $man 2>/dev/null |";
    print "open (F, '$cmdLine')\n" if $opt_T;
    if ($ret = open (F, $cmdLine)) {
	printf ("\$ret = '0x%x'\n", $ret) if $opt_T;
	my $lineFlag = 0;
	my $line;
	my $mark;
	my $prev;
	my $tag;
	while ($line = <F>) {
	    if ($lineFlag == 0) {
		########################################################################
		# First line - if open has error it reads a null file and never gets here
		# Erase everything to do with current page (contents, menus, marks)
		########################################################################
		$lineFlag = 1;
		$lineCnt = 0;
		$text->configure (-state  => 'normal');
		$text->configure (-cursor => 'watch' );
		$text->update();
		$menu_headings->menu()->delete(0,'end'); # Delete current headings
		foreach $mark ($text->markNames) {  # remove all marks
		    $text->markUnset($mark);
		}
		if ($searchText) {		# keep searchText
		    search_now(0, '', 1);	# clear search structures immediately
		}
		$text->delete('1.0', 'end');	# erase current page
		$prev = '';
		$tag = undef;			# not 'bd' or 'ul'
	    }
	    $mark = $line;
	    chomp $mark;
	    # Squeeze multiple blank lines producing only one blank line.
	    $mark eq '' && $prev eq '' && next;
	    $prev = $mark;
	    # If first character is a capital letter, it's likely a section
	    # unless it is the first line (standard man heading)
###	    print("text line:       $line") if $opt_T;
	    if ($lineCnt++ and not $opt and $line =~ s/^(\e\[(\d+)m)?([A-Z][\w ]*)(\e\[(\d+)m)?$/$3/) {
		# Likely a section heading
		$mark = $line;			# $mark has section title
		$mark =~ s/.//g;		# take out possible bold and underline repeats
		chomp $mark;
		my $index = $text->index('end');	# note current end location
		# Give 'section' tag to the section title
		$text->insert('end', "$mark\n", 'section');
###		print("section heading: $mark\n") if $opt_T;
		# Create a menu entry. Have callback invoke text widget's
		# 'see' method to go to the index noted above (pass index in 1st parameter)
		$menu_headings->command(-label   => $mark,
					-command => [ sub { seeCentre($_[0]) }, $index ],
				       );
	    } else {
		if ($Tk::VERSION =~ /800/) {
		    $line =~ s/\342\224\202/|/g;# man translates '|' into 226 148 130 ?! SuSE 9.1
		    $line =~ s/\302\255/-/g;	# precedes '-' for word syllabification from 'man' SuSE 9.1
		    $line =~ s/\342\200\220/-/g;# precedes '-' for word syllabification from 'man' SuSE 9.3
		    $line =~ s/\342\213\205/°/g;# bullet
		    $line =~ s/\302\264/´/g;	# acute accent
		    $line =~ s/\303\327/x/g;	# multiplication sign
		} else {	# Tk-804.xxx
		    $line = decode($enc, $line);	# take care of utf-8 chars
		}
		# Underlining, Boldfacing
		# assume oversriking and underlining with _^H is not mixed with ESC sequences
		while ($line =~ s/(.)//) {
		    my $o = $1;
		    $text->insert("end", $`);
		    ($line = $') =~ s/^(.)//;
		    if ($1 eq $o) {			# Overstrike
			$text->insert ("end", $1, 'bd');
			# $o can be any character
			# 1 while s/^$o//; i.e. will fail on '/' and '\'
			substr ($o, 0, 0) = "";
			while (substr ($line, 0, 2) eq $o) {
			    substr ($line, 0, 2) = "";	# Multiple overstrike
			}
		    }
		    elsif ($o eq "_") {		# Underline
			$text->insert ("end", $1, 'ul');
		    }
		    else {				# NYI
			$text->insert ("end", $1);
		    }
		}
		# Underlining, Boldfacing with ESC sequences
		# ESC [ 1 m	start Bold
		# ESC [ 1 m	start Bold
		# ESC [ 0 m	stop Bold at end of line
		# ESC [ 2 2 m	stop Bold in middle of line
		# ESC [ 4 m	start Underline
		# ESC [ 2 4 m	stop Underline
		# assume any other number than 1 and 4 stops both Bold and Underline
		# ussually last ESC code is a stop, although it does not have to be
		while ($line =~ s/\e\[(\d+)m//) {
		    if (length $`) {
			$text->insert("end", $`, $tag);	# text before ESC with current tag
		    }
		    $line = $';			# rest of the line after ESC code
		    if ($1 == 1) {
			$tag = 'bd';		# Bold
		    } elsif ($1 == 4) {
			$tag = 'ul';		# Undeline
		    } else {
			$tag = undef;		# normal text
		    }
		}
		$text->insert('end', $line, $tag);	# trailing text - just insert
	    }
	}
	$ret = close(F);	# fails with $?/256 == 16 - page does not exist
	if ($lineFlag) {
	    unless ($hFlag) {
		splice @dynamicHistory, $hi, 0, $entry;	# store new entry in history, keeping forwards
		for ($i = 0; $i < @dynamicHistory; $i++) {
		    if ($i != $hi and $entry eq $dynamicHistory[$i]) {
			splice @dynamicHistory, $i, 1;		# splice out duplicate entry
			if ($i < $hi) {
			    $hi--;
			}
			last;
		    }
		}
		$hi++;
	    }
	    $mainWindow->title("$named: $entry");
	    $manMenu->delete(0, 'end');
	    foreach $i (0 .. $#dynamicHistory) {
		print "History Menu $i '$dynamicHistory[$i]'\n" if $opt_T;
		$manMenu->command(
		    -label   => $dynamicHistory[$i],
		    -state   => $i == $hi-1 ? 'disabled' : 'normal',
		    -command => [ \&select_history, $i, ],
		);
	    }
	    if ($hi < @dynamicHistory) {
		$nextButton->configure(-state => 'normal');
	    } else {
		$nextButton->configure(-state => 'disabled');
	    }
	    if ($hi > 1) {
		$prevButton->configure(-state => 'normal');
	    } else {
		$prevButton->configure(-state => 'disabled');
	    }
	    $text->configure (-cursor => 'left_ptr');
	    $text->update();
	    info_display('blue', "Loaded $opt $man$section $lineCnt lines");
	} else {
	    if ($hi) {
		if ($hFlag) {			# happens only with wrong entry in command line
		    splice @dynamicHistory, $hi-1, 1;	# splice out error entry
		    if ($hFlag == 1) {
			$hi--;			# next entry needs to go back
		    }
		} elsif ($pi) {
		    for ($i = 0; $i < @dynamicHistory; $i++) {
			if ($entry eq $dynamicHistory[$i]) {
			    splice @dynamicHistory, $i, 1;	# splice out duplicate entry
			    if ($i < $pi) {
				$pi--;
			    }
			    $hFlag = 1;
			    last;
			}
		    }
		}
		if ($hFlag) {
		    $hi = $pi if $pi;
		    $entry = $dynamicHistory[$hi-1];	# restore current entry and show text
		    $entryMan->delete('0', 'end');
		    $entryMan->insert('end', $entry);
		}
	    }
	    info_display('red', "No manual entry for $opt $man$section");
	}
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
    } else {
	info_display('red', "'$cmdLine' returned '$ret' ($?)");
    }
    $pi = 0;
} # show_man

########################################################################
#
#	Select history entry
#	Parameter 1:	$i is index into @dynamicHistory
#	NOTE: this routine calls show_man() with modified $hi
#
########################################################################

sub select_history {
    my ($i) = @_;
    $entryMan->delete ('0', 'end');
    $entryMan->insert ('end', $dynamicHistory[$i]);
    $pi = $hi;			# save history index in previous index
    $hi = $i + 1;		# move history index
    show_man();
} # select_history

########################################################################
#
#	Check for a valid section
#
########################################################################

sub is_valid_section {
    my $section = $_[0];
    if ($section =~ /\((.*?)\)/) {
	$section = $1;
	my $s;
	foreach $s (keys %sections) {
	    if (lc($s) eq lc($section)) {
		return 1;
	    }
	}
    }
    return 0;
} # is_valid_section

########################################################################
#
#	Pick a word for creating a hyperlink
#	parameter 1:	dummy for key bindings
#	Parameter 2:	0 open in new window
#			1 fork to a new window
#
########################################################################

sub pick_word {
    my ($dummy, $forkFlag) = @_;
    my $start_index = $text->index('insert wordstart');
    my $end_index = $text->index('insert lineend');
    my $line = $text->get($start_index, $end_index);
    my ($page, $section) = ($line =~ /^([\w:+.-]+)\s*(\(.*?\))?/);
no warnings;
    print "pick_word: forkFlag = $forkFlag page = '$page' section = '$section'\n" if $opt_T;
use warnings;
    if ($page) {
	$entryMan->delete('0', 'end');
	if ($section && is_valid_section($section)) {
	    $entryMan->insert('end', "$page${section}");
	} else {
	    $entryMan->insert('end', $page);
	}
	show_man(undef, undef, undef, $forkFlag);
    }
} # pick_word

########################################################################
#
#	Show section contents
#
########################################################################

sub show_section_contents {
    my $current_section = $_[0];
    if (exists $sections{$current_section}) {
	$text->configure(-state => 'normal');
	$text->delete('1.0', 'end');
	$menu_headings->menu()->delete(0,'end');
	my $spaces = " " x 40;
	my $words_in_line = 0;  # New line when this goes to three
	my $man;
	foreach $man (@{$sections{$current_section}}) {
	    $text->insert('end', $man . substr($spaces,0, 24 - length($man)));
	    if (++$words_in_line  == 3) {
		$text->insert('end', "\n");
		$words_in_line = 0;
	    }
	}
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
    }
} # show_section_contents

########################################################################
#
#	Scout the man directories for section names
#
#	Since this may take some time, particularly if the system is busy,
#	the result of the scan is cached in ~/.iC/iCman.sec.
#	A full scan is carried out each new day. This should be sufficient
#	to catch any new man entries. Alternetively 'iCman -c' may be used
#	to build a new cache after new software has been installed.
#
########################################################################

use Cwd;
sub scout_man_dirs {
    my (@man_dirs, $man_dir, $section, $home);
    my @date = split ' ', `date`;	# get current system date
    my $newDate = join ' ', @date[0..2];# keep date part only
    if (($home = $ENV{HOME}) ne '' and	# restore section lists from ~/.iC/iCman.sec
	not $opt_c and			# $home must be set before $opt_c is tested
	(-d "$home/.iC" or mkdir "$home/.iC") and
	open(INI, "$home/.iC/$named.sec")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$section = $1;			# section found
		if ($section =~ /DATE (.*)/) {
		    my $oldDate = $1;
		    $section = '';
		    if ($newDate ne $oldDate) {
			close(INI);
			goto NewCache;
		    }
		}
	    } elsif ($section and /^\t/) {	# ini starts with <tab>
		my @new_list = split;		# all sections in one line
		$sections{$section} = \@new_list;
	    }
	}
	close(INI);
	return;				# use cache values
    }					# ignore if ~/.iC/iCman.sec cannot be opened or found or -c
  NewCache:
    %sections = ();			# start filling cache
    print STDERR "Scouting man directories\n";
    if ($ENV{MANPATH}) {
        @man_dirs = split (/:/, $ENV{MANPATH});
    } else {
        push (@man_dirs, "/usr/man");
    }
    # Convert all relative man paths to fully qualified ones, by
    # prepending with $cwd
    my $cwd = cwd();
    foreach $man_dir (@man_dirs) {
        next if ($man_dir =~ m|^/|);
        $man_dir = "$cwd/$man_dir"; # Modifies entry in man_dirs
    }
    foreach $man_dir (@man_dirs) {
        chdir $man_dir || next;
        # Now, in /usr/man, say. Get all the directories
        my @section_dirs = grep {-d $_} <man*>;
        my $section_dir;
        # @section_dirs has man1, man2, man3s etc.
        foreach $section_dir (@section_dirs) {
            chdir $section_dir || next;
            ($section = $section_dir) =~ s/^man//;
            push (@{$sections{$section}}, <*.$section*>);
            chdir "..";
        }
        chdir "..";
    }
    # All sections in all man pages have been slurped in. Remove duplicates
    foreach $section (keys %sections) {
        my @new_list;
        my %seen;
        @new_list = sort (grep (!$seen{$_}++, @{$sections{$section}}));
        # Change all entries like cc.1 to cc(1)
        foreach (@new_list) {
            $_ =~ s/[.](.*)/($section)/;
        }
        $sections{$section} = \@new_list;
    }
    ## save section lists to ~/.iC/iCman.sec
    if ($home ne '') {
	if (open(INI, ">$home/.iC/$named.sec")) {
	    print INI "[DATE $newDate]\n";	# date stamp in section file
	    foreach $section (sort keys %sections) {
		my @new_list = @{$sections{$section}};
		print INI "[$section]\n\t@new_list\n";
	    }
	    close(INI);
	} else {
	    warn "ERROR: Can't open ~/.iC/$named.sec: $!\n";
	}
    }
    print STDERR "Starting UI ...\n";
} # scout_man_dirs

########################################################################
#
#	Pop up man menu from previous or next button after 200 ms
#
########################################################################

sub ManMenu {
    my ($dummy, $buttonRef) = @_;
    my $buttonState = $$buttonRef->cget(-state);
    my $buttonText  = $$buttonRef->cget(-text);
    if ($buttonState ne 'disabled') {
	my $xWin = $mainWindow->rootx;
	my $yWin = $mainWindow->rooty;
	print "button '$buttonText' xWin = '$xWin' yWin = '$yWin'\n" if $opt_T;
	$manTimer = $mainWindow->after(200,
	    sub { $manMenu->post($xWin + ($buttonText eq '<=' ? 172 : 220), $yWin +  32); });
    }
    print "Pop up man button '$buttonText' '$buttonState'\n" if $opt_T;
} # ManMenu

########################################################################
#
#	Cancel man menu from previous or next button before 200 ms are up
#
########################################################################

sub ManCancel {
    $manMenu->unpost();
    $manTimer->cancel();
    print "Cancel man menu\n" if $opt_T;
} # ManCancel

########################################################################
#
#	Pop up search menu from search button after 200 ms
#
########################################################################

sub SearchMenu {
    my ($dummy, $buttonRef) = @_;
    my $buttonState = $$buttonRef->cget(-state);
    my $buttonText  = $$buttonRef->cget(-text);
    if ($buttonState ne 'disabled') {
	my $xWin = $mainWindow->rootx;
	my $yWin = $mainWindow->rooty;
	print "button '$buttonText' xWin = '$xWin' yWin = '$yWin'\n" if $opt_T;
	$searchTimer = $mainWindow->after(200,
	    sub { $searchMenu->post($xWin + 412, $yWin +  32); });
    }
    print "Pop up search button '$buttonText' '$buttonState'\n" if $opt_T;
} # SearchMenu

########################################################################
#
#	Cancel search menu from search button before 200 ms are up
#
########################################################################

sub SearchCancel {
    $searchMenu->unpost();
    $searchTimer->cancel() if defined $searchTimer;
    print "Cancel search\n" if $opt_T;
} # SearchCancel

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from
#		eg: bind('<KeyPress-Return>', [ \&search_text, undef, 0 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy first parameter when called directly.
#	Use this is buttonFlag.
#
#		parameter 1:	buttonFlag - false (0) when [/] release else true
#		parameter 2:	newSearchText
#		    "		undef	use $searchText from Entry widget
#		    "		''	clear the search
#		parameter 3:	0  Search down	(default)
#		    "		1  Search up	(save searchText when clearing)
#		    "		2  Go to line
#
#	search_text() is mostly called from a pop up, which does not close,
#	until search_text() has completed execution. If the search action
#	involves scrolling, the text covered by the pop up before scrolling
#	and not covered after scrolling is left blank.
#
#	To fix this, postpone the search and scrolling action until after
#	search_text() has completed execution, by posting the callback
#	search_now(). No actual delay is necessary.
#
########################################################################

sub search_text {
    my ($buttonFlag, $newSearchText, $direction) = @_;
no warnings;
    print "search_text: \$buttonFlag = '$buttonFlag' \$searchText = '$searchText'\n" if $opt_T;
use warnings;
    unless ($buttonFlag) {
	SearchCancel();				# do this first - no delays yet
	if ($searchText eq '' or not defined $searchText) {
	    $entrySearch->focus();		# initiate search entry (simulates vi)
	    return;
	}
    }
    $text->after(0, [ \&search_now, @_ ]);	# allow pop up to go away
} # search_text

sub search_now {
    my ($buttonFlag, $newSearchText, $direction) = @_;
    my ($saveText, $saveMatch, $option, $auxiliary, $current, $hl, $length);
    my $tmpText;
    if (defined $newSearchText) {
	if ($newSearchText eq '' and $direction) {	# save search text when clearing
	    ($saveText, $saveMatch) = ($searchText, $matchType);
	}
	($searchText, $option) = split(/\t/, $newSearchText);
	$matchType = $option ? $matchRestores{$option} : '-exact';
    }
    $searchText = '' if not defined $searchText;
    $text->tagDelete('gotoTag');
    while ($direction == 2 or $matchType eq 'g') {	# really if() {.. last; ..}
	########################################################################
	##	Go to line $searchText (do exact match search if not numeric)
	########################################################################
	if ($searchText eq '') {
	    $searchText = $current = "1.0";
	} elsif ($searchText =~ s/^(\d+\.(\d+|end)|end).*$/$1/) {
	    $current = "$1";
	} elsif ($searchText =~ s/^(\d+).*$/$1/) {
	    $current = "$1.0";
	} else {
	    $matchType = '-exact';	# try exact match - most likely
	    last;
	}
	print "goto: '$searchText' '$current' '$matchType' $direction\n" if $opt_T;
	$matchType = 'g';
	$text->see($current);
	## grey out the whole line - until mouse moves - visible in Edit and Live mode
	$text->tagConfigure('gotoTag',
			    -background => 'grey',
			    -foreground => 'black',
			   );
	$text->tagAdd('gotoTag', "$current linestart", "$current lineend");
	$text->markSet('insert', $current);
	$text->tagLower('gotoTag');	# put any search results in foreground
	report_cursor();
	$tmpText = "$searchText$matchExtensions{$matchType}";
	check_menu($tmpText, 'searches');
	$prevText = $searchText;
	$prevMatch = $matchType;
	return;
    }
    if ($prevText ne $searchText or $prevMatch ne $matchType) {
	########################################################################
	#	Start of a new search
	########################################################################
	print "pattern: '$searchText' '$matchType'\n" if $opt_T;
	@hits = ();
	@groups = ();
	$gl = 0;
	$text->tagDelete('searchTag') if $prevText;
	$text->tagConfigure('searchTag',
			    -background => 'black',	# same as 'less'
			    -foreground => 'white',
			   );
	if ($matchType eq 'ri') {
	    $matchType = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';	# fill as placeholder
	}
	$current = '1.0';
	$length = '0';

	########################################################################
	#	Actual searches storing results in @hits
	#	for every hit set a tag
	########################################################################
	while (1) {
	    eval {
		$current = $text->search(-count => \$length,
					 $matchType,
					 $auxiliary,
					 '--',
					 $searchText,
					 $current,	# start index
					 'end',		# stop index
					);
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		info_display('red', "ERROR: $@");	# error in search
		last;
	    }
	    last unless $current and $length;
	    if ($opt_T) {
		my @lineinfo = $text->dlineinfo($current);
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length '@lineinfo'\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    $current =~ /(\d+)\.(\d+)/;
	    push @hits, [ $current, $1, $2, $length, ];
	    $current = $text->index("$current + $length char");	# point bejond hit
	}
	$matchType = 'ri' if $auxiliary eq '-nocase';	# otherwise radio button skips
	if (($hl = scalar @hits) > 0) {
	    $tmpText = "$searchText$matchExtensions{$matchType}";
	    check_menu($tmpText, 'searches');
	    ########################################################################
	    #	Analyse hits and group them into display groups.
	    #   Pseudo_code for new algorithm (August 2009).
	    #
	    #	The previous 2 algorithms were much longer.
	    #	They actually missed showing some hits under some circumstances.
	    ########################################################################
	    # re-compute window details in case text and/or window has changed
	    $text->yview('moveto', 0);		# window to top left of text so bbox works
	    my ($x, $y, $w, $lineHeight) = $text->bbox("1.0");
	    print "bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
	    my $h = $text->height;		# current height of display window in pixels
	    my $height = int($h/$lineHeight);	# current height of display window in lines
	    my $endm = $text->index('end');
	    $endm =~ m/(\d+)\.(\d+)/;
	    $lineCnt = $1 - 1;			# current length of text in lines
	    my $groupFirst = undef;
	    my $prevGroupHeight = 0;
	    my ($groupHeight, $groupTop, $aRef);
	    while (($aRef = shift @hits)) {
		($current, $y, $x, $length) = @$aRef;
		if (defined $groupFirst) {
		    if (($groupHeight = $y - $groupFirst) >= $height) {
			$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
			$groupTop = 0 if $groupTop < 0;
			push @groups, $groupTop / $lineCnt;
			$groupFirst = $y;	# start of new group
			$prevGroupHeight = 0;
		    } else {
			$prevGroupHeight = $groupHeight;
		    }
		} else {
		    $groupFirst = $y;		# first item in search
		}
	    }
	    if (defined $groupFirst) {
		$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
		$groupTop = 0 if $groupTop < 0;
		push @groups, $groupTop / $lineCnt;
	    }

	    $gi = -1;				# see index
	    $gl = scalar @groups;
	    my $plural = $gl > 1 ? 's' : '';
	    info_display('dark green', "/$searchText/ found $hl times in $gl group$plural");
	}
	$prevText = $searchText;
	$prevMatch = $matchType;
	$entrySearch->focus();
    }
    ########################################################################
    #	Use @groups to scroll over the groups forwards or backwards.
    #	Initial group index is $gi = -1. Used to determine scroll start for
    #	immediate backward scroll.
    #	Even for a single group, re-position group every time RETURN is pressed,
    #	because the hits could have been moved by manual scrolling.
    ########################################################################
    if ($gl > 0) {
	my $infoFlag = ($gi < 0 or $gl < 2) ? 0 : 1;	# allows search statistics info to stay
	if (not $direction) {
	    $gi++;			# forward scroll
	    if ($gi >= $gl) {
		$gi = 0;
		if ($infoFlag) {
		    info_display('dark red', "search hit BOTTOM, continuing at TOP");
		    $infoFlag = 0;
		}
	    }
	} else {
	    $gi--;			# backward scroll
	    if ($gi < 0) {
		if ($infoFlag and $gi == -1) {	# -2 is first time backwards
		    info_display('dark red', "search hit TOP, continuing at BOTTOM");
		    $infoFlag = 0;
		}
		$gi = $gl - 1;
	    }
	}
	if ($infoFlag) {
	    info_display('black', '');	# clears display_info
	}
	$text->yview('moveto', $groups[$gi]);	# move forward or backward to next group
	print("moveto line @{[$lineCnt*$groups[$gi]+1]}\n") if $opt_T;
    } elsif ($gl == 0 and not $@) {	# do not overwrite search eval error message
	if ($searchText ne '') {
	    info_display('red', "/$searchText/ not found");	# report every time
	} else {
	    info_display('dark red', "search cleared");
	    $yScrollbar->focus();
	}
    }
    if ($saveText) {
	($searchText, $matchType) = ($saveText, $saveMatch);
    }
} # search_now

########################################################################
#
#	Start a new search with / or ALT-/ to simulate vi
#
########################################################################

sub new_search {
    print "new_search\n" if $opt_T;
    $searchText = '';		# clears search entry window
    search_text(0, '', 0);	# puts focus in search entry window
} # new_search

########################################################################
#
#	Scroll text left or right with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_x_text {
    my ($dummy, $increment) = @_;
    print "scroll_x increment = '$increment'\n" if $opt_T;
    $text->xview('scroll', $increment, 'units');
} # scroll_x_text

########################################################################
#
#	Scroll text up or down with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_text {
    my ($dummy, $increment) = @_;
    print "scroll increment = '$increment'\n" if $opt_T;
    $text->yview('scroll', $increment, 'units');
} # scroll_text

########################################################################
#
#	Position text Home or End
#
########################################################################

sub position_text {
    my ($dummy, $position) = @_;
    print "scroll position = '$position'\n" if $opt_T;
    $text->see($position);
} # position_text

########################################################################
#
#	Increase or decrease font size
#
#	change normal text font (includes underline text)
#	change 'section' headings which are bold
#	change 'bd' tagged words which are bold
#	do not change miscellanous button text fonts
#
########################################################################

sub change_font {
    my ($dummy, $increment) = @_;
    $fontSize += $increment;			# initial or new fontSize
    if ($fontSize < 8 || $fontSize > 22) {
	$fontSize -= $increment;		# keep fontSize within limits
    } else {
	print "font increment = '$increment' size = '$fontSize'\n" if $opt_T;
	$font       = $font_t;
	$boldfont   = $boldfont_t;
	$font       =~ s/fontSize/$fontSize/;	# no change if -F was a specified font
	$boldfont   =~ s/fontSize/$fontSize/;
	if ($increment) {
	    $text->configure(-font => $font);	# re-configure only for changed fonts
	    $text->tagConfigure('section', -font => $boldfont, -foreground => $colorBD);
	    $text->tagConfigure('bd',  -font => $boldfont);
	    info_display('black', "font size $fontSize");
	}
    }
} # change_font

########################################################################
#
#	Help man page
#
########################################################################

sub show_help {
    $entryMan->delete('0', 'end');
    $entryMan->insert('end', "$named(1)");
    show_man();
} # show_help

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    sleep 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    sleep 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Fork initial window to background
#
########################################################################

sub to_background {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid = fork;
    if ($pid < 0) {
	warn "Unable to run in the background, cannot fork: $!\n";
	exit $?;
    }
    exit 0 if $pid;	# exit foreground which started the program
} # to_background

########################################################################
#
#	check_menu (newEntry, menuKey[, delete])
#	Enter a new value into a particular menu
#	    iniMenuData{menuKey} ==> [
#		menuRef,	# [0]
#		entriesArray,	# [1]
#		menuPos,	# [2]
#		entriesLim,	# [3]
#		commandRef,	# [4]
#	    ])
#	'newEntry' is appended to (or moved to the bottom of) the 'menuKey' menu
#	when 'delete' is set, 'newEntry' in the menu is deleted and not replaced
#
#	Maintain local arrays @dynamicHistory and @dynamicSearches to map a regular
#	expression index pattern to a positional number, which can be used to
#	index menu entries with a numerical index. Entries in these local arrays
#	are always pushed on the end for new entries, shifted from the front to
#	delete the oldest entry, or spliced out to delete a previous entry from
#	the middle. A linear search in these arrays must be used to locate old
#	entries. A hash is not suitable, because several entries change their
#	numerical index every time an old entry is spliced out of the middle or
#	shifted from the front.  But since the number of entries (entriesLim) is
#	limited, this is not a serious drawback. These arrays, which are accessed
#	from 'iniMenuData' via 'entriesArray' parallels the arrays used internally
#	by the Tk menu system can be used to count and locate the numerical index
#	of dynamic menu entries.
#
########################################################################

sub check_menu {
    my ($newEntry, $menuKey, $delete) = @_;
    my $menuData = $iniMenuData{$menuKey};
    my ($menuRef, $entriesArray, $menuPos, $entriesLim, $commandRef) = @$menuData;

    my $e;
    my $n = 0;
    foreach $e (@$entriesArray) {
	if ($e eq $newEntry) {			# find newEntry in entriesArray
	    $e = splice(@$entriesArray, $n, 1);	# remove from middle of entriesArray
	    die "entry '$e' in entriesArray does not match call parameter '$newEntry', stopped" if $e ne $newEntry;
	    my $label = $menuRef->entrycget($menuPos+$n, '-label');	# check algorithm
	    die "entry '$e' in entriesArray does not match menu entry '$label', stopped" if $e ne $label;
	    print "check_menu: [$menuKey] '$e' removed from position $n of menu\n" if $opt_T;
	    $menuRef->delete($menuPos+$n) if $menuRef;	# delete old entry from menu
	    last;				# avoids indexing with a pattern, which fails
	}
	$n++;
    }
    push(@$entriesArray, $newEntry) unless $delete;	# add to end of entriesArray

    if ($opt_T) {
	if ($menuKey and $delete) {
	    print "check_menu: [$menuKey] '$newEntry' deleted\n";
	} else {
	    print "check_menu: [$menuKey] '$newEntry' added\n";
	}
    }
    if ($menuRef and not $delete) {		# menu for 'file' and 'searches' not 'last open file'
	$menuRef->command(-label   => "$newEntry",	# must use local $newEntry below
			  -command => [ $commandRef, 1, $newEntry, 0 ]); # define 0 (down for search)
	if (scalar @$entriesArray > $entriesLim) {
	    $e = shift(@$entriesArray);		# remove first entry in entriesArray
	    my $label = $menuRef->entrycget($menuPos, '-label');	# check algorithm
	    die "entry '$e' in entriesArray does not match menu entry '$label', stopped" if $e ne $label;
	    print "check_menu: [$menuKey] '$e' removed from front of menu\n" if $opt_T;
	    $menuRef->delete($menuPos);	# remove first dynamic menu entry
	}
    }
} # check_menu

########################################################################
#
#	Initialise the program by reading ~/.iC/iCman.ini if it exists
#	and initialising history list and search list in menus
#	only if there are no man arguments
#
#	structure of ~/.iC/iCman.ini
#	[history]
#		iCserver
#		immcc
#		-k immediate
#	[last open file]
#		iCserver		# last open file
#		27.4			# line #
#	[searches]
#		pip			# default match type is -exact
#		[files]			# a curious -exact match
#		timer		i	# match type -nocase (<tab>i)
#		QX[\d+]\.[\d+]	r	# match type -regexp (<tab>r)
#		ix[\d+]\.[\d+]	ri	# is resolved to -regexp -nocase
#
#	since tabs cannot be entered in the search entry box (skips to Text window)
#	use <tab> followed by search option in the search menu list
#	also precede each ini item by <tab>, since [files] may be a
#	legitimate search expression (watch Goedel here)
#
########################################################################

sub ini_program {
    my ($menuData, $menuKey, $entry, $initialFile, $position, $home);
    ## restore file and search menu lists from ~/.iC/iCman.ini
    if (($home = $ENV{HOME}) ne '' and
	(-d "$home/.iC" or mkdir "$home/.iC") and
	open(INI, "$home/.iC/$named.ini")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$menuKey = $1;			# key found
		$menuData = $iniMenuData{$menuKey};
		print "ini_program: menuKey [$menuKey] found\n" if $opt_T;
	    } elsif ($menuData and s/^\t(.*)$/$1/) {	# ini starts with <tab>
		$entry = $_;
		check_menu($entry, $menuKey);	# insert dynamic entries from ini file
	    }
	}
	close(INI);
    }	# ignore if ~/.iC/iCman.ini cannot be opened or found
} # ini_program

########################################################################
#
#	Quit program after checking if file needs saving
#	and current history and search menu lists have been written
#
########################################################################

sub quit_program {
    my ($menuKey, $entriesArray, $entry, $home);
    ## save file and search menu lists to ~/.iC/iCman.ini
    if (($home = $ENV{HOME}) ne '' and
	(-d "$home/.iC" or mkdir "$home/.iC") and
	open(INI, ">$home/.iC/$named.ini")) {
	foreach $menuKey (sort keys %iniMenuData) {
	    print INI "[$menuKey]\n";
	    print "INI: [$menuKey]\n" if $opt_T;
	    $entriesArray = @{$iniMenuData{$menuKey}}[1];	# entriesArray
	    foreach $entry (@$entriesArray) {
		if (defined $entry and $entry ne '') {
		    print INI "\t$entry\n";
		    print "INI:	$entry\n" if $opt_T;
		}
	    };
	}
	close(INI);
    } else {
	warn "ERROR: Can't open ~/.iC/$named.ini: $!\n";
    }
    print "$named: quit\n" if $opt_T;
    $mainWindow->destroy();
    exit(0);
} # quit_program
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCman - an interface to the on-line reference manuals

=head1 SYNOPSIS

 iCman[ -cnrTh][ -k <key>][ -f <page>][ -F <font>][ -l <num>][ -w <num>]
      [ -g <geometry>][ [<section>] <manpage> ...] ...
    -k key  display the output of man -k <key> (apropos) which provides
            man page links to the topic described by <key>.
    -f page display the output of man -f <page> (whatis)
    -F font font or font size to use in Text window (default '14')
    -l num  height of the Text window (default 35)
    -w num  width  of the Text window (default 80)
    -g geom geometry for main window
    -c      build a new cache of section names (default: use cache)
    -n      no fork of initial window (used in internal fork call)
            (default is to fork the initial window)
    -r      restore last session with manpage and search history
    -T      trace output static debug messages
    -h      help, ouput this Usage text only

    Manpage arguments may be of the form <section> <manpage>, which is
    the classical call for 'man'. <manpage>(<section>) may be used as
    an alternative, but this form must be quoted for the shell.  In
    either case <section> must be a valid section name.

    One or more manpage arguments may be used - these are placed in
    the history. If no manpage arguments are specified or if the -r
    option is used, the last session is restored with all its manpage
    and search history. The first manpage in the history is opened.
    This is either the first manpage argument or the first manpage
    in the previous session history.

 Menu buttons:                   Action                      Accelerator

    [man] Show  a new manpage - in this window                   RETURN
                (followed by an optional section in parentheses)
                Alternatively show a list of topics matching a key
                with '-k <key>' or 'apropos <key>' entered in the
                show window.
                Double-clicking on a word in the text which is the
                name of another man page will also open that page.
       Open     a new window - to show selected manpage         Alt-RET
       Quit     quit the program.                                   q

    [ <= ]      Load the previous manpage in the history.           p
    [ => ]      Load the next manpage in the history.               n
            Holding either of these buttons down briefly will
            open a menu of history items which can be selected.

    [Headings]  Skip to one of the headings in the manpage.
    [Sections]  Load the index for one of the manpage sections.

    [ / ]       Put focus in Search Entry window if cleared.        /
                    (simulates vi)                            or  Alt-/
                Else start or continue a search of text in
                the Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options and a history of previous searches.
       Search down       or                                      RETURN
                displays a new group of hits.
       Search up         or                                   Shift-RET
                reverses the direction of scrolling.
       Clear             or                                    Ctrl-RET
                clears hits and the search Entry window.
     <>Go to line        or                                     Alt-RET
                goes to the line entered in the Entry window.
     <>Exact match
     <>Ignore case
     <>Regexp match
     <>Rgexp+ignore case

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Help]      Display this man page.                              h

=head1 DESCRIPTION

B<iCman> provides a read-only window in which man pages can be
displayed. Each page argument given to B<man> is normally the name of
a program, utility or function. The manual page associated with
each of these arguments is then found and displayed. A section,
if provided, will direct B<iCman> to look only in that section of the
manual. The default action is to search in all of the available
sections, following a pre-defined order and to show only the
first page found, even if pages exist in several sections.

Other manual pages may be opened either by entering the name of a
manual page optionally followed by a section in parentheses in the
Man-Entry window and pressing RETURN, or by double clicking on a
word representing a manual page - usually under the SEE ALSO heading
or in a Section Index. Using ALT-RETURN or ALT-Double click will
open the new manual page in a new instance of iCman.

Alternatively '-k <key>' or 'B<apropos> <key>' may be used in
the Man-Entry window to search the manual page names and
descriptions. This provides man page links to the topic described
by <key>.  The default 'regex' behaviour of B<apropos> (man -k) is
used. No wildcard or exact option is provided. The text provided
by 'man -k' is piped through 'sort -u' to delete duplicate entries.
A sorted list with no duplicate entries is easier to analyze.

Also '-f <page>' or 'B<whatis> <page>' in the Man-Entry window will
display the short description of that manual page.

The displayed text is read-only. It's position may be manipulated
by the scroll bar(s) or the usual up/down/prior/next/home/end keys.
A useful feature is the use of the middle mouse button to fast scroll
in all 4 directions through the text. Other shortcuts are the 'p'
and 'n' key to load the previous or next entry in the history. 'h'
displays the iCman manual page and 'q' quits the program.

The search facility is much more powerful than that of 'less', the
usual man page viewer. Searches may be for an exact match or for a full
Perl-type regular expression. The \bword\b feature to find only whole
words is particularly useful. Searches are normally case sensitive,
but a case-insensitive search may be selectd. Once a search has been
carried out, all the hits are highlighted. A first group of hits is
displayed in the Text window. The text is moved to display as many
hits as possible. When the user has analysed the first group of hits,
hitting RETURN will display the next group of hits in the text and
so on until the end of the text is reached. Another RETURN will start
by displaying the first group at the top again. Hitting SHIFT-RETURN
will reverse the direction of scrolling through the groups.

When iCman is started the first time, the names of all manual
pages of every section in all directories of MANPATH are obtained.
Since this may take some time, particularly if the system is busy,
the result of the scan is cached in ~/.iC/iCman.sec.  A full scan is
carried out each new day. This should be sufficient to catch any
new man entries. Alternetively 'iCman -c' may be used to build a new
cache after new software has been installed.

=head1 AUTHOR

Copyright 2003-2012, John E. Wulff (immediateC@gmail.com)

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

Acknowledgments to Sriram Srinivasan (see below)

=head1 BUGS

B<iCman> cannot display Unicode characters used in SuSE Linux 9.3.
This is a problem with Tk::Text version Tk-800.024. Some tests done
with Tk804.027 showed its Tk::Text to be much slower in updating
tags - which is a cornerstone of the iC-range of programs.
B<man> produces some Unicode characters for a few man pages. In the
Unicode environment of SuSE Linux 9.3, these are not translated with
or without the man -7 option. (the -7 option is therefore not used).
The most important characters - in particular the special hyphen used
in B<man> for word syllabification and '|' are substituted by code.

Tk::Text version Tk-804.028 distributed with openSUSE Linux 11.1
handles the above characters correctly. Therefore the above translations
have been made conditional for Tk-800.024 (match 800). Proper UTF-8
translation with decode('utf-8', <line>) has also been introduced.
The only problem remaining is a bug in B<pod2man>, which replaces
all non ASCII-7 characters with rubbish.

This has now been fixed for UTF-8 sources if an early line in the pod
source is C<=encoding utf8> and B<pod2man> is called with the -u or
--utf8 option.  B<iCman> will then show UTF-8 characters correctly
but only if each text line is passed through  decode('utf-8', <line>),
which has been done.

Example: German Umlaut characters Ä Ö Ü ä ö ü ß, which should be
A O U a o u with Diaresis plus a sharp s.

Email bug reports to B<immediateC@gmail.com> with L<iC man page reader>
in the subject field.

=head1 SEE ALSO

man(1), apropos(1), iClive(1)

=head1 ACKNOWLEDGEMENTS

This program is a major extension of B<perlman>, the man page viewer
from the O'Reilly Book "Advanced Perl Programming" by Sriram Srinivasan.
The work of Sriram Srinivasan is gratefully acknowledged.  Some ideas
were also used from the version of B<perlman> extended by H.Merijn Brand.
