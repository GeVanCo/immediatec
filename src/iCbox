#!/usr/bin/perl -P

########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	iC generic Demo Box
#	adapted from
#	Example 14-1 Simple UI Code
#	Sriram Srinivasan: Advanced Perl p. 224
#
#	For measuring reaction times the Module Time::HiRes may be used.
#	This activates the -m option.
#	Make sure you have downloaded and installed Time::HiRes from CPAN
#	Uncomment the C++ comment in the next line
#//define TIME_HIRES
#
########################################################################

use Tk;					# Slurp the module in
use Msg;
use strict;

my @inputs;
my @outputs;

my @masks =	(1, 2, 4, 8, 16, 32, 64, 128);
my @invert =	(1, 0);		# invert logic sense
my @bitIndex =	(
    0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,	# 0x01 0x02 0x04 0x08
    4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	# 0x10
    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x40
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
@<<<<<< [-etmh] [-s <host>] [-p <port>] [-RrIiOo <num>] [-l <len>] [<ID> [<ini>]]
	$named
	ID	X0 X1 .. X31, B0 B1 .. B31, W0 W2 .. W30 (default is X0)
	ini	initial input value eg: 15, 017, 0xf, 0b1111 (default 0)
	-s host	host name of server    (default 'localhost')
	-p port	service port of server (default '8778')
	-t	trace debug messages
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-e	optional exit button
	-h	help, ouput this Usage text only
	The following options apply to analog units with ID Bx or Wy only
	-R num	from for input and output (default 0)
	-I num	from for input only
	-O num	from for output only
	-r num	to for input and output (default 100)
	-i num	to for input only
	-o num	to for output only
	-l len	length of scales (default 170)
Copyright (C) 2000-2001  John E. Wulff		<john@je-wulff.de>
							  '@'
$Id: iCbox,v 1.33 2001/04/04 10:30:37 jw Exp $
.

use vars qw($opt_e $opt_t $opt_m $opt_s $opt_p $opt_r $opt_i $opt_o $opt_R $opt_I $opt_O $opt_l $opt_h);
require "getopts.pl";
&Getopts('tmes:p:r:i:o:R:I:O:l:h');	# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
#ifdef TIME_HIRES 

my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
    $t0 = [gettimeofday];	# start of program
}
#endif

########################################################################
#
#	Connect to server
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $unitID = (@ARGV >= 1) ? $ARGV[0] : 'X0';
my $inByte = (@ARGV >= 2) ? $ARGV[1] : 0;
my $outByte =	0;		# initialize to a number for correct XOR

if ($unitID =~ /^[XBW]/) {
    $inByte = oct($inByte) if $inByte =~ /^0/;	# handles 017 0xf 0b1111
    $inByte = int($inByte);	# initialize to a number for correct AND/OR
    $inByte &= 0xff if $unitID =~ /^[XB]/;
}
else {
    die "iCbox $unitID could not be made\n";
}

my $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
die "Client could not connect to $host:$port\n" unless $conn;

print "Connection $unitID at client.\n";
$conn->send_now($unitID);	# register I/O

########################################################################
#
#	Create main window and optional Exit button
#
########################################################################

my $mainWindow = MainWindow->new();
$mainWindow->title("iC");
$mainWindow->Label(-text => "iC Demo Box")->pack;

$mainWindow->Button(-text    => "Exit",
		    -command => sub { exit; },
		   )->pack(-side   => 'bottom', 
			   -expand => 1,
			   -fill   => 'x',
			  ) if $opt_e;

########################################################################
#
#	Generate an input and an output frame
#
########################################################################

my $inLabel = "input";
my $outLabel = "output";
if ($unitID !~ /^X/) {
    $inLabel = "in I$unitID";
    $outLabel = "out Q$unitID";
}

my $inFrame  = $mainWindow->Frame(-label       => $inLabel,
				  -relief      => 'groove',
				  -borderwidth => 2,
				 )->pack(-side   => 'left', 
				         -expand => 'y',
				         -fill   => 'y',
				        );

my $outFrame = $mainWindow->Frame(-label       => $outLabel,
				  -relief      => 'groove',
				  -borderwidth => 2,
				 )->pack(-side   => 'right', 
				         -expand => 'y',
				         -fill   => 'y',
				        );

########################################################################
#
#	Generate 8 input checkbuttons and 8 output checkbuttons
#
########################################################################

if ($unitID =~ /^X/) {
    for my $index (0 .. 7) {
	my $input = "I$unitID.$index";
	my $makeCheckbutton = "\
	    if (\$inByte & $masks[$index]) {\
		\$inputs[$index] = 1;\
	    }\
	    \$inFrame->Checkbutton(\
		-text        => \$input,\
		-variable    => \\\$inputs[\$index],\
		-selectcolor => 'green',\
		-command     => sub {\
				     if (\$inputs[$index]) {\
					 \$inByte |= $masks[$index];	# set bit\n\
				     } else {\
					 \$inByte &= ~$masks[$index];	# clear bit\n\
				     }\
				     "
#ifdef TIME_HIRES 
				   ."\&printMicroSeconds if \$opt_m;"
#endif
				   ."print \"I$unitID.$index --> \$inputs[$index] (\$inByte)\\n\" if \$opt_t;\
				     \$conn->send_now(\"$unitID.\$inByte\");\
				    },\
	    )->pack(-side   => 'top',\
		    -expand => 1,\
	    );\
	";
	eval $makeCheckbutton;
	print $@;
    }
    if ($inByte) {
	print "init I$unitID 0 --> $inByte\n" if $opt_t;
	$conn->send_now("$unitID.$inByte");
    }

    for my $index (0 .. 7) {
	my $output = "Q$unitID.$index";
	my $makeCheckbutton = "\
	    \$outFrame->Checkbutton(\
		-text        => \$output,\
		-variable    => \\\$outputs[\$index],\
		-selectcolor => 'red',\
		-takefocus   => 0,\
		-command     => sub {\
				     print \"Inverting output $index on Q$unitID\\n\" if \$opt_t;\
				     \$outputs[$index] = \$invert[\$outputs[$index]];\
				    },\
	    )->pack(-side   => 'top',\
		    -expand => 1,\
	    );\
	";
	eval $makeCheckbutton;
	print $@;
	$outputs[$index] = 0;
    }
}

########################################################################
#
#	Generate 1 input analog scale and 1 output analog scale
#
########################################################################

elsif ($unitID =~ /^[BW]/) {

    $opt_R = 0 unless $opt_R;		# default from 0
    $opt_r = 100 unless $opt_r;		# default to 100
    $opt_I = $opt_R unless $opt_I;	# from for input
    $opt_O = $opt_R unless $opt_O;	# from for output
    $opt_i = $opt_r unless $opt_i;	# to for input
    $opt_o = $opt_r unless $opt_o;	# to for output
    $opt_l = 170 unless $opt_l;		# default length 170

    $inFrame->Scale(
	-from        => $opt_I,
	-to          => $opt_i,
	-length      => $opt_l,
	-variable    => \$inByte,
	-command     => sub {
			     if (length $inByte) {
#ifdef TIME_HIRES 
				 &printMicroSeconds if $opt_m;
#endif
				 print "I$unitID --> $inByte\n" if $opt_t;
				 $conn->send_now("$unitID.$inByte");
			     }
			    },
    )->pack(-side   => 'top',
	    -expand => 1,
    );

    $outFrame->Scale(
	-from        => $opt_O,
	-to          => $opt_o,
	-length      => $opt_l,
	-variable    => \$outputs[0],
	-state       => 'disabled',
	-takefocus   => 0,
    )->pack(-side   => 'top',
	    -expand => 1,
    );

    $outputs[0] = 0;
}

########################################################################
#
#	Register read events
#
########################################################################

$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });

########################################################################
#
#	Sit in an infinite loop dispatching incoming events.
#
########################################################################

MainLoop;

########################################################################
#
#	Receive message from server - adjust outputs
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, $err) = @_;
#ifdef TIME_HIRES 
    &printMicroSeconds if $opt_m;
#endif
    if (defined $msg) {
        my $len = length $msg;
	if ($len == 0) {
	    $conn->disconnect();
	    print "iCbox $unitID disconnected by server\n";
	    exit;
	}
	my ($uID, $value, $rest) = split /\./, $msg, 3;
	if ($uID ne $unitID or defined $rest) {
	    warn "WARNING: $msg from ICS ?? ignored";
	} elsif ($uID =~ /^X/) {
	    if ($value eq "R") {
		print "$uID rcvd R - reset from ICS\n" if $opt_t;
		for my $index (0 .. 7) {
		    if ($outputs[$index]) {
			print "init Q$uID.$index 0 <-- 1\n" if $opt_t;
			$outputs[$index] = 0;
		    }
		}
		$outByte = 0;
		if ($inByte) {
		    print "send I$uID 0 --> $inByte\n" if $opt_t;
		    $conn->send_now("$uID.$inByte");
		}
	    } elsif ($value =~ /^\d+$/ and $value < 256) {
		my ($diff, $mask, $index, $val);
		$diff = $outByte ^ $value;	# $outByte initialized to a number for correct XOR
		while ($diff) {			# age old algorithm from CSR days
		    $mask = $diff & -$diff;	# rightmost set bit from diff
		    $index = $bitIndex[$mask];
		    $val = ($value & $mask) ? 1 : 0;
		    print "Q$uID.$index $val <-- $outputs[$index] ($value)\n" if $opt_t;
		    $outputs[$index] = $val;	# modify viewable output
		    $diff &= ~$mask;		# clear rightmost bit in diff
		}
		$outByte = $value;		# ready for next message
	    } else {
		warn "Q$uID received spurious message: '$msg'\n";
	    }
	} elsif ($uID =~ /^[BW]/) {
	    if ($value eq "R") {
		print "$uID rcvd R - reset from ICS\n" if $opt_t;
		if ($outputs[0]) {
		    print "init Q$uID 0 <-- $outputs[0]\n" if $opt_t;
		    $outputs[0] = 0;
		}
		if (length $inByte and $inByte) {
		    print "send I$uID 0 --> $inByte\n" if $opt_t;
		    $conn->send_now("$uID.$inByte");
		}
	    } elsif ($value =~ /^-?\d+$/) {
		print "Q$uID $value <-- $outputs[0]\n" if $opt_t;
		$outputs[0] = $value;
	    } else {
		warn "Q$uID received spurious message: '$msg'";
	    }
	}
    }
}
#ifdef TIME_HIRES 

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    my ($sec, $usec);
    $t1 = [gettimeofday];
    $sec =  $t1->[0] - $t0->[0];
    $usec = $t1->[1] - $t0->[1];
    if ($usec < 0) {
	$sec--;
	$usec += 1000000;
    }
    if ($opt_t) {
	printf "%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
    } else {
	printf "%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
    }
    $t0 = $t1;
}
#endif
