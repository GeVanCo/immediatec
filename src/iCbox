#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2012  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCbox; generic Demo Box
#	adapted from
#	Example 14-1 Simple UI Code
#	Sriram Srinivasan: Advanced Perl Programming p. 224
#
#	For measuring reaction times the Module Time::HiRes may be used.
#	This activates the -m option.
#	Make sure you have installed Time::HiRes (provided in this distribution)
#
########################################################################

use Tk;			# The graphical user interface toolkit perl/Tk
			##                   by Nick Ing-Simmons
use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use strict;
use warnings;

my @ArgNames;		# stores IO names and initialisers in argument list order
my @ChannelNames;	# stores IO names with instance for each registered channel
my @ChannelsRI;		# allow retrieval of @ArgNames info via $channel
my @ChannelsQ;		# stores received value for all Q[XBWL]n outputs
my @ChannelsQX;		# stores computed bit value for all QXn.<0..7> outputs
my @ChannelsI;		# stores computed or selected value for all I[XBWL]n inputs
my @ChannelsIX;		# stores selected bit values for all IXn.<0..7> inputs
my @ChannelsIq;		# stores values before queing for all I[XBWL]n inputs
my %IONames;		# stores channel for each IO name (aux use in initial pass)
my $UnitRegistrations;	# stores the registration string
my %HoldQueue = ();	# Hold Queue
my $holdButton;		# Hold button
my $hold;		# state of Hold button
my $setButton;		# Set all inputs button
my $set;		# state of Set button
my @allButtons = ();	# used to note all buttons to set
my $indicatoron = 1;	# 0 button    1 checkbox
my $greenButton = "'green'";
my $redButton   = "'red'";

my @masks =	(1, 2, 4, 8, 16, 32, 64, 128);
my @bitIndex =	(
    0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,	# 0x01 0x02 0x04 0x08
    4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	# 0x10
    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x40
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
    @<<<< [-bdrHmtRSTxh][ -s <host>][ -p <port>][ -n <name>][ -i <inst>]
	$named
	  [ -c <col>][ -C <col>][ -Q <rows>][ -l <len>][ -f <file>]
	  [ <ID>[-<ID>[=<ini>]] ...]
	ID	X0 X1 X2 ... B0 B1 B2 ... W0 W1 W2 ..., L0 L1 L2 ...
		Any ID can be preceded by 'I' or 'Q' in which case
		only that input or output is generated (default is both)
		default ID is X0 generating input IX0 and output QX0
		A range of ID's can be specified with -; eg IX0-IX7
	ID-inst	Each ID can be followed by -<inst>, where <inst> consists
		of up to 3 numeric digits (usually 1 digit).
		Such an appended instance code takes precedence over the
		general instance specified with the -i <inst> (see below).
	ID=ini	initial input value eg: 15, 017, 0xf, 0b1111 (default 0)
		applies only to input ID's. One =ini applies to each input
		in a range of ID's; eg X5-X7=3 inits IX5 IX6 and IX7 to 3.
	X0,0b11 select buttons X0.0 and X0.1 only with a bit mask
		default X0 (= X0,0b11111111) selects X0.0 .. X0.7
	X0,,200 digital I/O push-buttons X0.0 .. x0.7 reset after 200 ms
		default on/off buttons, which must be reset by another click
	X0,,200,0b11  only X0.0 and X0.1 are push-buttons - rest are on/off
	B1,0,50 number range of an analog scale is 0 to 50; default ,0,100,1
	B1,0,500,10  number range 0 to 500 with a resolution of 10
	-s host	host name of server    (default 'localhost')
	-p port	service port of server (default '8778')
	-n name	registration name (default first full ID)
	-i inst instance ID for this @<<<<<< (1 to 3 numeric digits)
				    $named
	-c col 	maximum number of columns in a row (default 12)
	-C col 	absolute maximum number of columns in a row (default 18)
	-Q rows	absolute maximum number of rows (default 3)
	-l len	length of scales (default 170)
	-f file read additional ID parameters from this file
	-b	use buttons instead of checkboxes for digital I/O
	-d	display external inputs IMn only (no ini values allowed)
	-r	reverse - display inputs IMn, send outputs Qmn like inputs
	-H      a Hold button is generated which holds input changes
	-m	display elapsed time in seconds and microseconds
	-t	trace debug messages
	-R      trace rcv messages in Msg.pm
	-S      trace send messages in Msg.pm
	-T	extra static debug messages
	-x	exit after analyzing input parameters
	-h	help, ouput this Usage text only
Copyright (C) 2000-2012  John E. Wulff		<immediateC@gmail.com>
							  '@'
$Id: iCbox,v 1.53 2013/04/28 19:55:08 jw Exp $ uses Tk-@<<<<<<<<<
							$Tk::VERSION
.

use vars qw($opt_b $opt_d $opt_r $opt_H $opt_m $opt_x $opt_t $opt_R $opt_S $opt_T $opt_s $opt_p);
use vars qw($opt_n $opt_i $opt_c $opt_C $opt_Q $opt_l $opt_f $opt_h);
use Getopt::Std;		# replace require "getopts.pl";
getopts('bdrHmxtRSTs:p:n:i:c:C:Q:l:f:h');	# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    use Time::HiRes qw(gettimeofday);
    $t0 = [gettimeofday];	# start of program
}

$opt_c = 12	unless $opt_c;	# default maximum number of columns
$opt_C = 18	unless $opt_C;	# absolute maximum number of columns
$opt_c = $opt_C	if $opt_c > $opt_C;
$opt_Q = 3	unless $opt_Q;	# absolute maximum number of rows
$opt_l = 170	unless $opt_l;	# default length of analog scale
print "c = $opt_c C = $opt_C Q = $opt_Q l = $opt_l\n" if $opt_t;

if ($opt_b) {
    $indicatoron = 0;		# 0 button    1 checkbox
    $greenButton = "'light green'";
    $redButton   = "'IndianRed1'";
}

my $QX        = $opt_d ? qr/^[IQ]X/        : $opt_r ? qr/^IX/        : qr/^QX/;
my $Q_BWL_    = $opt_d ? qr/^[IQ][BWL]/    : $opt_r ? qr/^I[BWL]/    : qr/^Q[BWL]/;
my $Q__XBWL__ = $opt_d ? qr/^[IQ]([XBWL])/ : $opt_r ? qr/^I([XBWL])/ : qr/^Q([XBWL])/;

my $IX        = $opt_r ? qr/^QX/        : qr/^IX/;
my $I_BWL_    = $opt_r ? qr/^Q[BWL]/    : qr/^I[BWL]/;
my $I__XBWL__ = $opt_r ? qr/^Q([XBWL])/ : qr/^I([XBWL])/;

my $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = "-$opt_i";
	print "instance = '$instance'\n" if $opt_t;
    } else {
	warn "$named: badly formed option -i $opt_i - ignored\n";
    }
}

########################################################################
#
#	Analyse ID parameters
#
#	X0 X2	generates inputs and outputs IX0 QX0 IX2 QX2 in that order
#	B0-B2	generates inputs and outputs IB0 QB0 IB1 QB1 IB2 QB2
#	IW3 IW7	generates only inputs IW3 and IW7
#	QL4-QL7 generates only outputs QL4 QL5 QL6 and QL7
#
#	Combined input/output or input-only parameters can be initialised
#	with =<number>.
#	<number> may be decimal, octal, hexadecimal or binary as follows:
#	X10=15 X11=017 IX12=0xf IX13=0b1111	all equal decimal 15
#	only decimal initialisers may be preceded by a minus sign
#	IW10=-100	initialises IW10 with -100
#
#	An initialiser may be placed after the second parameter of a range.
#	Every input in the range will be initalised to the same value.
#	IW20-IW27=100	initialises IW20 IW21 .. IW27 with 100
#	X20-X27=0x3a	initialises IX20 IX21 .. IX27 with 0x3a
#	Outputs cannot be initialised.
#
#	All digital parameters or parameter ranges may optionally be followed
#	by one number separated by a comma representing a bitmask defining,
#	whether a particular bit .0 to .7 is defined and should be implemented.
#	Default ',255' which defines all 8 bits. The easiest way to declare
#	the bit mask is as a binary number, eg: ',0b10001111'. This declares
#	that bits .0, .1, .2, .3 and .7 are defined in the application and
#	should be implemented. The bits which are not defined are left blank.
#
#	All analog parameters or parameter ranges may optionally be followed
#	by two or three comma-separated numbers naming the start, finish
#	and optionally the resolution of the numbers displayed by the analog
#	scale. Default ',0,100' which is equivalent to ',0,100,1'.  A negative
#	resoltion reverses the direction of the slider. (0 not allowed)
#
#	ID-parameter, range, initialiser and number-range must be written
#	without spaces in the command line unless they are quoted. In the
#	optional INI file which can be read with the -f option, white space
#	can be placed between parameter, range, initialiser and number-range.
#	They must only be all in one line. Any text following '#' is ignored
#	and treated as a comment.
#
########################################################################

my $nr = qr/-?[1-9]\d*|0(x[\da-fA-F]+|b[01]+|[0-7]*)/;	# precompiled regex for number in all representations
							# NOTE: oct() only handles lower case 0b, 0x
my ($id, $ini, $from, $to, $res, $argNameRef);

if ($opt_f) {
    open IN, $opt_f or die "can't open ID file $opt_f! $!";
    LINE:
    while (<IN>) {		# read next entry from ID file into $_
	chomp;			# $_ is an ID line
	print "$opt_f:$.: '$_'\n" if $opt_t;
	my ($lead, $pos, $tail);
	$pos = 0;
	while (/(			# $1 lead
		    .*?			# NOTE minimal matching
		)
		(			# $2 whole ID
		    [IQ]?[XBWL]\d+	# IEC-1131 ID
		    (			# optional
			-\d{1,3}	# 3 digit instance
		    )?
		    (			# optional
			\s*-\s*		# '-' 2nd ID
			[IQ]?[XBWL]\d+	# IEC-1131 ID
			(		# optional
			    -\d{1,3}	# 3 digit instance
			)?
		    )?
		    (			# optional initialiser
			\s*=\s*		# '='
			( $nr )?	# optional number
		    )?
		    (			# optional  from, to, resolution
			(
			    \s*,\s*	# ','
			    ( $nr )?	# optional number
			){0,3}		# 0 to 3 values ,<number>
		    )
		)/xog) {
	    $lead = $1;
	    $id = $2;
	    $pos = pos;
	    print "$opt_f:$.: pos = '$pos' lead = '$lead' id = '$id'\n" if $opt_t;
	    if ($lead =~ /^\s*(#.*)?$/) {
		next LINE if $1;
	    } else {
		warn "$named: file $opt_f:$.: '$_' contains badly formed ID '$lead'\n";
	    }
	    push(@ARGV, $id);	# put next ID on end of @ARGV
	}
	$tail = substr $_, $pos;
	print "$opt_f:$.: pos = '$pos' tail = '$tail'\n" if $opt_t;
	unless ($tail =~ /^\s*(#.*)?$/) {
	    warn "$named: file $opt_f:$.: '$_' contains badly formed ID '$tail'\n";
	}
    }
    close IN;
}
unshift(@ARGV, 'X0') unless @ARGV;	# default name X0
print "ARGV:", join(':', @ARGV), ":\n" if $opt_t;

my ($argv);
while ($argv = shift @ARGV) {
    my ($start_iq_xbwl, $start_iq, $start_xbwl, $start_n, $si, $end_n, $ei, $fr_to_re, @list);
    if ($argv =~ /^
		    (				# $1   start IEC-1131 ID
			(			# $2   start_iq_xbwl
			    ( [IQ]? )		# $3   start_iq
			    ( [XBWL] )		# $4   start_xbwl
			)
			( \d+ )			# $5   start_n IEC addr <<<<<<<
			(			# $6   optional
			    -\d{1,3}		#      3 digit instance
			)?
		    )
		    (				# $7   optional
			\s*-\s*			#      '-' 2nd ID
			(			# $8   end IEC-1131 ID
			    ( [IQ]?[XBWL] )	# $9   end_iq_xbwl
			    ( \d+ )		# $10  end_n IEC addr
			    (			# $11  optional
				-\d{1,3}	#      3 digit instance
			    )?
			)
		    )?
		    (				# $12  optional initialiser
			\s*=\s*			#      '='
			( $nr )?		# $13  internal $14 in $nr = qr...
		    )?
		    (				# $15  optional  from, to, resolution
			(			# $16
			    \s*,\s*		# ','
			    ( $nr )?		# $17  internal $18 in $nr = qr...
			){0,3}			# 0 to 3 values ,<number>
		    )
		$/xog) {
	my ($n);
	$ini = 0;				# default initial value
	$start_iq_xbwl = $2;
	$start_iq = $3;
	$start_xbwl = $4;
	$start_n = $end_n = $5;			# start_n addr (end_n in case no range)
	$si = defined $6 ? $6 : '';		# start instance
	if ($8) {				# end IEC-1131 ID
	    $end_n = $10;			# end_n addr
	    $ei = defined $11 ? $11 : $si;	# end instance (same as start instance if not defined)
	    if (not $9 or			# end_iq_xbwl
		$start_iq_xbwl ne $9 or		# start_iq_xbwl must equal end_iq_xbwl
		not defined $end_n or		# $10 can never be '' with ( \d+ )
		$start_n > $end_n or
		$si ne $ei)			# start instance must equal end instance
	    {
		goto ARG_WARN;			# iq_xbwl not identical or negative range
	    }
	}
	if ($13) {		# initialiser
	    if ($start_iq and $start_iq eq 'Q') {
		warn "$named: $argv: output argument cannot be initialised - ignore initialiser\n";
	    } else {
		$ini = convert_nr($13, 0);	# 7 or 07 or 0x7 or 0b111 Input initialiser
	    }
	}
	unless ($si) {
	    $si = $instance;
	}
	$fr_to_re = defined $15 ? $15 : '';
	if ($fr_to_re) {			# [, from[, to[, resolution]]]
	    my $dummy;
	    print "fr_to_re = '$fr_to_re'\n" if $opt_t;
	    ($dummy, $from, $to, $res) = split /\s*,\s*/, $fr_to_re;
	    ########################################################################
	    ## $from, $to and $res are optional, so initialise them if undefined
	    ## all we know that if they are defined, they consist of a valid number
	    ## For digital I/O:
	    ## $ini contains the value of initial bits set (must be ANDED with $from)
	    ## $from contains the bit mask defining which bits are to be used
	    ##   if $from eq '' it is set to 255 - all 8 buttons present
	    ##   if $from == 0 it becomes a dummy frame with no buttons
	    ## $to is the pushbutton delay in ms (default '' or 0 is normal on/off button)
	    ## $res contains the bit mask defining which bits are push buttons if $to != 0
	    ########################################################################
	    if ($start_xbwl eq 'X') {
		$from = convert_nr($from, 0xff);	# digital I/O default bit mask for all 8 bits
		$ini &= $from;				# $ini should not have more bits than defined bits
		if ($start_iq and $start_iq eq 'Q' and defined $to) {
		    warn "$named: $argv: digital output argument cannot cannot have a time delay - used 0\n";
		    $to = 0;
		} else {
		    $to = convert_nr($to, 0);		# default 0 is normal Input on/off button
		}
		if ($to and $to < 50) {
		    warn "$named: $argv: push button time delay '$to' must be >= 50 - used 50 ms\n";
		    $to = 50;				# minimum push button time delay is 50 ms (not -ve)
		}
		$res = convert_nr($res, $to ? 0xff : 0);# push-button I/O default bit mask for all 8 bits if $to
		$res &= $from;				# $res should not have more bits than defined bits
	    } else {
		$from = convert_nr($from, 0);		# analog I/O default from = 0
		$to = convert_nr($to, 100);		# analog I/O default to   = 100
		$res = convert_nr($res, 1);		# analog I/O default res  = 1
		unless ($res) {
		    warn "$named: $argv: resolution '$res' must be non-zero - used 1\n";
		    $res = 1;
		} elsif ($res < 0) {
		    my $tmp = $from;			# reverse direction of scale
		    $from = $to;
		    $to   = $tmp;
		    $res = -$res;
		}
	    }
	} elsif ($start_xbwl eq 'X') {
	    ($from, $to, $res) = (0xff, 0, 0);		# digital I/O default bit mask for all 8 bits
	    $ini &= 0xff;				# should never have more than 8 bits initialised
	} else {
	    ($from, $to, $res) = (0, 100, 1);		# analog I/O default
	}
	foreach $n ($start_n .. $end_n) {
	    if ($start_iq) {
		@list = ("$start_iq_xbwl$n$si");	# generate individual I/Os
	    } else {
		@list = ("I$start_iq_xbwl$n$si", "Q$start_iq_xbwl$n$si");	# both I/Os
	    }
	    foreach $id (@list) {
		if ($IONames{$id}) {
		    print "\n" if $opt_t;
		    warn "$named: $id occurs twice - ignore second instance\n";
		} else {
		    $IONames{$id} = -1;			# mark as unregistered IO
		    print " $id=$ini" if $opt_t;
		    push @ArgNames, [ $id, $ini, $from, $to, $res ];	# argument order for generating widgets
		}
	    }
	}
	print "\n" if $opt_t;
    } else {
	ARG_WARN: warn "$named: $argv: badly formed ID argument - ignored\n";
    }
}
@ArgNames or die "$named: no valid arguments - cannot make any boxes\n";

if ($opt_t) {
    print "LIST:	ID	ini	from	to	resolution\n";
    foreach $argNameRef (@ArgNames) {
	my $argLine = join "\t", @$argNameRef;
	print "\t$argLine\n";
    }
}

%IONames = ();		# clear for channel entries

########################################################################
#
#	Connect to server and register I/Os
#
#	Inhibit Nagle's algorithm
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $name = $opt_n ? "$opt_n$instance" : $ArgNames[0][0];	# : $ArgNames [first entry] [$id]
$named = $name;			# use individual ID for warnings from now on

Msg->inhibit_nagle(1, $opt_R, $opt_S);	# inhibit Nagle's algorithm for real time response
my $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
die "Client '$named' could not connect to $host:$port\n" unless $conn;

############# send registration ############################

my ($label, $direction);
my $register = 1;		# tested in rcvd_msg_from_server() for registration reply
my $ri = 0;			# registration index used in rcvd_msg_from_server()
my $frameCount = 0;		# number of frames in the box
$UnitRegistrations = "N$name";	# initiate registration string

foreach $argNameRef (@ArgNames) {
    ($id, $ini, $from, $to, $res) = @$argNameRef;
    $direction = $label = '';
    if ($id =~ /^I/) {
	$direction = $opt_d || $opt_r ? 'R' : 'S';
    } elsif ($id =~ /^Q/) {
	$direction = $opt_r ? 'S' : 'R';
    } else {
	die "$named: invalid argument '$id' - internal error";
    }
    if ((length($UnitRegistrations) + length($id)) > 1396) {	# REPLY 1400 - (1+2+1) in tcpc.h
	print "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
	$conn->send_now($UnitRegistrations);
	my ($tmsg, $terr) = $conn->rcv_now();
	print "$named: Reply: $tmsg\n" if $opt_t;
	rcvd_msg_from_server($conn, $tmsg, $terr);	# receive registration acknowledgment
	$UnitRegistrations = '';
    }
    $UnitRegistrations .= ",$direction$id";	# direction 1 ',Z' 2 term 1
    print "register: $direction$id	inByte = $ini\n" if $opt_t;
}
$UnitRegistrations .= ",Z";	# terminate registration string
print "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
$conn->send_now($UnitRegistrations);
my ($tmsg, $terr) = $conn->rcv_now();
print "$named: Reply: $tmsg\n" if $opt_t;
rcvd_msg_from_server($conn, $tmsg, $terr);	# receive final registration acknowledgment

############# registration analysis ########################
$ri == scalar @ArgNames or
    die "$named: $ri: not enough registration replies from iCserver - system error";
$frameCount != 0 or
    die "$named: no valid registrations - cannot make any frames\n";
$register = 0;
############# correct number of registration replies #######

my ($frame, $ch, $maxColumn, $mw, $pane);
my ($row, $column, $scroll) = (0, 0, 0);

$frameCount++ if $opt_H;			# extra Hold frame
if ($frameCount > $opt_C*$opt_Q) {
    $maxColumn = $opt_C;
    $scroll = 1;
} else {
    for (my $r = $opt_Q; $r > 0; $r--) {
	my $r1 = $r - 1;
	if ($frameCount > $opt_c*$r1) {
	    $maxColumn = int(($frameCount + $r1) / $r);
	    last;
	}
    }
}
print "frameCount = $frameCount maxColumn = $maxColumn scroll = $scroll\n" if $opt_t;
exit if $opt_x;	# deliberate exit with -x option

########################################################################
#
#	Create main window
#	if too big use a scrollable pane (frame) using Tk::Pane
#
########################################################################

$mw = MainWindow->new(-title => "$name");
if ($scroll) {
    use Tk::Pane;
    $pane = $mw->Scrolled('Pane',
			  -scrollbars => 'oe',
			  -height     => $opt_Q * 218,	# 3 rows = 654
			 )->pack(
			         -fill   => 'both',
			         -expand => 1,
			 );
} else {
    $pane = $mw;	# no need to scroll - keep window at minimum size
}

########################################################################
#
#	Optional Hold button
#
########################################################################

if ($opt_H) {
    $frame  = $pane->Frame(-label       => 'Hold',
			   -relief      => 'groove',
			   -borderwidth => 2,
			  )->grid(-row    => $row,
				  -column => $column,
				  -sticky => 'nsew',
				 );
    $column++;
    if ($column >= $maxColumn) {	# in case $maxColumn == 1
	$column = 0;
	$row++;
    }
    $holdButton = $frame->Checkbutton(
	-text        => 'II',
	-width       => '2',
	-variable    => \$hold,
	-selectcolor => 'green',
	-indicatoron => $indicatoron,
	-command     => sub {
	    if ($hold) {
		print "Hold start            [II]\n" if $opt_t;
		$holdButton->configure(-text => '>');
	    } else {
		print "Hold release          [>]\n" if $opt_t;
		## scan list of changes on Hold Queue
		my ($ch, $val);
		foreach $ch (sort { $a <=> $b } keys %HoldQueue) {
		    $val = $HoldQueue{$ch};	# retrieve latest value
		    if ($val != $ChannelsIq[$ch]) {
			send_input($ch, $val);	# send hold value
			($id, $ini, $from, $to, $res) = @{$ArgNames[$ChannelsRI[$ch]]};	# all argument values
			if ($to and				# process held delayed push-buttons
			    $id =~ /$I__XBWL__/o and		# /^I([XBWL])/ or /^Q([XBWL])/ if $opt_r
			    $1 eq 'X') {			# only IXm.n
			    my $resolution = $res & $val;	# only push-buttons which had been pushed need clearing
			    if ($resolution) {
				my $channel = $ch;
				$mw->after($to, sub {
				    for my $i (0 .. 7) {
					$ChannelsIX[$channel][$i] = 0 if $resolution & (1 << $i);# clear delayed input bits
				    }
				    $ChannelsI[$channel] &= ~$resolution;
				    send_input($channel, $ChannelsI[$channel]);		# send cleared bits after delay
				});		# end of after()
			    }
			}			# latest value sent is in $ChannelsIq[$ch] now
		    }
		}
		%HoldQueue = ();		# delete all entries
		$holdButton->configure(-text => 'II');
		print "Hold release complete\n" if $opt_t;
	    }
	},
    )->pack(-side   => 'top', -expand => 1,);
    $setButton = $frame->Checkbutton(
	-text        => 'all',
	-width       => '2',
	-variable    => \$set,
	-selectcolor => 'green',
	-indicatoron => $indicatoron,
	-command     => sub {
	    my ($val, $ref);
	    if ($set) {
		 print "                all [set]\n" if $opt_t;
		 $val = 1;
	    } else {
		 print "                all [res]\n" if $opt_t;
		 $val = 0;
	    }
	    foreach (@allButtons) {
### 		print "$val@{[$_->cget(-text)]}";
		$ref = $_->cget(-variable);
		if ($$ref != $val) {
		    $$ref = $val;
		    $_->Callback(-command);
### 		} else {
### 		    print " == $$ref\n";
		}
	    }
	},
    )->pack(-side   => 'top', -expand => 1,);
}

########################################################################
#
#	For each argument generate a frame with
#
########################################################################

foreach $argNameRef (@ArgNames) {
    ($id, $ini, $from, $to, $res) = @$argNameRef;
    $direction = $label = '';
    if ($id =~ /^I/) {
	$direction = $opt_d || $opt_r ? 'R' : 'S';
    } elsif ($id =~ /^Q/) {
	$direction = $opt_r ? 'S' : 'R';
    } else {
	goto WARN_REG_ID;
    }
    if ($direction) {
	$ch = $IONames{"$direction$id"};
	$label = "$id";
	if (not defined $ch) {
	    print "$named: [$row:$column] label = '$label' ch not defined\n" if $opt_t;
	    next;			# multiple input not registered
	}
    }
    print "$named: [$row:$column] label = '$label' ch = '$ch' ini = '$ini' from = '$from' to = '$to' res = '$res'\n" if $opt_t;

    $frame  = $pane->Frame(-label       => $label,
			   -relief      => 'groove',
			   -borderwidth => 2,
			  )->grid(-row    => $row,
				  -column => $column,
				  -sticky => 'nsew',
				 );
    $column++;
    if ($column >= $maxColumn) {
	$column = 0;
	$row++;
    }

########################################################################
#
#	either 8 output checkbuttons
#	eval makes each of the 8 output CheckButtons in turn
#
#	Bug in Tk-804.027 (possibly only on MAC OsX-1.3-darwin)
#	selectcolor for disabled has no effect
#	disabledforeground is displayed instead - same as .0 .1 ...
#	'dark red' is a good compromise - identifies outputs nicely
#
########################################################################

    my ($index, $text, $sel, $del, $state, $borderwidth);
    if ($id =~ /$QX/o) {		# /^QX/ or /^[IQ]X/ if $opt_d or /^IX/ if $opt_r
	for $index (0 .. 7) {
	    $sel = $from & (1 << $index);
	    $text = $sel ? "'.$index'" : "''";
	    $borderwidth = $sel ? 2 : 0;
	    my $makeOutCheckbutton = "\
	    \$frame->Checkbutton(\
		-text               => $text,\
		-variable           => \\\$ChannelsQX[$ch][$index],\
		-selectcolor        => $redButton,\
		-borderwidth        => $borderwidth,\
		-takefocus          => 0,\
		-state              => 'disabled',\
		-disabledforeground => 'dark red',\
		-indicatoron        => $indicatoron,\
	    )->pack(-side => 'top', -expand => 1,);\
";									# end of eval
	    print $makeOutCheckbutton if $opt_T;
	    eval $makeOutCheckbutton;
	    print $@;
	    ## ChannelsQ[$ch] initialised to 0 on registration
	}
    }

########################################################################
#
#	or 8 input checkbuttons
#	eval makes each of the 8 input CheckButtons in turn
#	generates -command code only if button is selected in $from (mask)
#	handles push button with delay $del if $del != 0 (generates more code)
#	must be processed by eval to make -command a closure
#
########################################################################

    elsif ($id =~ /$IX/o) {		# /^IX/ or /^QX/ if $opt_r
	for $index (0 .. 7) {
	    $sel = $from & (1 << $index);
	    $del = ($res & (1 << $index)) ? $to : 0;			# select bits which are push-buttons
	    $text        = $sel ? "'.$index'" : "''";
	    $borderwidth = $sel ? 2 : 0;
	    $state       = $sel ? "'normal'" : "'disabled'";
	    my $makeInCheckbutton = ($del ? "\
	    my \$myself;" : "") . "\
	    my \$thisButton = \$frame->Checkbutton(\
		-text        => $text,\
		-variable    => \\\$ChannelsIX[$ch][$index],\
		-selectcolor => $greenButton,\
		-borderwidth => $borderwidth,\
		-state       => $state,\
		-indicatoron => $indicatoron," . ($sel ? "\
		-command     => " . ($del ? "\\(\$myself = " : "") . "sub {\
		    my \$val = \$ChannelsI[$ch];" . ($del ? "\
		    if (\$val & $masks[$index]) {\
			\$ChannelsIX[$ch][$index] = 0;	# reset bit indicator\
			\$val &= ~$masks[$index];	# clear bit after time delay\
		    } els" : "\
		    ") . "if (\$ChannelsIX[$ch][$index]) {\
			\$val |= $masks[$index];	# set bit" . ($del ? "\
			\$mw->after($del, \$myself) unless \$hold;	# clear bit after $del ms" : "") . "\
		    } else {\
			\$val &= ~$masks[$index];	# clear bit\
		    }\
		    if (\$val != \$ChannelsI[$ch]) {\
			\$ChannelsI[$ch] = \$val;\
			send_input($ch, \$val);\
		    }\
		}" . ($del ? ")" : "") . "," : "") . "\
	    )->pack(-side   => 'top', -expand => 1,);" . (($sel and $opt_H) ? "\
	    push \@allButtons, \$thisButton;	# prepare for all set/reset" : "") . "\
";									# end of eval
	    print $makeInCheckbutton if $opt_T;
	    eval $makeInCheckbutton;
	    print $@;
	}
	send_input($ch, $ChannelsI[$ch]);				# send initial values at build time (set in registration)
	if ($to) {							# process initial delayed push-buttons
	    my $resolution = $res & $ini;				# no need to clear uninitialised bits
	    if ($resolution) {
		my $channel = $ch;
		$mw->after($to, sub {
		    for my $i (0 .. 7) {
			$ChannelsIX[$channel][$i] = 0 if $resolution & (1 << $i);	# clear delayed input bits
		    }
		    $ChannelsI[$channel] &= ~$resolution;
		    send_input($channel, $ChannelsI[$channel]);		# send cleared bits after delay
		});							# end of after()
	    }
	}								# latest value sent is in $ChannelsIq[$ch] now
    }

########################################################################
#
#	or 1 analog output scale
#
########################################################################

    elsif ($id =~ /$Q_BWL_/o) {		# /^Q[BWL]/ or /^[IQ][BWL]/ if $opt_d
	$frame->Scale(			# /^I[BWL]/ if $opt_r
	    -from        => $from,
	    -to          => $to,
	    -resolution  => $res,
	    -length      => $opt_l,
	    -troughcolor => 'IndianRed1',
	    -width       => '4m',
	    -variable    => \$ChannelsQ[$ch],
	    -state       => 'disabled',
	    -takefocus   => 0,
	)->pack(-side => 'top', -expand => 1,);
    }

########################################################################
#
#	or 1 analog input scale
#	must be processed by eval to make -command a closure
#
########################################################################

    elsif ($id =~ /$I_BWL_/o) {		# /^I[BWL]/ or /^Q[BWL]/ if $opt_r
	my $makeInScaleCheckbutton = "\
	\$frame->Scale(\
	    -from        => $from,\
	    -to          => $to,\
	    -resolution  => $res,\
	    -length      => $opt_l,\
	    -troughcolor => 'light green',\
	    -width       => '4m',\
	    -variable    => \\\$ChannelsI[$ch],\
	    -command     => sub {\
		send_input($ch, \$ChannelsI[$ch]);\
	    },\
	)->pack(-side => 'top', -expand => 1,);\
";									# end of eval
	print $makeInScaleCheckbutton if $opt_T;
	eval $makeInScaleCheckbutton;
	print $@;
    }

    else {
	WARN_REG_ID: warn "$named: badly formed ID '$id' - ignored\n";
	next;		# should die - internal error
    }
}

########################################################################
#
#	Register read events
#
########################################################################

$mw->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });

########################################################################
#
#	Sit in an infinite loop dispatching incoming events.
#
########################################################################

MainLoop();
exit(0);

####### End of main program ############################################

########################################################################
#
#	Convert a number string obtained with $nr to an integer value
#	Parameter 1:	dec, bin, oct or hex number string - dec may be signed
#	Parameter 2:	initial value
#	retun initial value if parameter 1 undef or ''
#
########################################################################

sub convert_nr {
    my ($val, $initial) = @_;
    return $initial if not defined $val or $val eq '';
    if ($val =~ /^-\s*0/) {
	$val = 0;
	print "\n" if $opt_t;
	warn "$named: $argv: bin, oct or hex numbers may not be signed - ignore initialiser\n";
    } else {
	$val = oct($val) if $val =~ /^0/;	# handles 017 0xf 0b1111
    }
    $val = int($val);				# initialize to a number for correct AND/OR
    return $val;
} # convert_nr

########################################################################
#
#	Send input value, unless hold - in which case input is queued
#
########################################################################

sub send_input {
    my ($ch, $val) = @_;
    printMicroSeconds();
    if ($hold) {
	print "$named: $ch:$val	II $ChannelNames[$ch]\n" if $opt_t;
	$HoldQueue{$ch} = $val;			# hold latest value - not sent now
    } elsif ($val != $ChannelsIq[$ch]) {
	$ChannelsIq[$ch] = $val;		# always save latest value sent on this channel for hold
	print "$named: $ch:$val	> $ChannelNames[$ch]\n" if $opt_t;
### 	printf "%s	%2d:%08b\n", $ChannelNames[$ch], $ch, $val;
	printf "%s	%2d:%d	>\n", $ChannelNames[$ch], $ch, $val if $opt_S;
	$conn->send_now("$ch:$val");		# send latest value
    }
} # send_input

########################################################################
#
#	Receive message from server - adjust outputs - ack registrations
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, $err) = @_;
    printMicroSeconds();
    if (defined $msg) {
        my $len = length $msg;
	print "($len)$msg<\n" if $opt_T;
	if ($len == 0) {
	    $conn->disconnect();
	    print "$named: disconnected by server\n";
	    exit;
	}
	my ($msg1, $channel, $value, $old, $bitRef, $id, $ini, $from, $to, $res, $regId);
	foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
	    if ($msg1 =~ /^(\d+):(-?\d+)$/) {
		$channel = $1;			## receive data as channel:value
		$value   = $2;			## decimal value with optional sign
		$old = $ChannelsQ[$channel];
		if (defined $old) {
		    if ($value != $old) {
			$bitRef = $ChannelsQX[$channel];
			if (defined $bitRef) {		# only defined for QXm digital
			    my ($diff, $mask);
			    goto WrongFormat if $value >= 0x100;	# only 8 bit map allowed
			    $diff = $old ^ $value;	# $old initialized to a number for correct XOR
			    while ($diff) {		# age old algorithm from CSR days
				$mask = $diff & -$diff;	# rightmost set bit from diff
				${$bitRef}[$bitIndex[$mask]] = ($value & $mask) ? 1 : 0;
				$diff &= ~$mask;	# modify viewable output - clear rightmost bit
			    }
			}
			$ChannelsQ[$channel] = $value;	# ready for next message
			print "$named: $msg1	< $ChannelNames[$channel]\n" if $opt_t;
			printf "%s	%2d:%d	<\n", $ChannelNames[$channel], $channel, $value if $opt_R;
		    }
		} else {
		    warn "$named: not registered for $msg1 from iCserver - not OK\n";
		}
	    } elsif ($register and $msg1 =~ /^(-?\d+)$/) {
		$channel = $1;			## receive channel of a registration acknowlwdgment
		($id, $ini, $from, $to, $res) = @{$ArgNames[$ri]};	# all argument values
		defined $id or
		    die "$named: too many registration acknowledgments from iCserver - system error";
		print "$named: $ri: registering '$id' on channel '$channel'\n" if $opt_t;
		$ChannelsRI[$channel] = $ri;	# allow retrieval of @ArgNames info via $channel
		$ri++;
		my $dir = '';
		if ($id =~ /$Q__XBWL__/o) {	# /^Q([XBWL])/ or /^[IQ]([XBWL])/ if $opt_d
		    if ($channel == 0) {	# /^I([XBWL])/ if $opt_r
			warn "$named: trying to register receiver '$id' at channel 0 - error\n";
			next;
		    }
		    $dir = 'R';
		    $frameCount++;
		    if ($channel < 0) {
			$channel = -$channel;
			print "$named: registering receiver '$id' on channel $channel twice - equivalence\n" if $opt_t;
		    } else {
			$ChannelsQ[$channel] = 0;	# initial value and Q definition
			## when this array element is defined, it is a Q[XBWL] receiver (or I[XBWL] if $opt_d or $opt_r)
			if ($1 eq 'X') {
			    @{$ChannelsQX[$channel]}[0..7] = (0,0,0,0,0,0,0,0);
			    ## when this array slice is defined, channel is a QXn.m
			    ## Q[BWL]n have this slice undefined for their channel
			}
		    }
		}
		elsif ($id =~ /$I__XBWL__/o) {	# /^I([XBWL])/ or /^Q([XBWL])/ if $opt_r
		    if ($channel == 0) {
			warn "$named: trying to register sender '$id' twice - not allowed\n";
			next;
		    }
		    $dir = 'S';
		    $frameCount++;
		    ## initial value and I definition
		    $ChannelsIq[$channel] = $ChannelsI[$channel] = $ini;
		    ## when this array element is defined, it is a I[XBWL] sender (or Q[XBWL] if $opt_r)
		    if ($1 eq 'X') {
			for my $index (0 .. 7) {
			    $ChannelsIX[$channel][$index] = ($ini & $masks[$index]) ? 1 : 0;
			}
			## when this array slice is defined, channel is a IXn.m
			## I[BWL]n have this slice undefined for their channel
		    }
		}
		if ($dir) {
		    $regId = "$dir$id";
		    $ChannelNames[$channel] = "$id";
		    $IONames{$regId} = $channel;
		    ## build only boxes whose IONames entry is defined
		    print "register: $regId channel = $channel ini = '$ini' from = '$from' to = '$to' res = '$res'\n" if $opt_t;
		}
	    } else {
	      WrongFormat:
		warn "$named: WARNING: '$msg1' out of '$msg' from iCserver has wrong format - ignored";
	    }
	}
    }
} # rcvd_msg_from_server

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    if ($opt_m) {
	my ($sec, $usec);
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "B%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "B%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
	$t0 = $t1;
    } elsif ($opt_t) {
	print "B: ";
    }
} # printMicroSeconds
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCbox - a TK-widget to provide virtual digital and analog I/O

=head1 SYNOPSIS

 iCbox [-bdrHmtRSTxh][ -s <host>][ -p <port>][ -n <name>][ -i <inst>]
       [ -c <col>][ -C <col>][ -Q <rows>][ -l <len>][ -f <file>]
       [ <ID>[-<ID>[=<ini>]] ...]
    ID      X0 X1 X2 ... B0 B1 B2 ... W0 W1 W2 ..., L0 L1 L2 ...
            Any ID can be preceded by 'I' or 'Q' in which case
            only that input or output is generated (default is both)
            default ID is X0 generating input IX0 and output QX0
            A range of ID's can be specified with -; eg IX0-IX7
    ID-inst Each ID can be followed by -<inst>, where <inst> consists
            of up to 3 numeric digits (usually 1 digit).
            Such an appended instance code takes precedence over the
            general instance specified with the -i <inst> (see below).
    ID=ini  initial input value eg: 15, 017, 0xf, 0b1111 (default 0)
            applies only to input ID's. One =ini applies to each input
            in a range of ID's; eg X5-X7=3 inits IX5 IX6 and IX7 to 3.
    X0,0b11 select buttons X0.0 and X0.1 only with a bit mask
            default X0 (= X0,0b11111111) selects X0.0 .. X0.7
    X0,,200 digital I/O push-buttons X0.0 .. x0.7 reset after 200 ms
            default on/off buttons, which must be reset by another click
    X0,,200,0b11  only X0.0 and X0.1 are push-buttons - rest are on/off
    B1,0,50 number range of an analog scale is 0 to 50; default ,0,100,1
    B1,0,500,10  number range 0 to 500 with a resolution of 10
    -s host host name of server    (default 'localhost')
    -p port service port of server (default '8778')
    -n name registration name (default first full ID)
    -i inst instance ID for this iCbox (1 to 3 numeric digits)
    -c col  maximum number of columns in a row (default 12)
    -C col  absolute maximum number of columns in a row (default 18)
    -Q rows absolute maximum number of rows (default 3)
    -l len  length of scales (default 170)
    -f file read additional ID parameters from this file
    -b      use buttons instead of checkboxes for digital I/O
    -d      display external inputs IMn only (no ini values allowed)
    -r      reverse - display inputs IMn, send outputs Qmn like inputs
    -H      a Hold button is generated which holds input changes
    -m      display elapsed time in seconds and microseconds
    -t      trace debug messages
    -R      trace rcv messages in Msg.pm
    -S      trace send messages in Msg.pm
    -T      extra static debug messages
    -x      exit after analyzing input parameters
    -h      help, ouput this Usage text only

=head1 DESCRIPTION

The B<iCbox> widget contains one or more frames - each frame containing one
digital or anolag input or output widget.

Digital I/O widgets consist of a row of 8 vertical checkbuttons
labelled .0 to .7 - representing the 8 bits of one digital I/O byte
IXn or QXn. The address IXn or QXn labels the frame. Input checkbuttons
are green whereas output checkbuttons are red when on. Only input
checkbuttons are active when the mouse is over a button and can be
toggled on or off with mouse button-1.

Analog I/O widgets consist of a slider or scale widget allowing the
display or selection of a range of numbers. Default is a range from 0
to 100. This range can be changed on creation of the widget (,start,finish
option). Analog I/O widgets may be generated to deal with single
byte values, 2 byte or word values and 4 byte or long values. These
are labelled IBn, IWn, ILn and QBn, QWn, QLn for inputs and outputs
respectively. Input sliders have a green background and their central
button may be moved with the mouse to change the value transmitted
from the widget. To obtain greater precision, the coloured area
above and below the button may be clicked with the mouse button-1,
to decrement or increment the value in unit steps. Output sliders have
a red background and only display the value received by the widget.

 ID parameters

 X0 X2    generates inputs and outputs IX0 QX0 IX2 QX2 in that order
 B0-B2    generates inputs and outputs IB0 QB0 IB1 QB1 IB2 QB2
 IW3 IW7  generates only inputs IW3 and IW7
 QL4-QL7  generates outputs QL4 QL5 QL6 QL7

 Combined input/output or input-only parameters may optionally be
 initialised with =<number>.
 <number> may be decimal, octal, hexadecimal or binary as follows:
 X10=15 X11=017 IX12=0xf IX13=0b1111    all equal decimal 15
 only decimal initialisers may be preceded by a minus sign
 IW10=-70 initialises IW10 with -70 (IW10=-70,-100,0 to be useful)

An optional initialiser may be placed after the second parameter
of a range.  Every input in the range will be initalised to the
same value.  Outputs cannot be initialised.

 IW20-IW27=50  initialises IW20 IW21 .. IW27 with 50
 For analog inputs this means that the slider and the output are
 set to the value of 50, which happens to be in the middle.

 X20-X27=0b1011 initialises IX20 IX21 .. IX27 with 0b1011
 For digital inputs X20 this means that IX20.0 IX20.1 and IX20.3 are
 set - all other bits remain reset. Similarly for IX21 to IX27.

All analog parameters or parameter ranges may optionally be followed
by two or three comma-separated numbers naming the start, finish
and optionally the resolution of the numbers displayed by the analog
scale. Default ',0,100' which is equivalent to ',0,100,1'.  A negative
resoltion reverses the direction of the slider. (0 is not allowed)

All digital parameters or parameter ranges may optionally be followed
by one, two or three comma-separated numbers. Two consecutive commas
or any numbers missing at the end will be filled with a default.

 Number 1) is a bitmask defining, whether a particular bit .0 to .7
           is defined and should be implemented.  Default ',255'
           defines all 8 bits. The easiest way to declare the bit mask
           is as a binary number, eg: ',0b10001111'. This declares that
           bits .0, .1, .2, .3 and .7 are defined in the application
           and should be implemented. The bits which are not defined
           are left blank. Default 0b11111111 - all bits are defined.

 Number 2) is a delay value in milli-seconds. Any value 50 and above
	   is used to reset the button internally after that many
	   milli-second, which makes it a push-button that only
	   needs to be clicked once with the left mouse button.
	   Non-zero values less than 50 (including negative values)
	   are set to 50 ms. Default 0 - normal on/off button.

 Number 3) is a bitmask defining, whether a particular bit .0 to .7
	   is a push-button or is a normal on/off button. This is only
	   useful if a delay value has been specified. This optional
	   mask lets you select which bits in one group are to be
	   push-buttons. Default 0x11111111 - all push-buttons.

ID-parameter, range, initialiser and number-range must be written
without spaces in the command line unless they are quoted. In the
optional INI file which can be read with the -f option, white space
can be placed between parameter, range, initialiser and number-range.
They must only be all in one line. In an INI file any text following
'#' is ignored and treated as a comment.

A separate frame is generated for each input and output ID; two frames
for an ID not specifying I or Q. Each frame is labelled with the ID
followed by the optional instance; eg IX0 or IX0-1. The number of
columns is limited to 12, to prevent the whole widget becoming too
wide. On the other hand the number of rows is also limited to 3 (has
precedence). The number of frames in a row (columns) may be specified
with the -c option (absolute maximum with -C).  If the number of
I/O frames exceeds an absolute maximum of 18 columns and 3 rows,
more rows are generated, which can be accessed with a scroll-bar.

Digital frames have a vertical row of 8 Checkbuttons labelled .0 .1
... .7 for IX0.0 IX0.1 ... IX0.7; Input Checkbuttons are green when set
and may be pressed on and off or on only if they are a push-button;
Output Checkbuttons are red when set and display an external value
only - they cannot be pressed.

Analog frames have a vertical slider labelled 0 to 100 by default.
Analog inputs have a green slider - analog outputs a red slider. Only
input sliders can be moved to change an input value.

An B<iCbox> generated with the -d option will make input frames which
behave like outputs (except for the labels). This is useful for
monitoring real external inputs (and outputs).

An B<iCbox> generated with the -r option will reverse the functionality
of inputs and outputs. Frames whose ID starts with a Q can be modified
whereas frames whose ID starts with I will only monitor. An B<iCbox> -r
mimics an iC application during early development.

An optional frame with a B<Hold> button is generated with the -H
option showing [II] (press to hold).  After this button is pressed it
shows [>] (press to continue).  While B<Hold> is pressed, any input
changes are queued and not transmitted until the B<Hold> button
is released. This is useful for testing iC programs in a situation
when several inputs must arrive simultaneously. Push-buttons with an
internal reset delay are also held, sending their on and delayed off
state when the B<Hold> button is released.

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<immcc(1)>, L<iClive(1)>, L<iCserver(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2012  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
