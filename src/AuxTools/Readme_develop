Notes on the development environment of the iC components

	John E. Wulff   04 February 2007

    $Id: Readme_develop,v 1.22 2015/12/05 03:00:35 jw Exp $

Originally the system was developed under Unix Sytem V (1985 - 1986)
The system was ported to DOS with the MS-C compiler (1987 -1989)
and Borland C++ 3.1 (1990 - 1994) both with the MKS toolkit.

The development environment has been SuSE Linux 4.3 - 9.3 (1995-2005).
Various versions of openSUSE - up to 13.1 (Bottle) (x86_64) (2006-2015).
The distribution was tested under Red Hat Linux 7.2, Debian Linux and
the Cygwin environment under Windows XP. A native Windows port with
MS Visual C++ and Perl only is under development.
All development since 2006 has been on SUSE Linux 10 11.2 11.3 11.4
12.2 and 13.1. Further work on MAC OS-X and Windows is planned.

In September 2013 iC was ported to Raspbian (Debian Wheezy) on the
Raspberry Pi with arm11 processor. There were no problems, except the
gcc ARM compiler defaults to 'unsigned char'.  Since the core of the iC
system is based on signed arithmetic with char's, I had to change the
declaration of those to 'signed char'. The following package had to be
installed with sudo apt-get install: perl-tk. The following packages
are optional but useful: bison, flex, gtkwave, rcs and vim. (2 weeks
with an old vi was punishment enough). After that all tests passed.

The compilers required are for C, Yacc (Bison) and Lex (Flex). Building
the system requires Perl 5, Bash, Make and Configure. (Older Sed
and Awk scripts have been converted to Perl scripts). Running iC
applications requires Perl 5 and Bash. The graphical support applications
require perl/Tk.

Building the distribution is described in detail in README. The usual
steps followed in Linux projects has been adopted: tar -x, configure,
make, make test, make install.

This builds and installs 4 components from the sources:

    immcc	the stand-alone immediate C (iC) compiler, which
		translates iC language files <source>.ic to C files
		named <source>.c.

    immac	translates an iCa language file <source>.ica to an
		iC language file <source>.ic, which can then be
		compiled by immcc and the C compiler. immac has a
		macro facility which handles object type macros and
		in the latest release also function type macros,
		conditional compilation and include files making it
		a replacement for the cpp C pre-compiler.

    libict.so	a dynamic library to build stand alone applications
		from iC sources for the TCP/IP support environment

    libict.a	a static library to build stand alone applications
		from iC sources for the TCP/IP support environment
		supporting full debugging output at the console

The following C test compiler is rarely used during development:

    lmain	lmain only tests the internal C-parser and is not
		required for any other purpose

The following 2 components, which can be optionally built are obselete:

    icr		an iC compiler with integrated run-time keyboard
		I/O test environment (was used mainly under DOS)

    ict		an iC compiler with integrated run-time TCP/IP
		test environment (used with networking components)

For testing the code and node network generating strategies both these
obselete compilers have been maintained for the latest extensions of the
iC language.

Postprocessors	(written in Perl)

    pplstfix	Postprocessor used to fix forward references and aliases
		in iC listing files generated by the iC compilers.
		Called from 'immcc', 'icr' and 'ict' while compiling.

    immac -m	execute the macro part of immac only to post-process
		#define etc in C code while translating with immcc.
		Called from 'immcc', 'icr' and 'ict' instead of the
		full 'cpp' pre-compiler.

    immac -M	execute the macro part of immac only to post-process
		%define etc in yacc code while translating comp.y and
		gram.y.  Called from 'make'.

Additionally a number of Perl scripts are installed to establish
a TCP/IP networking environment for running iC applications:

    iCserver	a network server for connecting I/O components
		with running iC applications over TCP/IP.

    iCbox	a network client I/O component to generate digital
		or anlog input for an iC application and to display
		digital or analog output from an iC application.
		This is a simulation of real I/O components.  Can also
		be used to monitor real I/O when called with -d

    iClive	the IDE for immediate C - a programming and debugging
		tool for iC applications.  It provides an edit window
		in which the text of an iC source can be displayed
		edited, built, run and saved.  It is also a network
		client for a running application and shows the live
		state of nodes in the running application as coloured
		text showing true and false for imm bit variables
		and as numerical information for imm int variables.

    iClift	a very specific network client to provide realistic I/O
		for control programs to manage lifts.  Simulation of
		the physics and appearance of lifts in a building with
		IEC inputs sent to an iC control application from
		simulated sensors and buttons and using IEC outputs
		received from an iC control application to initiate
		and stop simulated movement and to reset buttons.

    iCgpio	(only useful on a Raspberry Pi) a network client
		I/O component to generate digital inputs and outputs
		from the GPIO pins of a Raspberry Pi or from the
		connections or relays of one or more PiFace I/O
		boards connected indirectly to the GPIO pins via SIO.
		(This is real I/O and not a simulation). This program
		is written in C and uses the same TCP/IP functions as
		compiled iC apps (tcpc.c). The functionlity of this
		program can also be linked directly to an iC app,
		which then no longer requires iCserver (except for
		debugging with iClive or if there is more TCP/IP I/O).

The netorking components can be used on one computer using 'localhost',
which is the default host name or distributed over several computers using
appropriate host names with the -s <host> option.  The default networking
port is '8778'. Another port can be selected with the -p <port> option.

Each of the first 4 Perl scripts use the module Msg.pm - the Messaging
Toolkit originally described in "Advanced Perl Programming" by Sriram
Srinivasan - an event-driven, client-server, messaging framework,
using the IO::Select and IO::Socket modules. Msg.pm has been very
useful, but lately a number of problems with it were discovered when
testing full scale iC applications under realistic conditions.

#   Modification John Wulff 2000.05.27 - event_loop()
#	select time_out is 0 if loop_count is defined
#	else undef - which maintains previous functionality
#
#	if loop_count has a fractional part interpret it as
#	the time_out value and set loop_count to 1 - useful for
#	timed message loops
#
#   Modification John Wulff 2012.10.31 - enable non-blocking
#	The original implemantion from 2000 had:
#	  my $blocking_supported = 0;	# executed after BEGIN block
#	leading to the situation that setting $blocking_supported in
#	the BEGIN block was overwritten with 0 - inhibiting non-blocking.
#
#	Also set_non_blocking and set_blocking requires F_GETFL in the
#	first fcntl() call, which was never executed because of the above.
#
#	According to the Errata for "Advanced Perl Programming"
#	$offset in _rcv() was incorrectly calculated - fixed.
#
#   Modification John Wulff 2012.11.06 - disable Nagle's algorithm
#	From <en.wikipedia.org/wiki/Nagle's_algorithm>
#	Applications that expect real time response can react poorly to
#	Nagle's algorithm. The algorithm purposefully delays transmission,
#	increasing bandwidth efficiency at the expense of latency.
#	For this reason applications with low bandwidth time sensitive
#	transmissions typically use TCP_NODELAY to bypass the Nagle delay.
#
#	This very much applies to network traffic in the immediate C system.
#	Messages are typically 5 to 10 bytes long staggered at intervals
#	which are usually 10's of milliseconds to seconds apart, but can
#	involve a burst of several messages as a result of the same trigger.
#	Nagle's algorithm sends the first if these bursts and delays the
#	rest for up to 500 ms or when an unrelated return message comes,
#	which is much too late.	(Also changed for C code in tcpc.c)
#
#   Modification John Wulff 2013.04.25 - modify send buffering
#	The syswrite() call in _send() takes a short time to complete. The return
#	from the OS is initiated by an interrupt. If another _send() is executed
#	before the previous syswrite is complete, it causes a 2nd syswrite() of the
#	same message at the head of the queue, because the message was not shifted
#	until the 1st syswrite has completed. In the changed code $conn->{sendBusy} is
#	set before starting to syswrite messages in the buffer. When another _send
#	occurs while busy is set, _send returns immediately. The queued message
#	is sent during the current loop emtying the buffer.
#	By having the $conn->{sendBusy} flag, messages are written in the order
#	they come in.  $conn->{sendBusy} only applies to one $conn. Other
#	connections can barge in and pre-empt a sys_write without ill effects.
#
#	A similar modification has been implemented in _rcv() to buffer received
#	messages when rcvd_notification_proc is interrupted starting another _rcv().
#	This uses the $conn{rcvBusy} flag to return immediately.
#
#   Modification John Wulff 2013.04.28 - added trace arguments to inhibit_nagle()
#	  Msg->inhibit_nagle(0)		# Nagle's algorithm active
#	  Msg->inhibit_nagle(1)		# inhibit Nagle's algorithm - no traces
#	  Msg->inhibit_nagle(1, 1)	# also trace rcv calls only
#	  Msg->inhibit_nagle(1, 0, 1)	# also trace send calls only
#	  Msg->inhibit_nagle(1, 1, 1)	# also trace rcv and send calls
#
#   Modification John Wulff 2015.03.06 - added time out delay to connect() calls
#	Some iC clients, in particular iCbox, are started from applications
#	automatically with a system() call. These same applications usually also
#	start iCserver if it is not already running. This may involve a timing
#	race and the client may not be able to connect to iCserver immediately.
#	To guarantee a smooth startup sequence, connect() has been modified to
#	retry 3 times at 2 second intervals.
#	
#	This action is not appropriate if there is no likelyhood of iCserver
#	being started externally. This applies to iClive, which starts iCserver
#	itself if there is none to connect to. To speed up startup of iClive
#	an extra optional argument '$time_out_inhibit' has been added to connect().
#	  Msg->connect($host, $port, $rcvd_notification_proc, $time_out_inhibit)
#	$time_out_inhibit undef or 0	# retry 3 connects at 2 sec intervals
#	$time_out_inhibit 1		# returns immediately if connect fails

    iCmake	make one or more iC application(s) from iC or iCa
		source(s) supplemented by optional .ih headers.

		If a source file contains 'FOR loops', %define macro
		definitions or there are -P macro definitions, it is
		an iCa language file and should be named <source>.ica.
		This is translated to an iC source file using immac.

		Each iC source file is compiled using 'immcc' which
		generates a C file, which in turn is compiled and
		linked with 'libict.so' or 'libict.a' generating the
		application.

    iCman	a general purpose man page viewer based on Sriram 
		Srinivasan's perlman - extended to be a full man page
		browser with hyper-link and search facilities.

All components and the generated applications will display detailed
usage texts when called with the -h option. The main components also
have POD texts, which expand into full man pages.

Scripts:

    configure:	#! /bin/sh
		Generated from autoconf. Slightly modified by jw
		Generates 'Makefile' from 'Makefile.in'

    install.sh:	#!/bin/sh
		install script - from X11R5;
		expected by configure and used in 'make install' if
		configure cannot find a better BSD compatible 'install'
		
		Actual use /usr/bin/install (file-4.13) via /usr/bin/ginstall
		Also use /usr/bin/ranlib

    perlinstall:#!/bin/sh
		install Perl modules in the correct $INC path;
		used in 'make install'

    iCbox:	#!/usr/bin/perl Tk.pm Msg.pm
    iClive:	#!/usr/bin/perl Tk.pm Msg.pm
    iCman:	#!/usr/bin/perl Tk.pm
    iClift:	#!/usr/bin/perl Tk.pm Msg.pm
    iCserver:	#!/usr/bin/perl Msg.pm
    pplstfix:	#!/usr/bin/perl
    iCmake:	#!/bin/bash

    makeAll:	#!/bin/bash
		calls 'make' with the correct environment to make
		immcc, icr, ict, libict.a and lmain
		-q quiet, output only headings and error messages
    		-g compile for debugging and no optimisation (default -O2)
		-h full help text

		calls 'make' with OPT=''  to make immcc         (OPT+=YYDEBUG if -c)
		calls 'make' with OPT=RUN to make icr           (OPT+=YYDEBUG if -r)
		calls 'make' with OPT=TCP to make ict           (OPT+=YYDEBUG if -t)
		calls 'make' with OPT=LOAD TCP to make libict.a (OPT+=YYDEBUG if -l)
		calls 'make' with OPT=LMAIN to make lmain       (OPT+=YYDEBUG if -m)
		"make" or "make all" calls makeAll -rm
		"make quiet" calls makeAll -qrm
		use makeAll directly if different options are required

    comp.pl:	#!/usr/bin/perl
    gram.pl:	#!/usr/bin/perl
    icg.pl:	#!/usr/bin/perl
    pawk.pl:	#!/usr/bin/perl
		4 support scripts for make

    m:		#!/bin/bash
		Make all iC components for debugging and install them.
		For this to work /usr/bin/install and /usr/bin/ranlib must have
		the "set user ID on execution" bit set (chmod +s ... as root).
		Optionally make all iC applications with the new libict.a
		Usage m[ -iudszh] [[<iCmake_options>] <iC_sources>]
		-i	execute chmod +s /usr/bin/install /usr/bin/ranlib as su once
			this is required to run make install as an ordinary user
		-u	make any compiler targets with Symbol SYUNION option
		-d	make with -DDEQ Gate option (make clean required first)
			double ended queue processing is slightly faster
		-s	make with -DINT_MAX=32767 (make clean required first)
			(on a 16 bit system INT_MAX is 32767 and -s is not required)
			simulates compilation for a 16 bit system, which does
			no 32 bit arithmetic and rejects QL.. and IL.. I/O unless
		-y	make with -DLONG16        (make clean required first)
			produces code for long int arithmetic on a 16 bit system
		-h	this help text
		<iC_sources>  list of iC source files which will be made with iCmake
		for other options see m -h

Auxiliary scripts for testing compiler outputs

    mklst:	#! /usr/bin/perl
		make a list of files generated by each iC source
		name passed as a parameter; used by 'ml'

    mkpp:	#!/usr/bin/bash
		make (or diff) version files for previous versions
		of the iC system. Uses 'mkv' of John Wulff's version
		control system.  Execute in directory Test2; etc

    ml:		#!/usr/bin/bash
		make lists for immcc compiler tests; uses 'mklst'
		Usage:	ml [-h]
		-h	this help text
		make different lists in a Test directory
		p.lt	# all for copying
		pd.lt	# sources, includes and derived for comparing
		pe.lt	# executables only
		pc.lt	# C files only
		pi.lt	# ini files only
		pl.lt	# lst files only
		p6.lt	# lst6 files only
		pp.lt	# iC files only
		ps.lt	# iC source files *.ic and *.ih
		pg.lt	# exe .c .ini .lst .lst6 - generated - may be deleted in source dir
		-g	pg.lt - exe .c .ini .lst .lst6 - generated files only
		-n	pn.lt - exe .c .ini .lst .lst6 - generated corpses - no .ic to match

    mm:		#!/usr/bin/bash
		make iC test cases from pm.lt which may specify linking iC's
		pm.lt must be edited manually from pp.lt (.ic files only)
		to reflect those which must be linked into an application
		Usage:	mm [-gASRxzNh][ -v<N>][ -d<opt>][ -O<level>]
		-v<N>	use ict<N> eg ict1 ict2 ... with libict1.a libict2.a ...
		-d<opt>	call immcc with extra -d<opt> orred into normal -d474
		-g	each expression has its own C code for debugging with gdb
		-A	compile output ARITHMETIC ALIAS nodes for symbol debugging
		-S	strict compile - all immediate variables must be declared
		-P	pedantic: warning if variable contains $ (default $ allowed)
		-PP	pedantic-error: error if variable contains $
		-O <level> optimisation -O0 none -O1 bit -O2 arithmetic -O4 eliminate
			duplicate arithmetic expressions -O7 all (default)
		-R      no maximum error count (default: abort after 100 errors)
		-i	produce file.ini with load info but no INITIALIZATION
		-I	produce file.ini with load info and full INITIALIZATION
		-J	produce file.ini without load info but full INITIALIZATION
		-x	auxiliary files .iC_list1.h .iC_list2.h not deleted
		-z	echo compiler calls with all options for debugging
		-N	No nice with calls of immcc and gcc compilers (default is nice)
		-h	this help text
		uses iCmake -v<N> -d<opt> -O<level> to make each line of the list pm.lt
		which has mostly individual lines naming one source eg. xxx.ic
		but may also have lines like "-l a.ic a1.ic a2.ic" for linking

    my:		#!/usr/bin/bash
		make iC test cases from pp.lt which is generated by ml
		Usage:	my [-gASRiIJ6xzh][ -d<opt>][ -O<level>]
		-d<opt>	call immcc with extra -d<opt> orred into normal -d474
		-g	each expression has its own C code for debugging with gdb
		-A	compile output ARITHMETIC ALIAS nodes for symbol debugging
		-S	strict compile - all immediate variables must be declared
		-P	pedantic: warning if variable contains $ (default $ allowed)
		-PP	pedantic-error: error if variable contains $
		-O <level> optimisation -O0 none -O1 bit -O2 arithmetic -O4 eliminate
			duplicate arithmetic expressions -O7 all (default)
		-R      no maximum error count (default: abort after 100 errors)
		-i	produce file.ini with load info but no INITIALIZATION
		-I	produce file.ini with load info and full INITIALIZATION
		-J	produce file.ini without load info but full INITIALIZATION
		-6	produce logic generation listing file.lst6
		-x	auxiliary files .iC_list1.h .iC_list2.h not deleted
		-z	echo compiler calls with all options for debugging
		-h	this help text
	uses immcc -d76 -d<opt> -O<level> x.ic to make each line of the list pp.lt
	uses immcc -d74 -d<opt> -O<level> -o x.c x.ic to make each line of the list pp.lt

    mo:		#!/usr/bin/bash
    		Usage: mo [-tTrRm] [file ...] # if none uses $(cat pa.lt)
		make an 'ict' compiler for each iC application and
		store the generated text files in directory ListT.
		The generated standard and error outputs are
		stored in the file ListT/Init.out. This information can
		then be diffed with runs of previous versions of
		the iC system. (use Mdiff -k ListT/*.* ListT/Alex.)

		mo -r makes an 'icr' compiler for each application and
		stores the generated text files in ListR

    mpv:	#!/usr/bin/bash
		make (or diff) versions of immcc ict and libict.a
		named in a parameter list or all versions;
		assumes version directories Test2/Alex??

    mz:		#!/usr/bin/bash
		Usage:	mz [-dh] [-min<MIN>] [-max<MAX>] file ...
		-d	diff previously made files
		-min<MIN> minimum version to process (0 .. 9999)
		-max<MAX> maximum version to process (0 .. 9999)
		-N	No nice with calls of immcc and gcc compilers (default is nice)
		-h	this help text
		uses iCmake -Iv<N> to make file ... for each version Alex<N>
		N is the minor version number of icc.v (version 1.<N>)
		iC files are made from compiler ict<N> and libict<N>.a
		if no files are specified uses mm via pm.lt
		directory Alex<N> must exist (generated files are saved there)

    tt:		#!/usr/bin/bash
		Regression test of iC compilation of ic sources in Test1 - Test10
		Usage: tt [-clrgASP[P]RiIJ6x:f:F:zvh][ -O<level>]
		  [ -m<txt>][ -d<opt>][ -x<regex>][ -f|F<filter>] <dir1>[ <dir2>]
		-m<txt>	place <txt> message in log file just after full date
		-d<opt>	call immcc with extra -d<opt> orred into normal -d474
		-c	only copy files to <dir1>; must be new, else compare only
		-l	list files which differ (default is full Mdiff output with -e)
		-r	put Rdiff *.lt output in log file
		-x<regex>  in each Mdiff ignore changes in lines that match regex
		-f<filter> process the first file in an Mdiff by <filter> before diff
		-F<filter> process the second file in an Mdiff by <filter> before diff
		-g	each expression has its own C code for debugging with gdb
		-A	compile output ARITHMETIC ALIAS nodes for symbol debugging
		-S	strict compile - all immediate variables must be declared
		-P	pedantic: warning if variable contains $ (default $ allowed)
		-PP	pedantic-error: error if variable contains $
		-O <level> optimisation -O0 none -O1 bit -O2 arithmetic -O4 eliminate
			duplicate arithmetic expressions -O7 all (default)
		-R      no maximum error count (default: abort after 100 errors)
		-i	produce file.ini with load info but no INITIALIZATION
		-I	produce file.ini with load info and full INITIALIZATION
		-J	produce file.ini without load info but full INITIALIZATION
		-6	produce logic generation listing file.lst6 in Test2 etc
		-z	echo compiler calls with all options for debugging
		-v	author and version information
		-h	this help text
		--	all further arguments are treated as files

		tt must be called from a directory, which has a number of
		sub-directories Test1, Test2, Test3 .. Test9 containg iC sources.
		Each iC source is made with iCmake, generating different files.

		<dir1> or <dir1>_<opt> are sub-directories of directory
		Test1, Test2, Test3 .. Test9 (however many exist)
		<dir1> will be created if it does not exist and generated
		files copied to it; if <dir1> exists, the generated files
		will be compared with files in <dir1> with Mdiff -kLe
		If no <dir1> is specified no files will be copied or compared

		If <dir2> is specified and exists and <dir1> does not exist
		<dir1> will be created and only changed files will be coped to <dir1>.
		The others will be soft links from <dir1> to <dir2>
		If <dir2> is specified and <dir1> exists all files in <dir1>
		will be compared with all files in <dir2> with Mdiff -kLe

		If <dir2> is an absolute path, it must be the base of
		another set of directories Test1, Test2, Test3 .. Test9

Vim support files

    ic.vim:	Vim syntax file for the iC language. The file was developed from
    		c.vim and yacc.vim in /usr/share/vim/current/syntax where ic.vim
		must also be located for Linux.
		The colouring of IEC-1131 I/O names like IX0.1, QB1, TX0.4 etc.
		is made red, like numbers to make them stand out. A proper iC program
		source should not use I/O names directly, but rather use aliases in a
		table where descriptive names in the program are allocated to physical
		I/O points. In the listings these aliases will show up nicely.

    filetype.vim:	Vim filetype file selects *.ic *.ica *.ih and *.lst as iC files

a2ps pretty printer support files

    ic.ssh:	a2ps syntax file for the iC language. The file was developed from
    		c.ssh and gnuc.ssh in /usr/share/a2ps/sheets where ic.ssh must also
		be located for Linux.

    sheets.map:	Append the following 5 lines (without the leading #) to
		/usr/share/a2ps/sheets.map (or directory where style sheets are stored)
		# immediate C
		ic:	/*.ic/
			/*.ih/
			/*.ica/
			/*.lst/

Development phases of the immcc compiler

This compiler is at the heart of the iC system and translates immediate
C code into C code, which can then be processed by a standard C
compiler and linker to produce executable apps.

Originally a compiler was built, which produced the execution
network directly. This compiler 'icr' was for direct keyboard I/O
and was useful with MS DOS.  Later 'ict' for TCP/IP I/O was added.
Plans were for a compile and run system similar to Perl. This was fine
for bit processing, which required no user defined C functions. Getting
this right was the work of the first years of development.  As soon
as arithmetic expression handling and embedded C code were added
the compile and run scheme proved to be clumsy.  Every time new
C snippets appeared in the user code, the basic compilers 'icr' or
'ict' had to be relinked to even run the iC code.  For various reasons
'icr' and 'ict' have been maintained until now (to prove compiler
implementations were correct und 3 different conditions).  Now that
all aspects of the language have been implemented, 'icr' and 'ict'
will be dropped by cutting out the optional code from the sources.

The design of the 'immcc' compiler and indeed the iC language borrowed
heavily from Yacc.  The idea of C literal blocks with their %{ ... %}
special braces were a direct copy. The idea of recognising language
entities and producing code or data blocks are central to compiling,
not just to a Yacc based compiler.

The idea of producing a network of nodes of individual immediate
variables, linked by forward links identifying nodes whose expressions
are dependant on a node was an idea I had in 1985 from reading about
neural networks. Later I discovered that Perl uses a very similar
execution network, albeit not in the forward execution sense but in
the standard instruction flow sense.

Built-in functions like the D flip-flop and the SH shift-register
were always part of the iC design and were initially implemented by a
fairly complex subsystem of the compiler. Later user defined function
blocks were added and there was a certain amount of overlap. A number
of the already compiled built-in functions could be defined as function
blocks using a subset of simple built-in functions.

As a first step in bootstrapping, the built-in functions, which could
be defined using simpler built-in functions were placed as a text
string of iC source code in the init.c file. One of the initialisation
steps in starting up the immcc compiler was to first compile the
function blocks from this Text string. The effect was that function
block templates for all extended built-in functions were available
for all iC programs to be compiled. One of the main reasons for
doing this was the fact that extending the underlying compiler to
handle ever more complex built-in functions proved tedious and error
prone. Bootstrapping was much simpler.

This left a small set of built-in functions, which could not be
expressed as function blocks.  A manual observation of the nodes and
links produced by each low level built-in function was undertaken
and arranged as if each had been compiled to a function block
template. Calling these manually compiled function blocks produced
the same code as the directly compiled built-in functions.

In a second phase of bootstrapping the manual process was replaced
by a generator, which was called once to produce the source code of
the nodes and links for function block templates for the low level
built-in functions. This source code was edited manually into the
initial symbol table in init.c.  These function block templates are
now in place when the immcc compiler is loaded.  At this point most
of the code for compiling function blocks could be scrapped and is
now only required for the bootstrapping process itself.

For some reason the extended built-in functions which are compiled
from built-in text each time the compiler is started were ignored
during the second bootstrapping phase.

In a third bootstrapping phase the extended built-in functions were
also pre-compiled and patched into the source code of the symbol
table, which makes the slightly messy compiling of these function
blocks unnecessary. Since generating the bootstrapping data is
competely automatic it will still be possible to extend the language.

Another change, which was made in the last 2 years was a mechanism to
allow logical AND and OR gates with more tha 127 inputs. The original
algorithm, using majority logic using a signed char member was decided
in 1985 when memory was limited and the size of a node had to be kept
to minimum. In practice it is hard to imagine a real application using
gates with more than 127 inputs. In practice two or more gates could
always be cascaded in such extreme cases, but this clashed with the
optimisation code, which tried to join cascaded gates into one. In
finalising the compiler there were three options:

    1)	Stop the optimiser from joining gates if the result exceeded
	127 inputs.

    2)	Ignore the number of inputs to gates during the compile
	phase (which had been checked until then) and introduce code
	at the very end to generate a cascade of gates if the number
	of inputs to an AND or OR gate exceeds 127. For XOR gates
	the number of inputs is irrelevant,

    3)	do majority logic with a 16 bit signed short member variable.

Option 2 was chosen, because it was easier to do than option 1. Also it
freed the iC programmer from having to think of this limitation. I can
now sleep easier knowing that this very unlikely case will be handled
correctly. (it has been tested carefully). There is still a limit -
it is of the order of 30,000 inputs - I can sleep easy with that.

Option 3 would have been easy but seemed unsatisfactory after so much
work was put into minimising the size of a node. The effect would have
been the same as for option 2.

Development of auxiliary drivers
