#!/usr/bin/perl

#################################################################
#
#	Copyright (C) 2000-2008  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <ic@je-wulff.de>
#
#	immac
#
#   Pre-compiler to convert "immediate C" source files containing arrays
#   int straight "immediate C".
#
#   The immediate C language extension is as follows:
#
#	immediate array variables are defined by appending an expression
#	enclosed in square brackets to the array name eg. array[i+10]
#
#	unless the expression in the square brackets is a constant
#	expression eg. array[4+10], the line containing the expression
#	must be contained in a for block as follows:
#
#	for (int i; i < 32; i++) {
#	    array[i+10];
#	}
#
#	The following "perlish" syntax does the same, but is not recommended.
#
#	for i (0 .. 31) {
#	    array[i+10];
#	}

#	The only reason it is included, is to generate irregular Perl type lists,
#	which is unlikely to be an important feature.
#
#	for i (0, 3, 4, 10, 5) {
#	    array[i];
#	}
#	will generate array0 array3 array4 array10 array5
#
#	Only the control variable 'i' in the above instances may be used in the
#	index expressions of the block. These 'for' blocks may be nested.
#	In that case all the control variables in each nested block may
#	be used.
#
#	Since this pre-processor only manipulates text, and does not compile,
#	there are some restrictions. The 'for' line with or without the following
#	opening brace and the braces must be on seperate lines. These are not
#	part of the immediate C code itself. The lines are called control lines.
#	Control lines may terminate with a C /* ... */ or C++ // comment.
#	(They may in fact terminate with a Perl # comment). But a C comment
#	in a control line must be completed on the line on which it starts.
#	(C++ or Perl comments terminate on the one line anyway).

#	Other immediate C lines in the block may contain bracketed index
#	expressions, but they don't need to.
#
#	All immediate C lines in a  'for' block are repeated a number of
#	times controlled by the 'for' control line.
#		As shown above, a 'C' type control expression
#			for (int i; i < 32; i++)
#		is preferable - it fits into the general 'C' syntax of
#		'immediate C'.
#		A 'perlish' syntax rather than a 'C' syntax may be used:
#			for int i (0 .. 31) {
#		This is, because the pre-compiler eval's a slightly
#		modified form of the code in Perl. This syntax is very
#		simple and fits the limitations of expanding an array.
#
#		The 'int' type specifier of the control variable is optional - it
#		may be used in both variants to make the syntax look more correct.
#		It must be remembered, that the control variable is usually an 'int'.
#		In the Perl code, 'use integer' has been called, so integer division
#		always applies.
#
#		In the case a 'Perl' type list is used, then strings may be used:
#			for i ("AA", "BB", "CC", "DD", "EE") {
#		If these are not numeric, then no arithmetic may be done when the
#		control variable is used in an index expression:
#			    array[i];
#		will generate arrayAA arrayBB arrayCC arrayDD arrayEE
#		Note: special care must be taken, that these strings are
#		not defined as macros.
#
#   The strategy is to match lines starting with the regex
#
#	for (identifier    or	for identifier ( #    identifier matches /[A-Z_a-z]/w*/
#
#   if it does not match substitite '[' by '@{[' and ']' by ']}'
#   and print line
#
#   else
#
#   Substitute identifier by my $identifier
#   Store $identifier in hash %identifiers
#
#   Next a block inside matching braces is looked for in the current
#   line and any following lines until the final closing brace is found
#   All of this is stored in the string $block
#
#   All occurrences of any identifier from %identifiers in [ ] in that block
#   is replaced by @{[$identifier ... ]} - even inside C or C++ comments
#   Any line not starting with 'for' is replaced by 'print "line"'
#   else do same as above for nested for's
#
#   eval $block;	# which is a string evaluation
#   die if $@;		# fail on error
#
#   since use integer pragma is used, the following is valid:
#
#   for (n = 0; n < 16; n++) {
#       QX[n/8].[n%8] = IB[n];\n"
#   }
#
#   generates the following, which is eval'd
#
#   for (my $n = 0; $n < 16; $n++) {
#       print "    QX@{[$n/8]}.@{[$n%8]} = IB@{[$n]};\n"
#   }
#
#   to produce the following straight immediate C output
#
#    QX0.0 = IB0;
#    QX0.1 = IB1;
#    ...
#    QX1.7 = IB15;
#
#   which is not brilliant code, but shows the pattern.
#
#################################################################

use strict;
use integer;			# allows QX[n/8].[n%8]

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
format STDERR =
Usage:
 @<<<<<<< [-ath][ -o<out>][ -l<log>][ -e<err>][ -Pmacro[=defn]...] <src.ica>
	$named
    -o <out>   name of generated iC output file (default: stdout)
    -l <log>   name of Perl log file            (default: none)
    -e <err>   name of error file               (default: stderr)
    -P <macro> predefine <macro> evaluated directly by this program
               Usually defined with a numeric value eg. -P m=8
               NOTE: command line definitions have precedence over
		     '%define m 4' in the code (opposite to cpp)
    -a         output for loop control and %define lines as comments
    -t         test if source is an iCa language file - status 1 if it is
    -h         this help text
    <src.ica>  iCa source file with array definiions
$Id: immac,v 1.15 2008/07/03 11:15:37 jw Exp $
.

use vars qw($opt_a $opt_o $opt_l $opt_e $opt_P $opt_t $opt_h);
require "getopts.pl";
&Getopts('ao:l:e:P:th');	# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 2;	# -h, ouput Usage only
}

my %defs = ();
my @def;
my $df;

if ($opt_t) {
    $opt_o = $opt_e = $opt_l = '';
}

open STDOUT, ">$opt_o" or die "Can't redirect stdout to '$opt_o': $!" if $opt_o;
open STDERR, ">$opt_e" or die "Can't redirect stderr to '$opt_e': $!" if $opt_e;
open LOG, ">$opt_l" or die "Can't create '$opt_l': $!" if $opt_l;

my @defines = split(' ', $opt_P);
foreach (@defines) {
    @def = split(/=/, $_);
    $df = shift(@def);		# enter -P NAME(s) in associative array %defs
    if ($df =~ /^[A-Z_a-z]\w*$/) {
	$defs{ $df } = @def ? join('=', @def) : '';
	warn "### WARNING: '-P $df' has no value - should be '-P $df=value'\n" unless @def;
	print LOG "### COMMAND LINE -P $df=$defs{ $df }\n" if $opt_l;
	print "//***** -P $_\n" if $opt_a;
    } else {
	warn "### WARNING: -P '$df' has bad characters - ignored in command line\n";
    }
}

my $ret = 0;
while ($ARGV = shift @ARGV) {
    unless (open (IN, $ARGV)) {
	warn "can't open input $ARGV";
	next;
    }
    print LOG "##### $named $ARGV\n" if $opt_l;
    $ret = processFile();
    close(IN);
}
close LOG if $opt_l;
exit $ret;

####################################################################
#
#	process one file
#
####################################################################

sub processFile {

    my ($identifier, %identifiers, $atom, %atoms, @block, $line, $offset, $lookfor, $pos, $prev);
    my ($translate, $control, $inBlock, $braceCount, $evalBlock, $comment, @ids);
    @block = ();
    $inBlock = 0;
    while (<IN>) {
	$control = 0;
	if (keys %defs) {			# resolve %define macros if any
	    $offset = 0;
	    $prev='';
	    while (/([A-Z%_a-z]\w*)/g) {	# look for 'words' in this line
		$atom = $1;			# 'word' found
		$pos  = length $`;		# position of 'word' found
		if (defined($translate = $defs{ $atom }) and $prev ne '%define') {
		    return 1 if $opt_t;		# test has found iCa code
		    print LOG "### OLD '$atom' '$translate' in $.: $_" if $opt_l and $offset++ == 0;
		    substr($_, $pos, length $atom) = $translate;
		    print LOG "### SUB '$atom' '$translate' in $.: $_" if $opt_l;
		}
		$prev = $atom;
	    }
	}
	$comment = $_;
	if (s/^\s*\bfor\b\s*\(\s*(\bint\b\s+)?([A-Z_a-z]\w*)\s*=/for (my $2 =/
	    or s/^\s*\bfor\b\s+(\bint\b\s+)?([A-Z_a-z]\w*)\s*\(/for my $2 (/	# perlish for i (...)
	   ) {
	    return 1 if $opt_t;			# test has found iCa code 'for loop'
	    $identifier = $2;
	    if (@block == 0) {
		%identifiers = ();
		@ids = () if $opt_a;
		$braceCount = 0;
	    }
	    if ($braceCount < $inBlock) {
		warn "### WARNING: 'for (...)' not nested after previous '{' at '$ARGV' line $.\n";			# }
		print LOG "### WARNING: 'for (...)' not nested after previous '{' at LINE $.\n", @block if $opt_l;	# }
	    }
	    if ($opt_a) {
		my $id;
		foreach $id (@ids) {
		    $comment =~ s/\b$id\b/($id=$identifiers{ $id })/g;
		}
		push @ids, $identifier;
		unless ($comment =~ /{/) {	# }
		    $comment =~ s/\)/) {/;	# } Todo: make more precise
		}
	    }
	    $identifiers{ $identifier } = "\$$identifier";
	    $inBlock++;
	    $control = 1;
	} elsif (/^\s*%\s*\bdefine\b\s+(\S+)\s+(\S.*)$/) {
	    return 1 if $opt_t;			# test has found iCa code %define
	    $identifier = $1;
	    $translate  = $2;
	    if ($identifier =~ /^[A-Z_a-z]\w*$/) {
		if (defined $defs{ $identifier }) {
		    print LOG "### command line definition '$identifier=$defs{ $identifier }' has precedence over %define\n" if $opt_l;
		    print "//***** -P $identifier=$defs{ $identifier } has precedence over $_" if $opt_a;
		} else {
		    $translate =~ s!(\s*/[*/].*|\s+)$!!;	# delete C or C++ comment and trailing blanks
		    $defs{ $identifier } = $translate;		# macro to %defs eg %define X (4 * 8)
		    print LOG "### $_" if $opt_l;
		    print "//***** $_" if $opt_a;
		}
	    } else {
		warn "### WARNING: %define '$identifier' has bad characters - ignored at '$ARGV' line $.\n";
	    }
	    next;				# do not output %define line
	}
	if ($inBlock) {
	    %atoms = ();			# new line in an eval block
	    $offset = 0;

	    foreach $lookfor ('{', '}') {
		for ($pos = $[;
		    ($pos = index($_, $lookfor, $pos)) >= $[;
		    $pos += length $lookfor) {
		    $atoms{ $pos } = $lookfor;	# key is position of atom found
		}
	    }
	    while (/([A-Z_a-z]\w*)/g) {		# look for 'words' in this line
		$atoms{ length $` } = $1;	# key is position of 'word' found
	    }
	    foreach $pos (sort { $a <=> $b } keys %atoms) {
		$atom = $atoms{ $pos };		# process atoms in sequence
		if ($atom eq "{") {
		    $braceCount++;		# brace count at the end of this line
		    $control = 3 unless $control;
		} elsif ($atom eq "}") {
		    $inBlock--;			# for control block finishes with brace
		    if (--$braceCount <= 0) {
			$inBlock = 0;		# actively came out of last nested block
		    }
		    $control = 2;
		    pop @ids if $opt_a;
		} elsif (defined($translate = $identifiers{ $atom })) {
		    substr($_, $pos + $offset, length $atom) = $translate;
		    $offset += length($translate) - length($atom);
		}
	    }
	    if (/[\[\]]/) {
		s/\[/\@{[/g;			# executable interpolated index expressions
		s/\]/]}/g;			# in control and immediate C lines
	    }
	    if ($control) {
		if ($opt_a) {
		    $comment =~ s/"/\\"/g;	# protect interpolated " in string
		    chomp $comment;
		    $comment = "print \"//***** $comment\\n\";\n";
		}
		s!(\s*(/[*/]|#).*|[ \t]+)$!!;	# delete C, C++ or Perl comment and traling blanks
		while (/([A-Z_a-z\$]\w*)/g) {	# look for 'words' in this line
		    $atom = $1;
		    if ($atom ne 'for' and $atom ne 'my' and $atom !~ /^\$/) {
			warn "### WARNING: Bareword '$atom' (unresolved macro) at '$ARGV' line $.\n";
		    }
		}
	    } else {
		if ($braceCount < $inBlock) {
		    warn "### WARNING: '{' must follow 'for (...)' at '$ARGV' line $.\n";			# }
		    print LOG "### WARNING: '{' must follow 'for (...)' at LINE $.\n", @block if $opt_l;	# }
		}
		s/"/\\"/g;			# protect interpolated " in string
		chomp;
		$_ = "print \"$_\\n\";\n";	# print lines in the for loop when eval'd
	    }
	    if ($opt_a and $control == 1) {
		push(@block, $comment);		# } push the 'for () {' comment line for eval
	    }
	    push(@block, $_);			# push the modified line for eval
	    if ($opt_a and $control == 2) {
		push(@block, $comment);		# { push the '}' comment line for eval
	    }
	    if (not $inBlock) {
		print LOG "### evaL BLOCK @{[++$evalBlock]} at LINE $.\n", @block if $opt_l;
		eval "@block";
		die if $@;
		@block = ();			# end of this eval block
	    }
	} elsif (/[\[\]]/
	    and not $opt_t	# do not return for [] outside 'for loop' - could be in comment
	    ) {			# can select either alternatives above or below
###	    return 1 if $opt_t;	# test has found iCa code [] outside 'for loop'
	    s/\[/\@{[/g;			# executable interpolated index expressions
	    s/\]/]}/g;				# outside of a control block
	    s/"/\\"/g;				# protect interpolated " in string
	    chomp;
	    $_ = "print \"$_\\n\";\n";
	    print LOG "### evaL LINE $.\n", $_ if $opt_l;
	    eval;				# evaluate constant expr eg. [4*8]
	    die if $@;
	} else {
	    print unless $opt_t;		# faster if direct print
	}
    }
    return 0;
} # processFile
__END__

############ POD to generate man page ##################################

=head1 NAME

 immac - the immediate-C array pre-compiler

=head1 SYNOPSIS

 immac [-ath][ -o<out>][ -l<log>][ -e<err>][ -Pmacro[=defn]...] <src.ica>
    -o <out>   name of generated iC output file (default: stdout)
    -l <log>   name of Perl log file            (default: none)
    -e <err>   name of error file               (default: stderr)
    -P <macro> predefine <macro> evaluated directly by this program
               Usually defined with a numeric value eg. -P m=8
               NOTE: command line definitions have precedence over
		     '%define m 4' in the code (opposite to cpp)
    -a         output for loop control and %define lines as comments
    -t         test if source is an iCa language file - status 1 if it is
    -h         this help text
    <src.ica>  iCa source file with array definiions

=head1 DESCRIPTION

B<immac> translates an iC-source with array definitions, called in iCa language
file (extension: .ica)
into an expanded iC language file (extension: .ic) which can be compiled with B<immcc>.

B<immac> reads and translates one source eg file.ica. If no options are specified,
output is to 'stdout' and compilation errors (if any) are reported on 'stderr'.

The B<immac> compiler can also produce an optional log file with the -l opton,
which can be run as a Perl script to test 'for loop' generation. This produces
better error messages.

The B<immac> compiler can be used to test for iCa language constructs with the -t opton.
If the source contains 'for loops', %define macro definitions or there are
B<immac> -P macro definitions, the source file is an iCa language file.
Isolated [index expressions] without at least one 'for loop' or %define
are not sufficient to classify a file as an iCa language file.

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<ic@je-wulff.de> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<immcc(1)>, L<iCmake(1)>, L<iCserver(1)>, L<iCbox(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2008  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.

=cut

############ end of POD to generate man page ###########################
