#!/usr/bin/perl

#################################################################
#
#	Copyright (C) 2000-2005  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	immac
#
#   Pre-compiler to convert "immediate C" source files containing arrays
#   int straight "immediate C".
#
#   The immediate C language extension is as follows:
#
#	immediate array variables are defined by appending an expression
#	enclosed in square brackets to the array name eg. array[i+10]
#
#	unless the expression in the square brackets is a constant
#	expression eg. array[4+10]
#	the line containing the expression must be contained in a for block
#	as follows:
#
#	for i (0 .. 31) {
#	    array[i+10];
#	}
#	Only the control variable 'i' in this instance may be used in the
#	index expressions on the block. These for blocks may be nested.
#	In that case all the control variables in each nested block may
#	be used.
#
#	Since this pre-processor only manipulates text, and does not compile
#	there are some restrictions. The for line with or without the following
#	opening brace and the braces must be on seperate lines. These are not
#	part of the immediate C code itself.
#	Other immediate C lines in the block may contain bracketed index
#	expressions, but they don not need to.
#
#	All the immediate C lines are repeated a number of times controlled
#	by the for block control line.
#		A 'perlish' syntax rather than a 'C' syntax was chosen
#		deliberately, because the pre-compiler eval's a slightly
#		modified form of the code in Perl. This syntax is very
#		simple and fits the limitations of expanding an array.
#
#   The strategy is to match lines starting with the regex
#
#	for identifier ( ... )	#    identifier matches /[A-Z_a-z]/w*/
#
#   if it does not match substitite '[' by '@{[' and ']' by ']}'
#   and print line
#
#   else
#
#   Substitute identifier by my $identifier
#   Store $identifier in hash %identifiers
#
#   Next a block inside matching braces is looked for in the current
#   line and any following lines until the final closing brace is found
#   All of this is stored in the string $block
#
#   All occurrences of any identifier from %identifiers in [ ] in that block
#   is replaced by @{[$identifier ... ]} - even inside C or C++ comments
#   Any line not starting with 'for' is replaced by 'print "line"'
#   else do same as above for nested for's
#
#   eval $block;	# which is a string evaluation
#   die if $@;		# fail on error
#
#   since use integer pragma is used, the following is valid:
#
#   for n (0 .. 25) {
#       QX[n/8].[n%8] = IB[n];\n"
#   }
#
#   generates
#
#   for my $n (0 .. 25) {
#       print "    QX@{[$n/8]}.@{[$n%8]} = IB@{[$n]};\n"
#   }
#
#################################################################

use strict;
use integer;			# allows QX[n/8].[n%8]

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
format STDERR =
Usage:	@<<<<<<< [-h][ -o out_file][ -l log_file] in_file ...
	$named
	-o out	produce iC out_file (default: stdout)
	-l log	produce log_file, usually 'immarc.log'
	-h	help, ouput this Usage text only
	in_file	input iC file(s) with arrays and for ()
$Id: immac,v 1.3 2008/06/09 09:02:25 wulff Exp $
.

use vars qw($opt_o $opt_l $opt_h);
require "getopts.pl";
&Getopts('o:l:h');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}


open STDOUT, ">$opt_o" or die "Can't redirect stdout to '$opt_o': $!" if $opt_o;
open LOG, ">$opt_l" or die "Can't create '$opt_l': $!" if $opt_l;
while ($ARGV = shift @ARGV) {
    unless (open (IN, $ARGV)) {
	warn "can't open input $ARGV";
	next;
    }
    print LOG "##### $named $ARGV\n" if $opt_l;
    processFile();
    close(IN);
}
close LOG if $opt_l;

####################################################################
#
#	process one file
#
####################################################################

sub processFile {

    my ($identifier, %identifiers, $atom, %atoms, @block, $line, $offset, $lookfor, $pos);
    my ($translate, $control, $inBlock, $braceCount, $evalBlock);
    @block = ();
    $inBlock = 0;
    while (<IN>) {
	$control = 0;
	if (s/\bfor\b(\s+)([A-Z_a-z]\w*)(\s*)\(/for my$1$2$3(/) {
	    $identifier = $2;
	    if (@block == 0) {
		%identifiers = ();
		$braceCount = 0;
	    }
	    $identifiers{$identifier} = "\$$identifier";
	    $inBlock = $control = 1;
	}
	if ($inBlock) {
	    %atoms = ();			# new line in an eval block
	    $offset = 0;

	    foreach $lookfor ('{', '}') {
		for ($pos = $[;
		    ($pos = index($_, $lookfor, $pos)) >= $[;
		    $pos += length $lookfor) {
		    $atoms{ $pos } = $lookfor;	# key is position of atom found
		}
	    }
	    while (/([A-Z_a-z]\w*)/g) {		# look for 'words' in this line
		$atoms{ length $` } = $1;	# key is position of 'word' found
	    }
	    foreach $pos (sort { $a <=> $b } keys %atoms) {
		$atom = $atoms{ $pos };		# process atoms in sequence
		if ($atom eq "{") {
		    $braceCount++;		# brace count at the end of this line
		    $control = 1;
		} elsif ($atom eq "}") {
		    if (--$braceCount <= 0) {
			$inBlock = 0;		# actively came out of last nested block
		    }
		    $control = 1;
		} elsif (defined($translate = $identifiers{ $atom })) {
		    substr($_, $pos + $offset, length $atom) = $translate;
		    $offset += length($translate) - length($atom);
		}
	    }
	    s/\[/\@{[/g;
	    s/\]/]}/g;
	    unless ($control) {
		s/"/\\"/g;
		chomp;
		$_ = "print \"$_\\n\";\n";	# output all lines in the for loop
	    }
	    push(@block, $_);			# push the modified line for eval
	    unless ($inBlock) {
		print LOG "### evaL BLOCK @{[++$evalBlock]} at LINE $.\n", @block if $opt_l;
		eval "@block";
		die if $@;
		@block = ();			# end of this eval block
	    }
	} else {
	    if (/[\[\]]/) {
		s/\[/\@{[/g;
		s/\]/]}/g;
		s/"/\\"/g;
		chomp;
		$_ = "print \"$_\\n\";\n";
		print LOG "### evaL LINE $.\n", $_ if $opt_l;
		eval;				# evaluate constant expr eg. [4*8]
		die if $@;
	    } else {
		print;				# faster if direct print
	    }
	}
    }
} # processFile
