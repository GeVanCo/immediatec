#!/usr/bin/perl

#################################################################
#
#	Copyright (C) 2000-2005  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	immac
#
#   Pre-compiler to convert "immediate C" source files containing arrays
#   int straight "immediate C".
#
#   The immediate C language extension is as follows:
#
#	immediate array variables are defined by appending an expression
#	enclosed in square brackets to the array name eg. array[i+10]
#
#	unless the expression in the square brackets is a constant
#	expression eg. array[4+10]
#	the line containing the expression must be contained in a for block
#	as follows:
#
#	for i (0 .. 31) {
#	    array[i+10];
#	}
#	Only the control variable 'i' in this instance may be used in the
#	index expressions on the block. These for blocks may be nested.
#	In that case all the control variables in each nested block may
#	be used.
#
#	Since this pre-processor only manipulates text, and does not compile,
#	there are some restrictions. The for line with or without the following
#	opening brace and the braces must be on seperate lines. These are not
#	part of the immediate C code itself. The lines are called control lines.
#	Control lines may terminate with a C /* ... */ or C++ // comment.
#	(They may in fact terminate with a Perl # comment). But a C comment
#	in a control line must be completed on the line on which it starts.
#	(C++ or Perl comments terminate on the one line anyway).

#	Other immediate C lines in the block may contain bracketed index
#	expressions, but they don't need to.
#
#	All the immediate C lines are repeated a number of times controlled
#	by the for block control line.
#		A 'perlish' syntax rather than a 'C' syntax was chosen
#		deliberately, because the pre-compiler eval's a slightly
#		modified form of the code in Perl. This syntax is very
#		simple and fits the limitations of expanding an array.
#
#   The strategy is to match lines starting with the regex
#
#	for identifier ( ... )	#    identifier matches /[A-Z_a-z]/w*/
#
#   if it does not match substitite '[' by '@{[' and ']' by ']}'
#   and print line
#
#   else
#
#   Substitute identifier by my $identifier
#   Store $identifier in hash %identifiers
#
#   Next a block inside matching braces is looked for in the current
#   line and any following lines until the final closing brace is found
#   All of this is stored in the string $block
#
#   All occurrences of any identifier from %identifiers in [ ] in that block
#   is replaced by @{[$identifier ... ]} - even inside C or C++ comments
#   Any line not starting with 'for' is replaced by 'print "line"'
#   else do same as above for nested for's
#
#   eval $block;	# which is a string evaluation
#   die if $@;		# fail on error
#
#   since use integer pragma is used, the following is valid:
#
#   for n (0 .. 25) {
#       QX[n/8].[n%8] = IB[n];\n"
#   }
#
#   generates
#
#   for my $n (0 .. 25) {
#       print "    QX@{[$n/8]}.@{[$n%8]} = IB@{[$n]};\n"
#   }
#
#################################################################

use strict;
use integer;			# allows QX[n/8].[n%8]

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
format STDERR =
Usage:	@<<<<<<< [-ph][ -o out_file][ -l log_file] in_file ...
	$named
	-o out	produce iC out_file (default: stdout)
	-l log	produce log_file, usually 'immarc.log'
	-p	allow perl type loop 'for id (0 .. 31)'
	-h	help, ouput this Usage text only
	in_file	input iC file(s) with arrays and for ()
$Id: immac,v 1.9 2008/06/10 15:24:56 wulff Exp $
.

use vars qw($opt_o $opt_l $opt_p $opt_h);
require "getopts.pl";
&Getopts('o:l:ph');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}


open STDOUT, ">$opt_o" or die "Can't redirect stdout to '$opt_o': $!" if $opt_o;
open LOG, ">$opt_l" or die "Can't create '$opt_l': $!" if $opt_l;
while ($ARGV = shift @ARGV) {
    unless (open (IN, $ARGV)) {
	warn "can't open input $ARGV";
	next;
    }
    print LOG "##### $named $ARGV\n" if $opt_l;
    processFile();
    close(IN);
}
close LOG if $opt_l;

####################################################################
#
#	process one file
#
####################################################################

sub processFile {

    my ($identifier, %identifiers, $atom, %atoms, @block, $line, $offset, $lookfor, $pos);
    my ($translate, $control, $inBlock, $braceCount, $evalBlock, %defs);
    %defs = ();
    @block = ();
    $inBlock = 0;
    while (<IN>) {
	$control = 0;
	if (s/^\s*\bfor\b\s*\(\s*(\bint\b\s+)?([A-Z_a-z]\w*)\s*=/for (my $2 =/
	    or $opt_p and			# perl type for id ( ... ) loop control
	    s/^\s*\bfor\b(\s+)([A-Z_a-z]\w*)\s*\(/for my $2 (/
	   ) {
	    $identifier = $2;
	    if (@block == 0) {
		%identifiers = ();
		$braceCount = 0;
	    }
	    if ($braceCount < $inBlock) {
		warn "### WARNING: 'for (...)' not nested after previous '{' at '$ARGV' line $.\n";
		print LOG "### WARNING: 'for (...)' not nested after previous '{' at LINE $.\n", @block if $opt_l;
	    }
	    $identifiers{ $identifier } = "\$$identifier";
	    $inBlock++;
	    $control = 1;
	} elsif (/^\s*#\s*\bdefine\b\s+([A-Z_a-z]\w*)\s+(\S.*)$/) {
	    $identifier = $1;
	    $translate  = $2;
	    $translate =~ s!(\s*/[*/].*|\s+)$!!;# delete C or C++ comment and traling blanks
	    $defs{ $identifier } = $translate;	# process macro eg #define X (4 * 8)
	    print LOG "### $_" if $opt_l;
	    next;				# do not output #define line
	}
	if (keys %defs) {			# resolve #define macros if any
	    $offset = 0;
	    while (/([A-Z_a-z]\w*)/g) {		# look for 'words' in this line
		$atom = $1;			# 'word' found
		$pos  = length $`;		# position of 'word' found
		if (defined($translate = $defs{ $atom })) {
		    print LOG "### OLD '$atom' '$translate' in $.: $_" if $opt_l and $offset++ == 0;
		    substr($_, $pos, length $atom) = $translate;
		    print LOG "### SUB '$atom' '$translate' in $.: $_" if $opt_l;
		}
	    }
	}
	if ($inBlock) {
	    %atoms = ();			# new line in an eval block
	    $offset = 0;

	    foreach $lookfor ('{', '}') {
		for ($pos = $[;
		    ($pos = index($_, $lookfor, $pos)) >= $[;
		    $pos += length $lookfor) {
		    $atoms{ $pos } = $lookfor;	# key is position of atom found
		}
	    }
	    while (/([A-Z_a-z]\w*)/g) {		# look for 'words' in this line
		$atoms{ length $` } = $1;	# key is position of 'word' found
	    }
	    foreach $pos (sort { $a <=> $b } keys %atoms) {
		$atom = $atoms{ $pos };		# process atoms in sequence
		if ($atom eq "{") {
		    $braceCount++;		# brace count at the end of this line
		    $control++;
		    $control = 1;
		} elsif ($atom eq "}") {
		    $inBlock--;			# for control block finishes with brace
		    if (--$braceCount <= 0) {
			$inBlock = 0;		# actively came out of last nested block
		    }
		    $control--;
		    $control = 1;
		} elsif (defined($translate = $identifiers{ $atom })) {
		    substr($_, $pos + $offset, length $atom) = $translate;
		    $offset += length($translate) - length($atom);
		}
	    }
	    if (/[\[\]]/) {
		s/\[/\@{[/g;			# executable interpolated index expressions
		s/\]/]}/g;			# in control and immediate C lines
	    }
	    if ($control) {
		s!/[*/]!##!;			# substitute C or C++ comment by Perl comment
	    } else {
		if ($braceCount < $inBlock) {
		    warn "### WARNING: '{' must follow 'for (...)' at '$ARGV' line $.\n";
		    print LOG "### WARNING: '{' must follow 'for (...)' at LINE $.\n", @block if $opt_l;
		}
		s/"/\\"/g;			# protect interpolated " in string
		chomp;
		$_ = "print \"$_\\n\";\n";	# print lines in the for loop when eval'd
	    }
	    push(@block, $_);			# push the modified line for eval
	    if (not $inBlock) {
		print LOG "### evaL BLOCK @{[++$evalBlock]} at LINE $.\n", @block if $opt_l;
		eval "@block";
		die if $@;
		@block = ();			# end of this eval block
	    }
	} elsif (/[\[\]]/) {
	    s/\[/\@{[/g;			# executable interpolated index expressions
	    s/\]/]}/g;				# outside of a control block
	    s/"/\\"/g;				# protect interpolated " in string
	    chomp;
	    $_ = "print \"$_\\n\";\n";
	    print LOG "### evaL LINE $.\n", $_ if $opt_l;
	    eval;				# evaluate constant expr eg. [4*8]
	    die if $@;
	} else {
	    print;				# faster if direct print
	}
    }
} # processFile
