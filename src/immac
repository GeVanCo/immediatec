#!/usr/bin/perl

#################################################################
#
#	Copyright (C) 2000-2005  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	immac
#
#   Pre-compiler to convert "immediate C" source files containing arrays
#   int straight "immediate C".
#
#   The immediate C language extension is as follows:
#
#	immediate array variables are defined by appending an expression
#	enclosed in square brackets to the array name eg. array[i+10]
#
#	unless the expression in the square brackets is a constant
#	expression eg. array[4+10], the line containing the expression
#	must be contained in a for block as follows:
#
#	for (int i; i < 32; i++) {
#	    array[i+10];
#	}
#
#	The following "perlish" syntax does the same, but is not recommended.
#
#	for i (0 .. 31) {
#	    array[i+10];
#	}

#	The only reason it is included, is to generate irregular Perl type lists,
#	which is unlikely to be an important feature.
#
#	for i (0, 3, 4, 10, 5) {
#	    array[i];
#	}
#	will generate array0 array3 array4 array10 array5
#
#	Only the control variable 'i' in the above instances may be used in the
#	index expressions of the block. These 'for' blocks may be nested.
#	In that case all the control variables in each nested block may
#	be used.
#
#	Since this pre-processor only manipulates text, and does not compile,
#	there are some restrictions. The 'for' line with or without the following
#	opening brace and the braces must be on seperate lines. These are not
#	part of the immediate C code itself. The lines are called control lines.
#	Control lines may terminate with a C /* ... */ or C++ // comment.
#	(They may in fact terminate with a Perl # comment). But a C comment
#	in a control line must be completed on the line on which it starts.
#	(C++ or Perl comments terminate on the one line anyway).

#	Other immediate C lines in the block may contain bracketed index
#	expressions, but they don't need to.
#
#	All immediate C lines in a  'for' block are repeated a number of
#	times controlled by the 'for' control line.
#		As shown above, a 'C' type control expression
#			for (int i; i < 32; i++)
#		is preferable - it fits into the general 'C' syntax of
#		'immediate C'.
#		A 'perlish' syntax rather than a 'C' syntax may be used:
#			for int i (0 .. 31) {
#		This is, because the pre-compiler eval's a slightly
#		modified form of the code in Perl. This syntax is very
#		simple and fits the limitations of expanding an array.
#
#		The 'int' type specifier of the control variable is optional - it
#		may be used in both variants to make the syntax look more correct.
#		It must be remembered, that the control variable is usually an 'int'.
#		In the Perl code, 'use integer' has been called, so integer division
#		always applies.
#
#		In the case a 'Perl' type list is used, then strings may be used:
#			for i ("AA", "BB", "CC", "DD", "EE") {
#		If these are not numeric, then no arithmetic may be done when the
#		control variable is used in an index expression:
#			    array[i];
#		will generate arrayAA arrayBB arrayCC arrayDD arrayEE
#		Note: special care must be taken, that these strings are
#		not defined as macros.
#
#   The strategy is to match lines starting with the regex
#
#	for (identifier    or	for identifier ( #    identifier matches /[A-Z_a-z]/w*/
#
#   if it does not match substitite '[' by '@{[' and ']' by ']}'
#   and print line
#
#   else
#
#   Substitute identifier by my $identifier
#   Store $identifier in hash %identifiers
#
#   Next a block inside matching braces is looked for in the current
#   line and any following lines until the final closing brace is found
#   All of this is stored in the string $block
#
#   All occurrences of any identifier from %identifiers in [ ] in that block
#   is replaced by @{[$identifier ... ]} - even inside C or C++ comments
#   Any line not starting with 'for' is replaced by 'print "line"'
#   else do same as above for nested for's
#
#   eval $block;	# which is a string evaluation
#   die if $@;		# fail on error
#
#   since use integer pragma is used, the following is valid:
#
#   for (n = 0; n < 16; n++) {
#       QX[n/8].[n%8] = IB[n];\n"
#   }
#
#   generates the following, which is eval'd
#
#   for (my $n = 0; $n < 16; $n++) {
#       print "    QX@{[$n/8]}.@{[$n%8]} = IB@{[$n]};\n"
#   }
#
#   to produce the following straight immediate C output
#
#    QX0.0 = IB0;
#    QX0.1 = IB1;
#    ...
#    QX1.7 = IB15;
#
#   which is not brilliant code, but shows the pattern.
#
#################################################################

use strict;
use integer;			# allows QX[n/8].[n%8]

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
format STDERR =
Usage:	@<<<<<<< [-h][ -o out_file][ -l log_file][ -D m=v] in_file
	$named
	-o out	produce iC out_file (default: stdout)
	-l log	produce log_file, usually 'immarc.log'
	-D m=3	define macro 'm' with value '3' (may have several)
		NOTE: command line definitions have precedence over
		      '#define m 4' in the code (opposite to cpp)
	-h	help, ouput this Usage text only
	in_file	input iC file(s) with arrays and for ()
$Id: immac,v 1.13 2008/06/19 08:53:17 wulff Exp $
.

use vars qw($opt_o $opt_l $opt_D $opt_h);
require "getopts.pl";
&Getopts('o:l:D:h');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my %defs = ();
my @def;
my $def;

open STDOUT, ">$opt_o" or die "Can't redirect stdout to '$opt_o': $!" if $opt_o;
open LOG, ">$opt_l" or die "Can't create '$opt_l': $!" if $opt_l;

my @defines = split(' ', $opt_D);
foreach (@defines) {
    @def = split(/=/, $_);
    $def = shift(@def);		# enter -D NAME(s) in associative array %defs
    $defs{ $def } = @def ? join('=', @def) : '';
    warn "### WARNING: '-D $def' has no value - should be '-D $def=value'\n" unless @def;
    print LOG "### COMMAND LINE -D $def=$defs{ $def }\n" if $opt_l;
}

while ($ARGV = shift @ARGV) {
    unless (open (IN, $ARGV)) {
	warn "can't open input $ARGV";
	next;
    }
    print LOG "##### $named $ARGV\n" if $opt_l;
    processFile();
    close(IN);
}
close LOG if $opt_l;

####################################################################
#
#	process one file
#
####################################################################

sub processFile {

    my ($identifier, %identifiers, $atom, %atoms, @block, $line, $offset, $lookfor, $pos);
    my ($translate, $control, $inBlock, $braceCount, $evalBlock);
    @block = ();
    $inBlock = 0;
    while (<IN>) {
	$control = 0;
	if (keys %defs) {			# resolve #define macros if any
	    $offset = 0;
	    while (/([A-Z_a-z]\w*)/g) {		# look for 'words' in this line
		$atom = $1;			# 'word' found
		$pos  = length $`;		# position of 'word' found
		if (defined($translate = $defs{ $atom })) {
		    print LOG "### OLD '$atom' '$translate' in $.: $_" if $opt_l and $offset++ == 0;
		    substr($_, $pos, length $atom) = $translate;
		    print LOG "### SUB '$atom' '$translate' in $.: $_" if $opt_l;
		}
	    }
	}
	if (s/^\s*\bfor\b\s*\(\s*(\bint\b\s+)?([A-Z_a-z]\w*)\s*=/for (my $2 =/
	    or s/^\s*\bfor\b\s+(\bint\b\s+)?([A-Z_a-z]\w*)\s*\(/for my $2 (/	# perlish for i (...)
	   ) {
	    $identifier = $2;
	    if (@block == 0) {
		%identifiers = ();
		$braceCount = 0;
	    }
	    if ($braceCount < $inBlock) {
		warn "### WARNING: 'for (...)' not nested after previous '{' at '$ARGV' line $.\n";
		print LOG "### WARNING: 'for (...)' not nested after previous '{' at LINE $.\n", @block if $opt_l;
	    }
	    $identifiers{ $identifier } = "\$$identifier";
	    $inBlock++;
	    $control = 1;
	} elsif (/^\s*#\s*\bdefine\b\s+(\S+)\s+(\S.*)$/) {
	    $identifier = $1;
	    $translate  = $2;
	    print LOG "### $_" if $opt_l;
	    if (/[A-Z_a-z]\w*/) {
		if (defined $defs{ $identifier }) {
		    print LOG "### command line definition '$identifier=$defs{ $identifier }' has precedence over #define\n" if $opt_l;
		} else {
		    $translate =~ s!(\s*/[*/].*|\s+)$!!;	# delete C or C++ comment and trailing blanks
		    $defs{ $identifier } = $translate;	# macro to %defs eg #define X (4 * 8)
		}
	    }
	    next;				# do not output #define line
	}
	if ($inBlock) {
	    %atoms = ();			# new line in an eval block
	    $offset = 0;

	    foreach $lookfor ('{', '}') {
		for ($pos = $[;
		    ($pos = index($_, $lookfor, $pos)) >= $[;
		    $pos += length $lookfor) {
		    $atoms{ $pos } = $lookfor;	# key is position of atom found
		}
	    }
	    while (/([A-Z_a-z]\w*)/g) {		# look for 'words' in this line
		$atoms{ length $` } = $1;	# key is position of 'word' found
	    }
	    foreach $pos (sort { $a <=> $b } keys %atoms) {
		$atom = $atoms{ $pos };		# process atoms in sequence
		if ($atom eq "{") {
		    $braceCount++;		# brace count at the end of this line
		    $control++;
		    $control = 1;
		} elsif ($atom eq "}") {
		    $inBlock--;			# for control block finishes with brace
		    if (--$braceCount <= 0) {
			$inBlock = 0;		# actively came out of last nested block
		    }
		    $control--;
		    $control = 1;
		} elsif (defined($translate = $identifiers{ $atom })) {
		    substr($_, $pos + $offset, length $atom) = $translate;
		    $offset += length($translate) - length($atom);
		}
	    }
	    if (/[\[\]]/) {
		s/\[/\@{[/g;			# executable interpolated index expressions
		s/\]/]}/g;			# in control and immediate C lines
	    }
	    if ($control) {
		s!(\s*(/[*/]|#).*|[ \t]+)$!!;	# delete C, C++ of Perl comment and traling blanks
		while (/([A-Z_a-z\$]\w*)/g) {	# look for 'words' in this line
		    $atom = $1;
		    if ($atom ne 'for' and $atom ne 'my' and $atom !~ /^\$/) {
			warn "### WARNING: Bareword '$atom' (unresolved macro) at '$ARGV' line $.\n";
		    }
		}
	    } else {
		if ($braceCount < $inBlock) {
		    warn "### WARNING: '{' must follow 'for (...)' at '$ARGV' line $.\n";
		    print LOG "### WARNING: '{' must follow 'for (...)' at LINE $.\n", @block if $opt_l;
		}
		s/"/\\"/g;			# protect interpolated " in string
		chomp;
		$_ = "print \"$_\\n\";\n";	# print lines in the for loop when eval'd
	    }
	    push(@block, $_);			# push the modified line for eval
	    if (not $inBlock) {
		print LOG "### evaL BLOCK @{[++$evalBlock]} at LINE $.\n", @block if $opt_l;
		eval "@block";
		die if $@;
		@block = ();			# end of this eval block
	    }
	} elsif (/[\[\]]/) {
	    s/\[/\@{[/g;			# executable interpolated index expressions
	    s/\]/]}/g;				# outside of a control block
	    s/"/\\"/g;				# protect interpolated " in string
	    chomp;
	    $_ = "print \"$_\\n\";\n";
	    print LOG "### evaL LINE $.\n", $_ if $opt_l;
	    eval;				# evaluate constant expr eg. [4*8]
	    die if $@;
	} else {
	    print;				# faster if direct print
	}
    }
} # processFile
