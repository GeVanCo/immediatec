#!/usr/bin/perl

#################################################################
#
#	Copyright (C) 2000-2013  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	vcd2sav
#
#   Scan a VCD file produced by an iC 'application -v application.vcd'
#   and output a more detailed SAV file than the original SAV produced.
#   The original SAV files only shows variables in the iC source and
#   not secondary or auxiliary variables generated by the immcc compiler
#   and shown in the LST file. These are in the VCD file in modules
#   with the name of the base name of these auxiliary variables. From
#   there they can be manually selected in GTKWave via the module tree.
#
#   To produce a SAV file with all auxiliary variables use the -a option.
#
#   To only include variables which match a certain regex use -R <regex>
#       default is -R<.*> (still use -a for all auxiliaries).
#       The regex may name a number of alternatives like (ant|bee|wasp)
#	which selects names with those strings anywhere. To select full
#	names use '^(ant|bee|wasp)$' or leave out the dollar to specify
#       starting strings, which is probably the most useful.
#   To suppress variables which match a certain regex use -S <regex>
#       default is not to suppress any.
#	eg: -S '^[IQT]' to supress all I/O names (not a good idea).
#
#   If only one VCD file is scanned the output SAV file must be named
#   with the -o <sav_file> option or it is output to STDOUT. This provides
#   for better control of SAV file names with different options.
#
#   If more than one VCD file is scanned the output SAV will be named
#   xxx_.sav for each input file xxx.vcd. (The original SAV file was xxx.sav)
#
#################################################################

use strict;

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
format STDERR =
Usage:
@<<<<<< [-aAh][ -o <sav_file>][ -R <regex>][ -S <regex>] <vcd_file> ...
        $named
        -o<sav> produce new <sav> file (default: stdout)
        -a      include all auxiliary variables
        -A      include immC array variables (default: suppress)
        -R<reg> include variables matching <reg> (default: all except)
        -S<reg> suppress variables matching <reg> (default: none)
        -i<var> invert <var> (or give it another property <var>=xx)
                standard properties @xx are 28 for wire or event
				'@'
                24 for integer and 68 for inverted wire
        -i<sav> alternatively scan named <sav> file for properties
                alternatively scan xxx.sav for VCD file xxx.vcd
                for properties (best option - do nothing)
        -h      help, ouput this Usage text only
$Id: vcd2sav,v 1.1 2013/03/03 11:54:38 jw Exp $
.

use vars qw($opt_o $opt_a $opt_A $opt_R $opt_S $opt_h);
my %opt_i = ();
my %props = ();
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    'o=s' => \$opt_o,
    'a'   => \$opt_a,
    'A'   => \$opt_A,
    'R=s' => \$opt_R,
    'S=s' => \$opt_S,
    'i:s' => \%opt_i,
    'h'   => \$opt_h);

if ($opt_h) {
    write STDERR; exit 0;		# -h, ouput Usage only
}

my $nARGV = scalar @ARGV;
die "*** ERROR: $named: no VCD file to process ???\n" unless $nARGV;

if (scalar %opt_i) {
    for my $key (sort keys %opt_i) {
	my $v;
	if (-f $key and $key =~ m/\.sav$/) {
	    scan_old_sav($key);
	} else {
	    $props{$key} = ($v = $opt_i{$key}) ? $v : "68";
	    $props{$key} =~ s/^@//;	# allows entry -i <variable_name>=@55
	    if (not $key or $props{$key} !~ m/^\d\d$/) {
		warn "*** WARNING: $named: illegal property option -i '$key=$props{$key}' - must be 2 digit number\n";
	    }
	}
    }
} else {
    my $sav = $ARGV[0];
    if ($sav =~ s/\.vcd/.sav/ and -f $sav) {
	scan_old_sav($sav);
    } else {
	warn "*** WARNING: $named: VCD file '$ARGV[0]' does not have .vcd extension or no matching .sav - proceed without getting properties\n";
    }
}

$opt_R = '.*'       unless $opt_R;
$opt_S = '^iClock$' unless $opt_S;	# iClock is already excluded

my $state = 0;				# global

if ($opt_o) {
    if ($nARGV == 1) {
	open STDOUT, ">$opt_o" or die "*** ERROR: $named: can't redirect stdout to '$opt_o': $!";
    } else {
	warn "*** WARNING: $named: -o '$opt_o' will be be renamed automatically because of $nARGV VCD files\n";
    }
}
while ($ARGV = shift @ARGV) {
    unless (open (IN, $ARGV)) {
	warn "*** WARNING: $named: can't open input $ARGV";
	next;
    }
    if ($nARGV > 1) {
	my $out = $ARGV;
	if ($out =~ s/\.vcd/_.sav/) {	# outfile xxx_.sav for xxx.vcd if multiple VCD files
	    open STDOUT, ">$out" or die "*** ERROR: $named: can't redirect stdout to '$out': $!";
	} else {
	    warn "*** WARNING: $named: automatic renaming requires extension .vcd on input files\n";
	}
    }
    processFile();
    close(IN);
}

####################################################################
#
#	process one file
#
####################################################################

sub processFile {
    my $module1  = '';
    my $module2  = '';
    my $prop     = '';
    my $propPrev = '';
    my ($date, $version, $var, $n, $v);
  Line:
    while (<IN>) {
	chomp;
	$var     = '';
	if (/^\$var /) {
	    if (/(wire|event) /) {
		if (/1 \d+ (\w+) \$end$/) {
		    $var = $n = $1;
		    $prop = ($v = $props{$n}) ? "\@$v" : "\@28";	# inverted ALIAS in %props
		} elsif (/1 \d+ (\w+\.[0-7]) \$end$/) {
		    $var = "\\$1";		# IX0.0 QX0.1 TX0.2
		    $n    = $1;
		    $prop = ($v = $props{$n}) ? "\@$v" : "\@28";
		} elsif (/1 \d+ (\w+\[\d+\]) \$end$/) {
		    if ($opt_A) {
			$var = $n = $1;		# sel[0] sel[1]
			$prop = ($v = $props{$n}) ? "\@$v" : "\@28";
		    }
		}
	    } elsif (/integer (\d+) \d+ (\w+) \$end$/) {
		$var = $n = "$2\[@{[$1-1]}:0\]";
		$prop = ($v = $props{$n}) ? "\@$v" : "\@24";		# may be named in %props
	    } else {
		warn "*** WARNING: $named: bad variable: $_\n";
	    }
	    if ($var eq "iClock" or $n !~ /$opt_R/o or $n =~ /$opt_S/o) {
		$var = '';			# iClock is output at start of list
	    }
	}
	if ($state == 0) {
	    if (/^\$date$/) {
		$date = '';
		next Line;
	    } elsif (defined $date and $date eq '') {
		$_ =~ s/\s*//;
		$date = $_;
	    } elsif (/^\$version$/) {
		$version = '';
		next Line;
	    } elsif (defined $version and $version eq '') {
		$_ =~ s/\s*//;
		$version = $_;
		$state = 1;
	    }
	} elsif ($state == 1) {
	    if (/^\$scope module (\w+) \$end$/) {
		die "*** ERROR: $named: $ARGV: 2nd base module definition - malformed iC VCD file\n" if $module1;
		$module1 = "$1";
		print "[*]\n";
		print "[*] $version\n";
		print "[*] $date\n";
		print "[*]\n";
		print "[dumpfile] \"$module1\"\n";
		print "[size] 1024 700\n";
		print "[pos] -1 -1\n";
		print "*-4.343955 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n";
		$propPrev = $prop = "\@28";
		print "$prop\n";
		print "$module1.iClock\n";
		$state = 2;
	    } elsif (/^\$enddefinitions \$end$/) {
		$state = 0;
		last;		# one input file completed - follow on files append
	    }
	} elsif ($state == 2) {
	    if (/^\$scope module (\w+) \$end$/) {
		$module2 = "$1";
		$state = 3;
	    } elsif (/^\$upscope \$end$/) {
		$state = 1;
	    } elsif ($var) {
		if ($prop ne $propPrev) {
		    print "$prop\n";
		    $propPrev = $prop;
		}
		print "$module1.$var\n";
	    }
	} elsif ($state == 3) {
	    if (/^\$scope module (\w+) \$end/) {
		die "*** ERROR: $named: $ARGV: 3rd level module definition '$module1.$module2.$1' - malformed iC VCD file\n";
	    } elsif (/^\$upscope \$end$/) {
		$module2 = '';
		$state = 2;
	    } elsif ($var and $opt_a) {
		if ($prop ne $propPrev) {
		    print "$prop\n";
		    $propPrev = $prop;
		}
		print "$module1.$module2.$var\n";
	    }
	}
    }
    warn "*** WARNING: $named: $ARGV: no module definiton - malformed iC VCD file\n" unless $module1;
    warn "*** WARNING: $named: $ARGV: variable definitions not terminated correctly with '\$enddefinitions \$end'\n" unless $state == 0;
} # processFile

########################################################################
#
#	Get non standard inversion properties from an original SAV file
#	Standard properties are @28 for wire or event and @28 for integer
#	Inverted aliases need inversion whose property is @68 and which is
#	used if the option is just -i <variable_name>
#	Other properties can be entered with -i <variable_name>=55
#
########################################################################

sub scan_old_sav {
    my ($sav) = @_;
    my $property = '';
    if (open(SAV, $sav)) {
	while (<SAV>) {
	    chomp;
	    if (/^@(\d+)$/) {
		if ($_ eq "\@24" or $_ eq "\@28") {
		    $property = '';
		} else {
		    $property = $1;
		}
	    } elsif ($property) {
		if (/\w+\.\\?([\w.]+)/) {	# may be followed by [\d+:\d+]
		    $props{$1} = $property;	# add to properties in %props
		} else {
		    warn "*** WARNING: $named: bad line '$_' in inversion SAV file $sav";
		}
	    }
	}
	close(SAV);
    } else {
	warn "*** WARNING: $named: can't open inversion SAV file $sav";
    }
} # scan_old_sav
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

vcd2sav - iCa converter to change single braces in FOR control lines

=head1 SYNOPSIS

 vcd2sav [-aAh][ -o <sav_file>][ -R <regex>][ -S <regex>] <vcd_file> ...
        -o<sav> produce new <sav> file (default: stdout)
        -a      include all auxiliary variables
        -A      include immC array variables (default: suppress)
        -R<reg> include variables matching <reg> (default: all except)
        -S<reg> suppress variables matching <reg> (default: none)
        -i<var> invert <var> (or give it another property <var>=xx)
                standard properties @xx are 28 for wire or event
                24 for integer and 68 for inverted wire
        -i<sav> alternatively scan previous <sav> file for properies
        -h      help, ouput this Usage text only

=head1 DESCRIPTION

B<vcd2sav> scans VCD files produced by iC 'applications  run with
the '-v application.vcd' and outputs a more detailed SAV file than
the original SAV file produced.  The original SAV files only show
variables in the iC source and no secondary or auxiliary variables
generated by the immcc compiler and shown in the LST file. These
are in the VCD file in sub-modules with the name of the base name of
these auxiliary variables. From there they can be manually selected
in GTKWave via the module tree.

 To produce a SAV file with all auxiliary variables use the -a option.

 To include immC array variables eg sel[0] sel[1] ... use the -A option.
    This is not very useful, since their aliases sel0 sel1 ... are
    already included.

 To only include variables which match a certain regex use -R <regex>
    default is -R<.*> to selact all (still use -a for all auxiliaries).
    The regex may name a number of alternatives like (ant|bee|wasp)
    which selects names with those strings anywhere. To select full
    names use '^(ant|bee|wasp)$' or leave out the dollar to specify
    starting strings, which is probably the most useful.

 To suppress variables which match a certain regex use -S <regex>
    default is not to suppress any.
    eg: -S '^[IQT]' to supress all I/O names (not a good idea).

If only one VCD file is scanned the output SAV file must be named
with the -o <sav_file> option or it is output to STDOUT. This provides
for better control of SAV file names with different options.

If more than one VCD file is scanned the output SAV will be named
xxx_.sav for each input file xxx.vcd. (The original SAV file was xxx.sav)

 To get non standard inversion properties from an original SAV file
    use -i xxx.sav, for xxx.vcd (this is the original SAV file produced)

 Standard properties are @28 for wire or event and @28 for integer
 Inverted aliases need inversion whose property is @68 and which is
 used if the option is just -i <variable_name>
 Other properties can be entered with -i <variable_name>=55

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<vcd2sav> in the
subject field.

=head1 SEE ALSO

L<gtkwave(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2013  John E. Wulff

You may distribute this program under the terms of the GNU General
Public License

=cut

############ end of POD to generate man page ###########################
