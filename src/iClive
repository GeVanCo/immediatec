#!/usr/bin/perl -P

########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	LiveList for iC programs and listings
#
#	LiveList provides an edit window in which the text of a program
#	or listing can be displayed and optionally edited and saved.
#
#	LiveList is normally a client of a running iC program. On startup
#	it requests the symbol table of the running program. It returns
#	a list of words from the symbol table on which it wants live
#	updates of the state of the nodes, named by each word in the
#	list. The running program then provides updates when the state
#	of any node from the list changes as soon as possible after the
#	change.
#
#	All words in the text which exactly match any token in the list
#	are marked with a colour depending on the current state of the
#	node - usually green for 0 and red for 1. These are called 'active'
#	words. Active words in the list which are preceded by ~ or ! or
#	which are followed by ~ show the inverse state of the node.
#
#	When the mouse cursor sits on an active word the value of the
#	node is displayed in a subwindow. This is useful for displaying
#	the current value of arithmetic nodes.
#
#	To be effective, the displayed text must be either the source of
#	the running iC program or a text derived from that source, such
#	as the iC listing. The LiveList then shows the logical statements
#	of the source and the colours will show what the current state
#	is. It is then easy to inspect the listing and relate states with
#	the logic.
#
#	For measuring reaction times the Module Time::HiRes may be used.
#	This activates the -m option.
#	Make sure you have downloaded and installed Time::HiRes from CPAN
#	Uncomment the C++ comment in the next line
#define TIME_HIRES
#
########################################################################

use Tk;					# Slurp the module in
use Msg;
use strict;

#  live colouring     false 0          true 1
my @tagArithmetic = ('LightSkyBlue1', 'LightSkyBlue1',);
my @tagBackground = ('PaleGreen1'   , 'yellow'       ,);
my @tagForeground = ('black'        , 'red'          ,);

my $is_logic = 0;             # 1 if check-button on
my $info = '';
my $filename = '';

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
@<<<<<<< [-tmh] [-s <host>] [-p <port>] [-f <font>] [file ...]
	$named
	-s host	host name of server    (default 'localhost')
	-p port	service port of server (default '8778')
	-f font	font to use in Text window (default '9x15')
	-t	trace debug messages
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-h	help, ouput this Usage text only
Copyright (C) 2000-2001  John E. Wulff		<john.wulff@inka.de>
							  '@'
$Id: iClive,v 1.5 2001/03/29 11:16:15 jw Exp $
.

use vars qw($opt_t $opt_m $opt_s $opt_p $opt_f $opt_h);
require "getopts.pl";
&Getopts('tms:p:f:h');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
#ifdef TIME_HIRES 

my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
    $t0 = [gettimeofday];	# start of program
}
#endif

########################################################################
#
#	Connect to server
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $font = defined $opt_f ? $opt_f : '9x15';
my $unitID = 'L0';
my %symbolTable = ();	# $symbolTable{$symbol}     = [$ftype, $index]
my @activeSymbols;	# $activeSymbols[$index][0] = $ftype if active (never 0)
			# $activeSymbols[$index][1] = $ftype if inverse active
my $recvIndex = 0;

my ($normal, $inverse);
$normal = "0";
$inverse = "0~";

my $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
if ($conn) {
    print "Connection $unitID at client.\n";
    $conn->send_now($unitID);	# register I/O
    $conn->send_now("$unitID.1");	# request Symbol Table
} else {
    print "$named could not connect to $host:$port\nEdit only - no live listing\n";
}

$filename = $ARGV[0] unless @ARGV < 1;

########################################################################
#
#	Create main window and menus
#
########################################################################

my $mainWindow = MainWindow->new();
$mainWindow->title("iC LiveList");

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack('-side' => 'top', '-fill' => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton('-text' => 'File',
				    '-relief' => 'raised',
				    '-borderwidth' => 2,
				   )->pack('-side' => 'left',
					   '-padx' => 2,
					  );
$menuFile->command('-label' => 'New',  '-command' => \&new_text);
$menuFile->command('-label' => 'Load', '-command' => \&load_file);
$menuFile->command('-label' => 'Save', '-command' => \&save_file);
$menuFile->separator();
$menuFile->command('-label' => 'Quit', '-command' => sub { exit(0); } );

########################################################################
#	Scan Menu
########################################################################
my $menuScan = $menuBar->Button('-text'        => 'Scan',
				    '-relief'      => 'raised',
				    '-borderwidth' => 2,
				    '-command'     => \&scan,
				   )->pack('-side' => 'left',
					   '-padx' => 2,
					  );

########################################################################
#	Search menu 
########################################################################
my $search_mb = $menuBar->Menubutton('-text'         => 'Search',
				     '-relief'       => 'raised',
				     '-borderwidth'  => 2,
				     )->pack('-side' => 'left',
					     '-padx' => 2
					    );
my $match_type = "-regexp";
my $ignore_case = 1;
$search_mb->separator();
########################################################################
#	Regexp match
########################################################################
$search_mb->radiobutton('-label'    => 'Regexp match',
			'-value'    => '-regexp',
			'-variable' => \$match_type);
########################################################################
#	Exact match
########################################################################
$search_mb->radiobutton('-label'    => 'Exact match',
			'-value'    => '-exact',
			'-variable' => \$match_type);
$search_mb->separator();
########################################################################
#	Ignore case
########################################################################
$search_mb->checkbutton('-label'    => 'Ignore case?',
			'-variable' => \$ignore_case);
$search_mb->separator();

########################################################################
#	Logic
########################################################################
$search_mb->checkbutton('-label'    => 'Logic',
			'-variable' => \$is_logic,
			'-command'  => \&logic);

########################################################################
#	Search entry
########################################################################
my $search = $menuBar->Entry('-width' => 20,
			        )->pack('-side' => 'left',
				        '-padx' => 2,
				       );
$search->bind('<KeyPress-Return>', \&search);

########################################################################
#	Info bar
########################################################################
$mainWindow->Label(-textvariable => \$info,
		   -relief => 'ridge',
		  )->pack(-side => 'bottom',
		  	  -fill => 'x',
		         );

########################################################################
#	Text window
########################################################################
my $text = $mainWindow->Scrolled('Text',
		                 -scrollbars => 'osoe',
		                 -background => 'cornsilk1',
		                 -wrap => 'none',
		                 -font => $font,
		                )->pack(-fill => 'both',
			                -expand => 1,
			               );

########################################################################
#
#	Register read events
#
########################################################################

$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); }) if $conn;

########################################################################
#
#	Open the first file in the argument list
#	Sit in an infinite loop dispatching incoming events.
#
########################################################################

load_file() if $filename;
MainLoop;

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occurr if $conn)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
#ifdef TIME_HIRES 
    printMicroSeconds() if $opt_m;
#endif
    if (defined $msg) {
	if (length $msg == 0) {
	    $rConn->disconnect();
	    print "LiveList $unitID disconnected by server\n";
	    deleteAllTags();
	    undef $conn;
	} else {
	    print "$msg\n" if $opt_t;
	    my @symbols = split /;/, $msg;		# break up message
	    my $entry = shift @symbols;		# first entry is an operation
	    if ($entry =~ /$unitID\.(\d+)/) {
		if (($entry = $1) eq '1') {
		    # Symbol table block
		    while ($entry = shift @symbols) {
			my ($symbol, $ftype) = split " ", $entry;
			print "$symbol	$ftype\n" if $opt_t;
			push @{ $symbolTable{$symbol} }, $ftype, $recvIndex++;
		    }
		} elsif ($entry eq '2') {
		    # End of symbol table
		    $recvIndex = 0;		# ready for next block
		    scan();
		} elsif ($entry eq '3') {
		    # New data values
		    while ($entry = shift @symbols) {
			my ($index, $value) = split " ", $entry;
			my $is = $value ? 1 : 0;
			my $inv = $is ^ 1;
			$activeSymbols[$index][2] = $value;	# for value display
			if ($activeSymbols[$index][0]) {
			    $text->tagConfigure("$index", 
						'-background' => $tagBackground[$is], 
						'-foreground' => $tagForeground[$is]);
#ifdef TIME_HIRES 
			    printMicroSeconds() if $opt_m;
#endif
			}
			if ($activeSymbols[$index][1]) {
			    $text->tagConfigure("$index~", 
						'-background' => $tagBackground[$inv], 
						'-foreground' => $tagForeground[$inv]);
#ifdef TIME_HIRES 
			    printMicroSeconds() if $opt_m;
#endif
			}
			print "$index	$value\n" if $opt_t;
		    }
		}
	    } else {
		print "Spurious operation '$entry' for $unitID ???\n";
	    }
	}
    }
}

########################################################################
#
#	Logic tagging
#
########################################################################

sub logic {
    my $inv_logic = $is_logic ^ 1;
#ifdef TIME_HIRES 
    printMicroSeconds() if $opt_m;
#endif
    if ($activeSymbols[0][0]) {
	$text->tagConfigure($normal, 
			    '-background' => $tagBackground[$is_logic], 
			    '-foreground' => $tagForeground[$is_logic]);
#ifdef TIME_HIRES 
	printMicroSeconds() if $opt_m;
#endif
    }
    if ($activeSymbols[0][1]) {
	$text->tagConfigure($inverse, 
			    '-background' => $tagBackground[$inv_logic], 
			    '-foreground' => $tagForeground[$inv_logic]);
#ifdef TIME_HIRES 
	printMicroSeconds() if $opt_m;
#endif
    }
    print "is_logic = $is_logic '$normal' '$inverse'\n if $opt_t";
}

########################################################################
#
#	Search for a regular expression or exact match
#
########################################################################

sub search {
    my ($search_pattern, $word, $i, $iw, $inv);
    $normal = $search->get();
    $inverse = "$normal~";
    $text->tagDelete($normal);
    $text->tagDelete($inverse);
    logic();
    $word = $normal;
    $word =~ s/\./\\./;
    $search_pattern = "\[~!\\s\]*\\b$word\\b\\s*((~ )?---)?";

    my $current = '1.0'; my $length = '0';
    while (1) {
        if ($ignore_case) {
            $current = $text->search('-count' => \$length,
                                     $match_type, 
                                     '-nocase',
                                     '--',
                                     $search_pattern,
                                     $current,
                                     'end');
        } else {
            $current = $text->search('-count' => \$length,
                                     $match_type, 
                                     '--',
                                     $search_pattern,
                                     $current,
                                     'end');
        }
        last if (!$current);
	$iw = $i = $text->get($current, "$current + $length char");
	$i =~ s/([!~\t ]*)([\w.]+)([!~\t ]*)/$1$3/;
	$word = $2;
	$inv = '';
	while ($i =~ m/[!~]/g) {
	    $inv = $inv ? '' : '~';
	}
	$word .= $inv;
	print "word: $word '$iw'\n" if $opt_t;
        $text->tagAdd($word, $current, "$current + $length char");
        $current = $text->index("$current + $length char");
    }
}

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    foreach my $symbol (keys %symbolTable) {
	my $index = $symbolTable{$symbol}[1];
	if ($activeSymbols[$index]) {
	    if ($opt_t) {
		print("$symbol");
		print(" $index")    if $activeSymbols[$index][0];
		print(" $index~")   if $activeSymbols[$index][1];
		print(" deleted\n");
	    }
	    $text->tagDelete("$index")  if $activeSymbols[$index][0];
	    $text->tagDelete("$index~") if $activeSymbols[$index][1];
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
}

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program.
#
########################################################################

sub scan {
    if ($conn) {
	my ($search_pattern, $current, $word, $i, $iw, $tag, $inv, $ftype, $index);

	deleteAllTags();
	$search_pattern = '[~!\s]*[A-Za-z][\w.]*\s*((~ )?---)?';

	$current = '1.0'; my $length = '0';
	while (1) {
	    $current = $text->search('-count' => \$length,
				     '-regexp', 
				     '--',
				     $search_pattern,
				     $current,
				     'end');
	    last if (!$current);
	    $iw = $i = $text->get($current, "$current + $length char");
	    $i =~ s/([!~\t ]*)([\w.]+)([!~\t ]*)/$1$3/;
	    if ($symbolTable{$2}) {
		($ftype, $index) = @{ $symbolTable{$2} };
		$tag = $index;
		$word = $2;			# ZZZ word is in the symbol table
		$inv = 0;
		while ($i =~ m/[!~]/g) {
		    $inv ^= 1;
		}
		$tag .= '~' if $inv;
		print "$tag	$word	'$iw'\n" if $opt_t;
		unless ($activeSymbols[$index][$inv]) {
		    $activeSymbols[$index][$inv] = $ftype;	# TODO use to adjust background
		    $activeSymbols[$index][2] = 0;		# initial value
		    $text->tagConfigure($tag, 
					'-background' => $tagBackground[$inv], 
					'-foreground' => $tagForeground[$inv]);
		}
		$text->tagAdd($tag, $current, "$current + $length char");
	    }
	    $current = $text->index("$current + $length char");
	}

	####################################################################
	# send list of active symbols to iC control process
	# only the state (logic or arithmetic) for the symbols in this list
	# need to be updated for this display
	# it is immaterial for the control program in which logic
	# sense the symbol is displayed
	####################################################################

	my $msg = "";
	foreach $index (0 .. $#activeSymbols) {
	    if ($activeSymbols[$index]) {
		print "$index\n" if $opt_t;
		if (length $msg > 391) {
		    $conn->send_now("$unitID.3$msg");	# intermediate active symbols
		    $msg = "";
		}
		$msg .= ";$index";
	    }
	}
	$conn->send_now("$unitID.4$msg");		# send last active symbols
    } else {
	$info = "$unitID not connected";
    }
}

########################################################################
#
#	new_text clears the text area
#
########################################################################

sub new_text {
  $text->delete("1.0", "end");
  $info = "";
}

########################################################################
#
#	load_file checks to see what the filename is and loads it if possible
#
########################################################################

sub load_file {
    $info = "Loading file '$filename'...";
    $text->delete("1.0", "end");
    if (!open(FH, "$filename")) {
    $text->insert("end", "ERROR: Could not open $filename\n"); 
	return; 
    }
    my $length = 0;
    while (<FH>) {
	$length += length $_;
	$text->insert("end", $_);
    }
    close (FH);
    $info = "File '$filename', '$length' bytes loaded";
}

########################################################################
#
#	save_file saves the file using the filename in the entry box
#
########################################################################

sub save_file {
    $info = "Saving '$filename'...";
    open (FH, ">$filename");
    my $contents = $text->get("1.0", "end - 1 chars");
    my $length = length $contents;
    print FH $contents;
    close (FH);
    $info = "File '$filename', '$length' bytes saved";
}
#ifdef TIME_HIRES 

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    my ($sec, $usec);
    $t1 = [gettimeofday];
    $sec =  $t1->[0] - $t0->[0];
    $usec = $t1->[1] - $t0->[1];
    if ($usec < 0) {
	$sec--;
	$usec += 1000000;
    }
    if ($opt_t) {
	printf "%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
    } else {
	printf "%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
    }
    $t0 = [gettimeofday];	# $t0 = $t1;
}
#endif
