#!/usr/bin/perl -P

########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	iClive display for iC sources and listings
#
#	iClive provides an edit window in which the text of a source
#	or listing can be displayed and optionally edited and saved.
#
#	iClive is normally a client of a running iC program. On startup
#	it requests the symbol table of the running program. It returns
#	a list of words from the symbol table on which it wants live
#	updates of the state of the nodes, named by each word in the
#	list. The running program then provides updates when the state
#	of any node from the list changes as soon as possible after the
#	change.
#
#	All words in the text which exactly match any token in the list
#	are marked with a colour depending on the current state of the
#	node - usually green for 0 and red for 1. These are called 'active'
#	words. Active words in the list which are preceded by ~ or ! or
#	which are followed by ~ show the inverse state of the node.
#
#	When the mouse cursor sits on an active word the value of the
#	node is displayed in a subwindow. This is useful for displaying
#	the current value of arithmetic nodes.
#
#	To be effective, the displayed text must be either the source of
#	the running iC program or a text derived from that source, such
#	as the iC listing. iClive then shows the logical statements of
#	the source and the colours will show what the current state is.
#	It is then easy to inspect the listing and relate states with
#	the logic.
#
#	This program uses the Tk::Text widget, an extension Tk::TextUndo
#	may be used to provide an UNDO facility while editing. This
#	extension has disadvantages for the 'live display' - it is 7 times
#	slower in making arithmetic updates and it causes the window to
#	jump to the last updated text for value changes in the control
#	program. This makes the 'live display' hard to interpret. This does
#	not happen with Tk::Text. If you want to activate the UNDO facility
#	uncomment 'define' in the next line. (not recommended)
#//define TEXT_UNDO
#
#	For measuring reaction times the Module Time::HiRes is used.
#	This activates the -m option and flash display of short events.
#	Make sure you have installed Time::HiRes (provided in this distribution)
#define TIME_HIRES
#
########################################################################

use Tk;					# Slurp the module in
use Msg;
#ifdef TEXT_UNDO
use Tk::TextUndo;	# 7 times slower for live display
my $undoBinding = '                (Control-u is <<Undo>>)';
#else
my $undoBinding = '';
#endif
use Tk::Balloon;
use Tk::Dialog;
use Cwd;
use strict;
#ifdef TIME_HIRES 
use Time::HiRes qw(sleep gettimeofday tv_interval);
my $t0 = [gettimeofday];	# start of program
my %delayedColour;	# colour that should be restored after a flash
#endif

########################################################################
#
#	Colour selection for background/foreground and false/true
#	$colourSelect[ftype] must match the definitions in 'icg.h'
#	Different ftypes select the 'cs' index to select four colours.
#	The last bit of cs selects the false/true colours.
#	The ftype INV_A has an odd 'cs' which inverts the colours.
#
#	To display clocks and glitches, the foreground is flashed white
#	for 50 milliseconds. Flashing the background looks confusing.
#	Uses Tk::After. Flash 2 clocks in a row white. This happens if
#	CLOCK or TIMER has 2 slave gates which are fired together.
#	
#	the following array is indexed by gt_fni is ftype (see icg.h)
#	
#	UDFA	ARITH	GATE	RI_BIT	CH_BIT	S_SH	R_SH	D_SH
#	F_SW	S_FF	R_FF	D_FF	F_CF	F_CE	CLCK	TIMR
#	OUTW	OUTX	CLCKL	TIMRL
#	ARITH_A	GATE_A	INV_A	...	CLCKL_A	TIMRL_A
#
########################################################################

my @colourSelect  = ( 0,2,0,0,2,0,0,2,2,0,0,0,0,0,0,0,2,0,4,6, # cs[ftype] 0 - 19
		      0,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,6, # ALIAS    20 - 39
		    );

#  live colouring     false 0          true 1             cs  ftype
my @tagBackground = ('PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
							## cs|010 no change
		     'PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
		    );
my @tagForeground = ('black'        , 'red'          ,  # 0 1 GATE
		     'black'        , 'red'          ,  # 2 3 ARITH
		     'black'        , 'white'        ,  # 4 5 CLCKL
		     'black'        , 'white'        ,  # 6 7 TIMRL
							## cs|010 flash glitch
		     'white'        , 'white'        ,  # 0 1 GATE
		     'white'        , 'white'        ,  # 2 3 ARITH
		     'white'        , 'white'        ,  # 4 5 CLCKL
		     'white'        , 'white'        ,  # 6 7 TIMRL
		    );

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
@<<<<<<< [-tTmh] [-s <host>] [-p <port>] [-f <font>] [file ...]
	$named
	-s host	host name of server    (default 'localhost')
	-p port	service port of server (default '8778')
	-f font	font to use in Text window (default '9x15')
	-t	trace run time changes
	-T	trace static debug messages
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-h	help, ouput this Usage text only

Menu buttons:
    File/New	provide an empty page for editing.
    File/Open	load the file named in the menu bar window.
    File/Save	store the file previously opened if modified
    File/SaveAs store the file by the name in the menu bar window.
    File/Quit	quit the program.

    Make	make either the C file or the exutable program from the
		currently displayed iC program text.

    Run/Stop	run or stop the executable program generated from the
		currently displayed iC program text.

    Live	scan the text in the text window and generate live markings
    		for all words, which represent variables in the currently
		running program - which should be generated from the text to
		make a meaningful display. Text is 'read only' in this mode.

    Edit	clears the live markings in the text window. In this mode the
    		text may be edited with the facilities of Tk::Text, which is
		a full featured editor. The edit facilities are described in
		the Tk::Text man page in the section 'BINDINGS' near the end.
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		$undoBinding
    Search	the text in the text window. It may be scanned for an exact
		match or for a regular expression in the entry window next
		to the button. All found items will be marked. Repeating
		'Search down' or RETURN will display a section of the text
		containing found items which were previously not displayed.
		'Search up' or SHIFT-RETURN reverses the direction of scrolling.

Copyright (C) 2000-2002  John E. Wulff		<john@je-wulff.de>
						  '@'
$Id: iClive,v 1.29 2003/12/21 23:26:44 jw Exp $
.

use vars qw($opt_T $opt_t $opt_m $opt_s $opt_p $opt_f $opt_h);
require "getopts.pl";
&Getopts('tTms:p:f:h');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

########################################################################
#
#	Initialize global variables
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $font = defined $opt_f ? $opt_f :
			    $ENV{COMSPEC} ?	# defined on Windows 98 and Windows XP
				'{Lucida Console} 10 normal' :
				'9x15';		# Linux
my $unitID = 'L0';
my %symbolTable = ();	# $symbolTable{$symbol} [0, 1]   = ($ftype, $index)
my @activeSymbols;	# $activeSymbols[$index][0 .. 3] = ($ts,$val,$cs,[$sec,$usec])
my $stIndex = 0;
my $conn;

my $info = '';
my $iCname = '';	# name of connected iC control program
my $fileName = '';	# name of currently loaded file
my $searchText = '';
my $oldContents = '';
my $newName = 'unknown.ic';
my $cwd = cwd;
print "cwd = $cwd\n" if $opt_T;;

my $fileTypes = [
    ['iC Source Files',  ['.ic',  '.ih',   ], ['TEXT', ], ],
    ['iC Listing Files', ['.lst',          ], ['TEXT', ], ],
    ['C  Source Files',  ['.c',            ], ['TEXT', ], ],
    ['Text Files',       ['.txt', '.text', ],             ],
    ['All Files',        ['*',             ],             ],
];

# in scan() Tk::Text->search() does not accept a pre-compiled regex qr/.../
my $scanPattern = '[~\s]*[\w]+(\.\w+)?\s*((~ )?---|=$)?';
my $bMsg = '';
my $sMsg = '';
my @wIdx = ('', '');  # Indices surrounding the current word.
my @lIdx = ('', '');  # Same for last word.

# has to be global, 'our' not portable yet
my ($prevText, $prevMatch, @lines, $si, $sj, $siWrap, $sjWrap, $top);

########################################################################
#
#	Create main window and menus
#
#	NOTE: parameters in -command => [ ] closures are taken from the
#	      time the command was executed - not when event takes place
#
########################################################################

my $mainWindow = MainWindow->new();
$mainWindow->title("iClive");

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack(-side => 'top', -fill => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton(-text        => 'File',
				    -relief      => 'raised',
				    -borderwidth => 2,
				    -tearoff     => 1,	# tear off line 0
				   )->pack(-side => 'left',
					   -padx => 2,
					  );
$menuFile->command(-label => 'New',    -command => \&new_text);
$menuFile->command(-label => 'Open',   -command => \&open_file);
$menuFile->command(-label => 'Save',   -command => \&save_file);
$menuFile->command(-label => 'SaveAs', -command => \&saveAs_file);
$menuFile->separator();
$menuFile->command(-label => 'Quit',   -command => \&quit_program);
$menuFile->separator();
my $menuFileStart = 8;				# first dynamic entry line 8
my @currentFiles = ();
my @lastFile = ();				# save last open file

########################################################################
#	Make menu
########################################################################
my $make_mb   = $menuBar->Menubutton(-text        => 'Make',
				     -relief      => 'raised',
				     -borderwidth => 2,
				    )->pack(-side => 'left',
					    -padx => 2,
					   );
$make_mb->command(-label => 'Make executable',      -command => [ \&make_file, 0, 0 ]);
$make_mb->command(-label => 'Make unconditionally', -command => [ \&make_file, 0, 1 ]);
$make_mb->command(-label => 'Make C file only',     -command => [ \&make_file, 0, 2 ]);

########################################################################
#	Run or Stop button
########################################################################
my $runButton  = $menuBar->Button(-text        => 'Run ',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -command     => \&run_file,
			         )->pack(-side => 'left',
				         -padx => 2,
				        );
my $runFlag = 0;

########################################################################
#	Live or Edit button
########################################################################
my $scanButton = $menuBar->Button(-text        => 'Live',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -command     => \&scan,
			         )->pack(-side => 'left',
				         -padx => 2,
				        );
my $scanFlag = 0;		# text is initially cleared

########################################################################
#	Search menu 
########################################################################
my $menuSearch = $menuBar->Menubutton(-text        => 'Search',
				      -relief      => 'raised',
				      -borderwidth => 2,
				      -tearoff     => 1,	# tear off line 0
				     )->pack(-side => 'left',
					     -padx => 2,
					    );
my $matchType = "-exact";	# default, alternatives -nocase -regexp

$menuSearch->command(-label       => 'Search down',
		     -accelerator => 'RETURN',
		     -command     => [ \&search_text, 0, undef, 0 ]);
$menuSearch->command(-label       => 'Search up',
		     -accelerator => 'SHIFT-RET',
		     -command     => [ \&search_text, 0, undef, 1 ]);
$menuSearch->command(-label       => 'Clear',
		     -accelerator => 'CTRL-RET',
		     -command     => [ \&search_text, 0, '',    0 ]);
########################################################################
#	Goto line number
########################################################################
$menuSearch->radiobutton(-label    => 'Go to line',
			 -accelerator => 'ALT-RET',
			 -value    => 'g',
			 -variable => \$matchType,
			 -command  => [ \&search_text ]);
########################################################################
#	Exact match
########################################################################
$menuSearch->radiobutton(-label    => 'Exact match',
			 -value    => '-exact',
			 -variable => \$matchType,
			 -command  => [ \&search_text ]);
########################################################################
#	Ignore case
########################################################################
$menuSearch->radiobutton(-label    => 'Ignore case',
			 -value    => '-nocase',
			 -variable => \$matchType,
			 -command  => [ \&search_text ]);
########################################################################
#	Regexp match
########################################################################
$menuSearch->radiobutton(-label    => 'Regexp match',
			 -value    => '-regexp',
			 -variable => \$matchType,
			 -command  => [ \&search_text ]);
########################################################################
#	Regexp match - Ignore case
########################################################################
$menuSearch->radiobutton(-label    => 'Regexp Ignore case',
			 -value    => 'rn',
			 -variable => \$matchType,
			 -command  => [ \&search_text ]);
$menuSearch->separator();
my $menuSearchStart = 10;			    # first dynamic entry line 10
my @currentSearches = ();

########################################################################
#	Search entry
########################################################################
my $entrySearch = $menuBar->Entry(-width        => 20,
				  -textvariable => \$searchText,
				 )->pack(-side => 'left',
					 -padx => 2,
					);
$entrySearch->bind('<KeyPress-Return>',		[ \&search_text, undef, 0 ]); # search down
$entrySearch->bind('<Shift-KeyPress-Return>',	[ \&search_text, undef, 1 ]); # search up
$entrySearch->bind('<Control-KeyPress-Return>',	[ \&search_text, '',    0 ]); # clear
$entrySearch->bind('<Alt-KeyPress-Return>',	[ \&search_text, undef, 2 ]); # go to line

########################################################################
#	Ini data for file and search menu lists
########################################################################
my %iniData = (
    files	=> [
	$menuFile,		# file menu
	$menuFileStart,		# start of dynamic entries
	\@currentFiles,		# save file menu entries
	10,			# number of dynamic entries
	\&open_file,		# call back for open file
    ],
    'last open file' => [
	0,			# no menu
	0,
	\@lastFile,		# save last open file
	1,
	0,
    ],
    searches	=> [
	$menuSearch,		# search menu
	$menuSearchStart,	# start of dynamic entries
	\@currentSearches,	# save search menu entries
	10,			# number of dynamic entries
	\&search_text,		# call back for search text
    ],
);

my %matchExtensions = (
    -exact	=> '',
    -nocase	=> '	n',
    -regexp	=> '	r',
    rn		=> '	rn',
    g		=> '	g',
);
my %matchRestores = (
    e		=> '-exact',
    n		=> '-nocase',
    r		=> '-regexp',
    rn		=> 'rn',
    g		=> 'g',
);

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
				 -relief       => 'ridge',
				)->pack(-side => 'bottom',
					-fill => 'x',
				       );

########################################################################
#	Text window
########################################################################
#ifdef TEXT_UNDO
my $text = $mainWindow->Scrolled('TextUndo',
				 -scrollbars => 'osoe',
				 -background => 'cornsilk1',
				 -wrap       => 'none',
				 -font       => $font,
				)->pack(-fill   => 'both',
					-expand => 1,
				       );
$text->eventAdd('<<Undo>>' => '<Control-u>');	# extra Undo binding
#else
my $text = $mainWindow->Scrolled('Text',
				 -scrollbars => 'osoe',
				 -background => 'cornsilk1',
				 -wrap       => 'none',
				 -font       => $font,
				)->pack(-fill   => 'both',
					-expand => 1,
				       );
#endif
$text->bind('<KeyPress>', [ \&report_cursor ] );	# change in cursor position
$text->bind('<Button-1>', [ \&report_cursor ] );	# change in cursor position

########################################################################
#	Balloon widget
########################################################################
my $balloon = $mainWindow->Balloon(-state => 'balloon');
my $balloonAttached = 0;
$mainWindow->OnDestroy(sub { $balloon->destroy; });

########################################################################
#	Initialise file and search menu lists, open the first file
########################################################################

ini_program();

########################################################################
#	Connect to iCserver
########################################################################

connect_to_server();

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################

MainLoop;

########################################################################
#	Display information on the info bar
########################################################################

sub info_display {
    my ($colour, $text) = @_;
    $infoBar->configure(-foreground => $colour);
    $info = $text;
} # info_display

########################################################################
#	Report the cursor position in the info bar
########################################################################

sub report_cursor {
    my @m = $text->markNames();
    foreach (@m) {
	if (/insert/) {
	    info_display('black', $text->index($_));
	    last;
	}
    }
} # report_cursor

########################################################################
#
#	Connect to iCserver
#	Register read events
#	Register I/O at iCserver and request Symbol Table
#
########################################################################

sub connect_to_server {
    $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
    if ($conn) {
	print "Connection $unitID at client.\n";
	$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });
	$conn->send_now($unitID);	# register I/O
	%symbolTable = ();
	$conn->send_now("$unitID.1");	# request Symbol Table
    } else {
	info_display('red',
	    "Could not connect to $host:$port - no live listing - edit only");
    }
} # connect_to_server

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occurr if $conn and read events registered)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
    if (defined $msg) {
	if (length $msg == 0) {
	    $rConn->disconnect();
	    $mainWindow->title("iClive $fileName");
	    info_display('red', $iCname ?
		"$unitID disconnected from '$iCname' by server" :
		"$unitID is not connected to a control program");
	    deleteAllTags();	# also clears @activeSymbols
	    %symbolTable = ();	# clear symbol table so balloons dont show
	    undef $iCname;
	    undef $conn;
	    clearScan(1);	# detach balloon
	    ####################################################
	    ## change text on run button to "Run"
	    ####################################################
	    $runButton->configure(-text => "Run ");
	    $runFlag = 0;
	} else {
#ifdef TIME_HIRES 
	    printMicroSeconds() if $opt_m;
#endif
	    print "rcvd '$msg'\n" if $opt_t;
	    my @symbols = split /;/, $msg;	# break up message
	    my $entry = shift @symbols;		# first entry is an operation
	    if ($entry =~ /$unitID\.(\d+)/) {
		if (($entry = $1) eq '1') {
		    ####################################################
		    ## Symbol Table block
		    ## Symbol table entries consist of two or three words.
		    ## Usually symbol-id and ftype are received. In this
		    ## case the ST-offset is the index. (computed by counting)
		    ## For ALIASes the index of the Gate to which the
		    ## ALIAS resolves is transmitted as a 3rd value.
		    ## For bit I/O names IX0.0 etc, add a second entry IX0_0
		    ####################################################
		    while ($entry = shift @symbols) {
			my ($symbol, $ftype, $index) = split " ", $entry;
			$index = $stIndex unless defined $index;
			print "$index\t$symbol\t$ftype\n" if $opt_T;
			@{ $symbolTable{$symbol} } = ($ftype, $index);
			if ($symbol =~ s/^([IQT]X\d+)\.(\d+)/$1_$2/) {
			    print "$index\t$symbol\t$ftype\n" if $opt_T;
			    @{ $symbolTable{$symbol} } = ($ftype, $index);
			}
			$stIndex++;
		    }
		} elsif ($entry eq '2') {
		    ####################################################
		    ## End of Symbol Table
		    ## The 2nd entry is the name of the running iC program.
		    ## This name allows a check against the file name of
		    ## the displayed text. (Assume it should match)
		    ####################################################
		    $iCname = shift @symbols;
		    info_display('blue', "$unitID connected to '$iCname' by server");
		    ####################################################
		    ## change text on run button to "Stop"
		    ####################################################
		    $runButton->configure(-text => "Stop");
		    $runFlag = 1;		# run successful
		    $stIndex = 0;		# ready for next reception
		    scan();
		} elsif ($entry eq '3') {
		    ####################################################
		    ## New data values
		    ## Data value entries consist of ST-index and value
		    ####################################################
		    my $normalFlag = 0;		# state currently diasabled
		    while ($entry = shift @symbols) {
			my ($index, $value) = split " ", $entry;
#ifdef TIME_HIRES 
			my $tNew;
			my ($cs, $tOld) = @{ $activeSymbols[$index] }[2, 3];
			$activeSymbols[$index][3] = $tNew = [gettimeofday];
			my $tRest = 50 - int(tv_interval($tOld, $tNew) * 1000);	# ms.
# print "index: $index value: $value rest: $tRest\n";
#else
			my $cs = $activeSymbols[$index][2];
#endif
			$cs ^= 1 if $value;			# change colour
			$activeSymbols[$index][1] = $value;	# for value display
			if ($activeSymbols[$index][0] & 01) {
#ifdef TIME_HIRES 
			    if ($tRest < 10) {
				colourTag("$index", $cs);	# normal colour
			    } else {
				colourTag("$index", $cs | 010);	# flash glitch
				## delay the colour change to make it visible
				$text->after(50, [ \&restoreTag, "$index" ]);
			    }
#else
			    colourTag("$index", $cs);		# normal colour
#endif
			    if ($cs == 5 or $cs == 7) {	# hi CLOCK or TIMER
				## turn colour off after 50 ms.
				$text->after(50, [ \&colourTag, "$index", $cs & ~01 ]);
			    }
			}
			if ($activeSymbols[$index][0] & 02) {
#ifdef TIME_HIRES 
			    $cs ^= 1;				# complement colour
			    if ($tRest < 10) {
				colourTag("$index~", $cs);	# latest $cs is saved
			    } else {
				colourTag("$index~", $cs | 010);# flash glitch
				## delay the colour change to make it visible
				$text->after(50, [ \&restoreTag, "$index~" ]);
			    }
#else
			    colourTag("$index~", $cs ^ 1);	# complement colour
#endif
			}
			if ($activeSymbols[$index][0] & 04) {
			    my $tag = "$index=";
			    my @ranges = $text->tagRanges($tag);
# print "value at index $index: $activeSymbols[$index][1] '@ranges'\n";
			    unless ($normalFlag) {
				$text->configure(-state => 'normal');
				$normalFlag = 1;	# state normal until loop end
			    }
			    for (my $i = 0; $i < @ranges; $i += 2) {
				my ($beg, $end) = @ranges[$i, $i+1];
				$text->delete($beg, $end);
				$text->insert($beg, " $value", $tag);
			    }
			}
#ifdef TIME_HIRES 
			printMicroSeconds() if $opt_m;
#endif
			print "$index	$value\n" if $opt_t;
		    }
		    if ($normalFlag) {
			$text->configure(-state => 'disabled');
		    }
		} else {
		    goto Spurious;
		}
	    } else {
		Spurious: warn "$unitID: spurious operation '$entry' ???\n";
	    }
#ifdef TIME_HIRES 
	    printMicroSeconds() if $opt_m;
#endif
	    print "rcvd end\n" if $opt_t;
	}
    }
} # rcvd_msg_from_server

########################################################################
#
#	Change the tag colours
#
########################################################################

sub colourTag {
    my ($tag, $cs) = @_;
# print "colourTag: $tag $cs\n";
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
#ifdef TIME_HIRES 
    $delayedColour{$tag} = $cs;		# save colour for end of flash
} # colourTag

########################################################################
#
#	Restore the tag colour after a flash
#
#	If the value in %delayedColour were not used, another change
#	before the 50 ms flash is finished may come in and the end of
#	flash will then restore to the second last change. Now the
#	colour is saved in &colourTag and the end of the flash will
#	restore the very latest change.
#
########################################################################

sub restoreTag {
    my ($tag) = @_;
    my $cs = $delayedColour{$tag} & 07;	# latest colour ignoring flash
# print "restoreTag: $tag $cs\n";
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
#endif
} # restoreTag

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from bind('<Return>', [ \&search_text, 1 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy first parameter when called directly
#
#		parameter 1:	(dummy)
#		parameter 2:	newSearchText
#		    "		undef	use $searchText from Entry widget
#		    "		''	clear the search
#		parameter 3:	0  Search down	(default)
#		    "		1  Search up
#		    "		2  Go to line
#
#	search_text() is mostly called from a pop up, which does not close,
#	until search_text() has completed execution. If the search action
#	involves scrolling, the text covered by the pop up before scrolling
#	and not covered after scrolling is left blank.
#
#	To fix this, postpone the search and scrolling action until after
#	search_text() has completed execution, by posting the callback
#	search_now(). No actual delay is necessary.
#
########################################################################

sub search_text {
    $text->after(0, [ \&search_now, @_ ]); # allow pop up to go away
} # search_text

sub search_now {
    my ($dummy, $newSearchText, $direction) = @_;
    my ($option, $auxiliary, $current, $length, $i, $tmpText);
    if (defined $newSearchText) {
	($searchText, $option) = split(/\t/, $newSearchText);
	$matchType = $option ? $matchRestores{$option} : '-exact';
    }
    if ($direction == 2 or $matchType eq 'g') {
	## go to line $searchText
	if ($searchText =~ s/^(\d+\.(\d+|end)|end).*$/$1/) {
	    $current = "$1";
	} elsif ($searchText =~ s/^(\d+).*$/$1/) {
	    $current = "$1.0";
	} else {
	    info_display('red', "cannot go to line '$searchText'");
	    return;
	}
    print "goto: '$searchText' '$current' '$matchType' $direction\n" if $opt_T;
	$matchType = 'g';
	$text->see($current);
	if ($scanFlag) {
	    $text->tagAdd('sel', "$current linestart", "$current lineend");
	}
	$text->markSet('insert', $current);
	report_cursor();
	$tmpText = "$searchText$matchExtensions{$matchType}";
	check_menu($tmpText, 'searches');
	return;
    }
    if ($prevText ne $searchText or $prevMatch ne $matchType) {
	print "pattern: '$searchText' '$matchType'\n" if $opt_T;
	$si = -1;			# see index
	@lines = ();
	$text->tagDelete('searchTag') if $prevText;
	$text->tagConfigure('searchTag',
			    -background => 'gray', 
			   );
	if ($matchType eq 'rn') {
	    $matchType = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';	# fill as placeholder
	}
	$current = '1.0';
	$length = '0';
	while (1) {
	    eval {
		$current = $text->search(-count => \$length,
					 $matchType, 
					 $auxiliary,
					 '--',
					 $searchText,
					 $current,	# start index
					 'end',		# stop index
					);
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		info_display('red', "ERROR: $@");	# error in search
		last;
	    }
	    last unless $current and $length;
	    my @lineinfo = $text->dlineinfo($current);
	    if ($opt_T) {
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length '@lineinfo'\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    push @lines, $current;
	    $current = $text->index("$current + $length char");
	}
	$matchType = 'rn' if $auxiliary eq '-nocase';	# otherwise radio button skips
	$tmpText = "$searchText$matchExtensions{$matchType}";
	if (@lines != 0) {
	    check_menu($tmpText, 'searches');
	}
	$prevText = $searchText;
	$prevMatch = $matchType;
    }
    if (($i = @lines) != 0) {
	my $sd = $direction ? -1 : 1;	# scroll direction
	if ($si == -1) {
	    info_display('dark green', "/$searchText/ found $i times");
	    $top = "1.0";
	    $text->see($top);		# position to top left corner
	    print "see:  $si $sd '$top' $#lines\n" if $opt_T;
	    $si = 0;			# index for downwards display
	    $sj = $#lines;		# index for upwards display
	    $siWrap = $sjWrap = 0;
	} elsif ($sd == $siWrap) {
	    info_display('dark red', "search hit BOTTOM, continuing at TOP");
	} elsif ($sd == $sjWrap) {
	    info_display('dark red', "search hit TOP, continuing at BOTTOM");
	} else {
	    $info = '';			# clears display_info
	}
	if ($sd == 1) {			# search downward
	    $top = "$lines[$si] - 1 line";
	    $text->see($top);		# position to top new search box
    print "top:  $si $sd '$top'\n" if $opt_T;
	    for ($i = $si + 1; $i <= $#lines; $i++) {
		$current = "$lines[$i] + 1 line";
		unless ($text->bbox($current)) {	# test not needed if once failed
		    $text->see($current);		# this line was previously invisible
    print "cur:  $i $sd '$current'\n" if $opt_T;
		    unless ($text->bbox($top)) {
			$top = $lines[$si];
			$text->see($top);	# position to top new search box again
    print "to1:  $i $sd '$top'\n" if $opt_T;
			if (--$i > $si) {
			    $current = $lines[$i];
			    $text->see($current);	# this is last box still visible
    print "cu1:  $i $sd '$current'\n" if $opt_T;
			}
			if ($si <= 0) {
			    $sj = $#lines;
			    $sjWrap = -$sd;
			} else {
			    $sj = $si - 1;
			    $sjWrap = 0;
			}
			$si = $i + 1;
			$siWrap = 0;
    print "for loop break early $si\n" if $opt_T;
			return;		# now show the new block of boxes
		    }
		} elsif ($opt_T) {
		    print "loop: $i $sd '$current' '$top'\n";
		}
	    }
	    $top = $lines[$si];
	    $text->see($top);		# position to top new search box again
    print "to2:  $i $sd '$top'\n" if $opt_T;
	    if (--$i > $si) {
		$current = $lines[$i];
		$text->see($current);	# this is last box still visible
    print "cu2:  $i $sd '$current'\n" if $opt_T;
	    }
	    if ($si <= 0) {
		$sj = $#lines;
		$sjWrap = -$sd;
	    } else {
		$sj = $si - 1;
		$sjWrap = 0;
	    }
	    $si = 0;
	    $siWrap = $sd;
    print "for loop complete $si\n" if $opt_T;
	} else {		# search upward
	    $top = "$lines[$sj] + 1 line";
	    $text->see($top);		# position to top new search box
    print "top:  $sj $sd '$top'\n" if $opt_T;
	    for ($i = $sj - 1; $i >= 0; $i--) {
		$current = "$lines[$i] - 1 line";
		unless ($text->bbox($current)) {	# test not needed if once failed
		    $text->see($current);		# this line was previously invisible
    print "cur:  $i $sd '$current'\n" if $opt_T;
		    unless ($text->bbox($top)) {
			$top = $lines[$sj];
			$text->see($top);	# position to top new search box again
    print "to1:  $i $sd '$top'\n" if $opt_T;
			if (++$i < $sj) {
			    $current = $lines[$i];
			    $text->see($current);	# this is last box still visible
    print "cu1:  $i $sd '$current'\n" if $opt_T;
			}
			if ($sj >= $#lines) {
			    $si = 0;
			    $siWrap = -$sd;
			} else {
			    $si = $sj + 1;
			    $siWrap = 0;
			}
			$sj = $i - 1;
			$sjWrap = 0;
    print "for loop break early $sj\n" if $opt_T;
			return;		# now show the new block of boxes
		    }
		} elsif ($opt_T) {
		    print "loop: $i $sd '$current' '$top'\n";
		}
	    }
	    $top = $lines[$sj];
	    $text->see($top);		# position to top new search box again
    print "to2:  $i $sd '$top'\n" if $opt_T;
	    if (++$i > $sj) {
		$current = $lines[$i];
		$text->see($current);	# this is last box still visible
    print "cu2:  $i $sd '$current'\n" if $opt_T;
	    }
	    if ($sj >= $#lines) {
		$si = 0;
		$siWrap = -$sd;
	    } else {
		$si = $sj + 1;
		$siWrap = 0;
	    }
	    $sj = $#lines;
	    $sjWrap = $sd;
    print "for loop complete $sj\n" if $opt_T;
	}
    } elsif ($si == -1 and not $@) {	# do not overwrite search eval error message
	if ($searchText) {
	    info_display('red', "/$searchText/ not found");
	} else {
	    info_display('dark red', "search cleared");
	}
	$si = 0;			# do not display this unless new search
    }
} # search_now

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    $text->configure(-state => 'normal');
    foreach my $index (0 .. $#activeSymbols) {
	my $ts = $activeSymbols[$index][0];
	if ($ts) {
	    if ($opt_T) {
		print(" $index")    if $ts & 01;	# normal
		print(" $index~")   if $ts & 02;	# inverted
		print(" $index=")   if $ts & 04;	# value
		print(" deleted\n");
	    }
	    if ($ts & 01) {
		$text->tagDelete("$index");
	    }
	    if ($ts & 02) {
		$text->tagDelete("$index~");
	    }
	    if ($ts & 04) {
		my $tag = "$index=";
		my @ranges = $text->tagRanges($tag);
		for (my $i = 0; $i < @ranges; $i += 2) {
		    $text->delete(@ranges[$i, $i+1]);
		}
		$text->tagDelete($tag);
	    }
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
} # deleteAllTags

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found and another for the inverted symbol, if required.
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program. Further updates occur, every time the
#	state of an active symbol changes.
#
#	Attach balloon processing while display is live.
#	Balloon processing is detached for a newly loaded file and when
#	the scan is cleared to allow clean editing.
#
########################################################################

sub scan {
    my ($current, $word, $i, $iw, $tag, $cs, $ts, $ftype, $index);

    deleteAllTags();	# also clears @activeSymbols

    if ($scanFlag) {
	$mainWindow->title("iClive $fileName");
	clearScan();	# $scanFlag = 0
    } elsif ($conn and $iCname) {
	$mainWindow->title("iClive $fileName $iCname");
	if ($fileName !~ /\b$iCname\./) {
	    info_display('red',
		"WARNING: '$fileName' does not match connected control program '$iCname'");
	}
	$current = '1.0'; my $length = '0';
	while (1) {
	    $current = $text->search(-count => \$length,
				     '-regexp',
				     '--',
				     $scanPattern,
				     $current,
				     'end');
	    last if (!$current);
	    $iw = $i = $text->get($current, "$current + $length char");
	    $i =~ s/([~\t ]*)([\w.]+)([~\t ]*)/$1$3/;
	    if ($symbolTable{$2}) {
		($ftype, $index) = @{ $symbolTable{$2} };
		if (defined $index and $ftype) {
		    $tag = $index;
		    $word = $2;			# word is in the symbol table
		    $cs = $colourSelect[$ftype]; # initial colour with ALIAS inv
#ifdef TIME_HIRES 
		    @{ $activeSymbols[$index] }[1 .. 3] = (0, $cs & ~01, [gettimeofday]);
#else
		    @{ $activeSymbols[$index] }[1, 2] = (0, $cs & ~01);	# clear inv
#endif
		    while ($i =~ m/~/g) {
			$cs ^= 1;		# complement initial colour selection
		    }
		    $tag .= '~' if ($ts = $cs & 01); # adjust tag name if inverted
		    $ts++;			# convert to a mask 0 => 01, 1 => 02
		    print "$tag	$word	'$iw'\n" if $opt_T;
		    unless ($activeSymbols[$index][0] & $ts) {
			$activeSymbols[$index][0] |= $ts; # 01|02 leaves 03 for both
			colourTag($tag, $cs);	# initial tag colour
		    }
		    $text->tagAdd($tag, $current, "$current + $length char");
		    if ($iw =~ /[\w.]+\s*=$/) {
			$tag = "$index=";
			print "$tag	$word	'$iw'\n" if $opt_T;
			unless ($activeSymbols[$index][0] & 04) {
			    $activeSymbols[$index][0] |= 04; # for analog value display
			    colourTag($tag, 2);	# ARITH tag colour never changed
			}
			$text->insert("$current lineend", " 0", $tag);
		    }
		}
		## ELSE - there may be spurious words in symbolTable with undefined data
		##        as explained in "Programming Perl 3rd ed. page 254" - IGNORE
	    }
	    $current = $text->index("$current + $length char");
	}

	####################################################################
	## Send list of active symbols to the iC control process. Only the
	## state (logic or arithmetic) for the symbols in this list need to
	## be updated for this display, since the others are not displayed.
	## It is immaterial for the control program in which logic
	## sense the symbol is displayed, except for inverted ALIASes.
	####################################################################

	my $msg = "";
	foreach $index (0 .. $#activeSymbols) {
	    if ($activeSymbols[$index][0]) {
		print "$index\n" if $opt_T;
		if (length $msg > 391) {		# REPLY - 9 in icg.h
		    $conn->send_now("$unitID.3$msg");	# intermediate active symbols
		    $msg = "";
		}
		$msg .= ";$index";
	    }
	}
	$conn->send_now("$unitID.4$msg");		# send last active symbols

	####################################################################
	## Attach balloon processing
	####################################################################

	unless ($balloonAttached) {
	    $balloon->attach($text,
	       -balloonmsg      => \$bMsg,
	       -statusmsg       => \$sMsg,
	       -balloonposition => 'mouse', # not used since postcommand returns real position
	       -postcommand     => sub {
		    if ($wIdx[0] eq $wIdx[1]) {
			## No word under mouse - dont post the balloon
			return 0;
		    } else {
			my ($ftype, $index, $val);
			## Have a word under mouse - change the message:
			my $word = $text->get($wIdx[0], $wIdx[1]);
			## Skip if it contains non-word chars or is not in Symbol Table
			return 0 if $word =~ /\W/;
			while (not defined ($index = $symbolTable{$word}[1])) {
			    ## Try if I/O like IX0.0 QX10.7 or TX0.0_14
			    return 0 if $word !~ /^[IQT]X\d+$/;
			    $word = $text->get($wIdx[0], "$wIdx[1] lineend");
			    $word =~ s/^([IQT]X\d+\.\d(_\d+)?).*$/$1/;
			}
			$ftype = $symbolTable{$word}[0];
			$val = $activeSymbols[$index][1];
			$val ^= 1 if $colourSelect[$ftype] & 01; # inv ALIAS
			$bMsg = "$val";
			$sMsg = "$word: $val";
			$text->tag('add', 'sel', $wIdx[0] => $wIdx[1]);
			## a good place to put the balloon is below the last char in the word
			my $i = $text->index("$wIdx[1] - 1 chars");
			my @p = $text->bbox($i);
			my $x = $text->rootx + $p[0] + $p[2] - 4;
			my $y = $text->rooty + $p[1] + $p[3] + 2;
			return "$x,$y";
		    }
		},
	       -motioncommand   => sub {
		    my $x = $text->pointerx - $text->rootx;
		    my $y = $text->pointery - $text->rooty;
		    @wIdx = ($text->index("\@$x,$y wordstart"),
			$text->index("\@$x,$y wordend"));
		    if ($wIdx[0] eq $lIdx[0] and $wIdx[1] eq $lIdx[1]) {
			## Same word - dont cancel the balloon.
			return 0;
		    } else {
			## New word under mouse
			## cancel it so a new balloon will be posted.
			$text->SelectionClear;
			@lIdx = @wIdx;
			return 1;
		    }
		},
	    );
	    $balloonAttached = 1;
	}

	####################################################################
	## change text on scan button to 'Edit'
	####################################################################

	$scanButton->configure(-text => 'Edit');
	$text->configure(-state => 'disabled');
	$scanFlag = 1;		# scan successful
    } else {
	$info = '';		# clears display_info
	connect_to_server();	# will call scan() if connect was successful
    }
} # scan

########################################################################
#
#	clearScan
#	detach balloon processing
#	prepare for scan
#	clear active symbols for faster processing of connected controller
#
########################################################################

sub clearScan {
    if ($balloonAttached) {
	$balloon->detach($text);
	$balloonAttached = 0;
    }
    $scanButton->configure(-text => 'Live');
    $scanFlag = 0;		# text has been cleared of all tags
    return if @_;		# called from disconnect
    $info = '';			# clears display_info
    $conn->send_now("$unitID.4") if $conn;	# clear active symbols
} # clearScan

########################################################################
#
#	check if a file has been modified and needs to be saved
#
#	IF contents has changed AND Button 'Yes' is pressed
#		saves $fileName
#		changes entry box text to $fileName if successful
#	ELSE does nothing
#	no regex matches allowed for make_file()
#
########################################################################

sub check_save {
    my $ret = 1;
    my $contents = $text->get("1.0", "end - 1 chars");	# whole text
    if ($contents ne $oldContents) {
	my $dialog = $text->Dialog (-title   => 'Modified file',
				    -bitmap  => 'question',
				    -text    => 'Save modified file?',
				    -buttons => [qw(Yes No Cancel)],
				   );
	my $dialogBar = $dialog->Label(-textvariable => \$fileName,
				       -relief       => 'ridge',
				      )->pack(-side => 'bottom',
					      -fill => 'x',
					     );
	my $answer = $dialog->Show();
	if ($answer eq 'Cancel') {
	    $ret = 0;			# cancel operation
	} elsif ($answer eq 'Yes') {
	    $ret = save_file(1);	# save modified $fileName
	}
    }
    return $ret;
} # check_save

########################################################################
#
#	new_text clears the text area
#
########################################################################

sub new_text {
    deleteAllTags();	# also clears @activeSymbols
    clearScan();
    if (check_save()) {
	$text->delete("1.0", "end");
	$oldContents = '';
	$fileName = $newName;
	$mainWindow->title("iClive $fileName");
    }
} # new_text

########################################################################
#
#	open_file
#	opens a file if possible; then loads the contents
#		parameter 1:	1  load unconditionally (discard changes)
#				'' save first if text is altered (default)
#		parameter 2:	file_name
#				'' use getOpenFile from Tk::FBox (default)
#	$fileName is assigned new file_name if successfully opened
#	this is done, rather than returning new name because open_file is often
#	called from a call-back, where the return value cannot be used
#
#	file_name must be 2nd parameter to line up with search_text(), which
#	has a dummy 1st parameter and whose 2nd parameter searchText is also
#	supplied from a menu via a closure set up in check_menu()
#	both are called via check_menu()
#
########################################################################

sub open_file {
    my ($unconditional, $fName) = @_;	# optional parameters
    if ($fName eq '') {
	$fName = $mainWindow->getOpenFile(-filetypes => $fileTypes);
	$fName =~ s#^C:/cygwin## or $fName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	$fName =~ s#^$cwd/##;
    }
    print "open_file: $unconditional $fName\n" if $opt_T;;
    if ($fName ne '') {
	deleteAllTags();		# also clears @activeSymbols
	clearScan();
	if ($unconditional or check_save()) {
	    stat($fName);
	    if (-f _ and -r _ and open(FH, "$fName")) {
		$text->delete("1.0", "end");	# clear the text area
		$oldContents = '';
		while (<FH>) {
		    $oldContents .= $_;
		}
		close(FH);
		$text->insert("end", $oldContents);
		my $length = length $oldContents;
		$fileName = $fName;	# alter global $fileName
		$mainWindow->title("iClive $fileName");
		info_display('black', "File '$fileName', '$length' bytes loaded");
		$prevText = '';		# start a new search
		check_menu($fileName, 'files');
		return;			# global $fileName is altered
	    }
	    info_display('red', "ERROR: Could not open $fName");
	}
    } else {
	info_display('red', "no file opened");
    }
    return;				# global $fileName is not altered
} # open_file

########################################################################
#
#	save_file
#	saves the file previously loaded or last saved
#		parameter 1:	1  overwrite file unconditionally (new destination)
#				'' overwrite if contents has changed (default)
#
########################################################################

sub save_file {
    my $ret = 1;
    if ($fileName and $fileName ne $newName) {
	my ($unconditional) = @_;	# optional parameter
	deleteAllTags();	# also clears @activeSymbols
	clearScan();	# take away all live text
	my $contents = $text->get("1.0", "end - 1 chars");
	if ($unconditional or $contents ne $oldContents) {
	    if (open(FH, ">$fileName")) {
		$oldContents = $contents;
		my $length = length $oldContents;
		print FH $oldContents;
		close(FH);
		$mainWindow->title("iClive $fileName");
		info_display('black', "File '$fileName', '$length' bytes saved");
		check_menu($fileName, 'files');
	    } else {
		info_display('red', "ERROR: Could not open '$fileName' for writing");
		$ret = 0;
	    }
	} else {
		info_display('blue', "FILE '$fileName' has not changed - not written");
	}
    } else {
	$ret = saveAs_file();
    }
    return $ret;
} # save_file

########################################################################
#
#	saveAs_file
#	save file to suggested $fileName or to another selected file_name
#		return:		1  file successfully saved
#				0  failure - $fileName not changed
#	$fileName is assigned new file_name if successfully saved
#
########################################################################

sub saveAs_file {
    my $ret = 1;
    my $oldname = $fileName;
    $fileName = $mainWindow->getSaveFile(-filetypes => $fileTypes,
					 -initialfile => $fileName);
    $fileName =~ s#^C:/cygwin## or $fileName =~ s#^([A-Z]):#/cygdrive/\l$1#;
    $fileName =~ s#^$cwd/##;
    print "saveAs_file: $fileName\n" if $opt_T;;
    if ($fileName ne '') {
	if (save_file($fileName ne $oldname) == 0) {
	    $fileName = $oldname;	# restore fileName
	    $mainWindow->title("iClive $fileName");
	    $ret = 0;
	}
    } else {
	info_display('red', "no file saved");
	$fileName = $oldname;	# restore fileName
	$ret = 0;
    }
    return $ret;
} # saveAs_file

########################################################################
#
#	Make a target file generated from $fileName (C file or executable)
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate a new target file if target is older than $fileName
#
#	2nd parameter:	0   Make executable
#			1   Make unconditionally
#			2   Make C file only
#
########################################################################

sub make_file {
    my $par2 = $_[1];		# make C file if true
    if (check_save()) {		# make sure check_save() has no regex matches
	my $errorName;
	if ($fileName =~ /(^[\w\.\\\/]+)\.(lst?|c|ini)$/) {
	    $errorName = "$1.ic";	# listing should never be modified
	    open_file(1, $errorName);	# load the corresponding iC source unconditionally
	} else {
	    deleteAllTags();	# also clears @activeSymbols
	    clearScan();
	}
	if ($fileName !~ /(^[\w\.\\\/]+)\.ic/) {
	    info_display('blue', "WARNING: cannot make '$fileName' (must end in .ic)");
	} else {
	    my $baseName = $1;	# so that $1 is valid
	    my $targetName = $par2 == 2 ? "$baseName.c" : $baseName;
	    my $ftime = (stat($fileName))[9];
	    my $mtime = (stat($targetName))[9];
	    my $ret = 0;
	    $errorName = '';
	    if ($par2 == 1 or $mtime < $ftime) {
		my @args = ("iCmake", $fileName);
		if ($par2 == 2) {
		    splice(@args, 1, 0, '-b');	# iCmake -b to suppress making executable
		}
		print "system @args\n" if $opt_t;
		$ret = system(@args) >> 8;
		if ($ret) {
		    $errorName = "$baseName.lst";
		    open_file(0, $errorName);	# load the listing file (iC is up to date)
		    $searchText = '^\*\*\* ';	# regular expression to find errors in listing
		    $prevText = '';		# start a new search
		    $matchType = '-regexp';
		    search_text();			# carry out the search setting markers
		    $errorName = "$baseName.ic";	# to open iC file after inspecting listing
		    info_display('red',
			"ERROR: '$targetName' cannot be made from '$errorName' (return = $ret)");
		} else {
		    info_display('dark green', "'$targetName' successfully made");
		}
	    } else {
		info_display('blue', "'$targetName' is up to date");
	    }
	}
    } # ELSE operation was cancelled by check_save()
} # make_file

########################################################################
#
#	run the executable file generated from $fileName
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate name of executable file from $fileName
#	run executable if it exists, is executable and newer than source
#
########################################################################

sub run_file {
    if ($runFlag) {
	stop_file();	# $runFlag = 0
    } elsif ($conn and $iCname) {
	info_display('red', "$unitID is connected to '$iCname' (Stop it to run '$fileName')");
    } elsif ($fileName !~ /(^[\w\.\\\/]+)\.(ic|lst?|c|ini)$/) {
	info_display('blue', "WARNING: cannot run '$fileName' (must end in .ic .lst .c or .ini)");
    } elsif ($2 ne 'ic' or check_save()) {
	deleteAllTags();	# also clears @activeSymbols
	clearScan();
	my $processName = $1;
	print "run_file: $processName from $fileName\n" if $opt_T;;
	my $ftime = (stat($fileName))[9];
	my $mtime = (stat($processName))[9];
	if (not -f _) {
	    info_display('red', "ERROR: no file named '$processName' (Make it first)");
	} elsif (not -x _) {
	    info_display('red', "ERROR: '$processName' not executable ??");
	} elsif ($mtime < $ftime) {
	    info_display('blue', "WARNING: '$processName' is older than '$fileName' (Make again)");
	} else {
	    my $pid;
	    FORK: {
		if ($pid = fork) {
		    ## parent process
		    sleep 0.1;	# wait for control program to be activated as child process
		    scan();	# make live connection with the new control program
		} elsif (defined $pid) {	# $pid is zero if defined
		    ## dispatch child process
		    my @call = ($processName);
		    splice @call, 1, 0, '-p', $opt_p if defined $opt_p;
		    splice @call, 1, 0, '-t' if defined $opt_t;
		    splice @call, 1, 0, '-m' if defined $opt_m;
		    print "@call\n";
		    exec @call;
		} elsif ($! =~ /No more process/) {
		    ## EAGAIN, recoverable fork error
		    sleep 5;
		    redo FORK;
		} else {
		    ## weird fork error
		    die "Can't fork: $!\n";
		}
	    }
	}
    } # ELSE operation was cancelled by check_save()
} # run_file

########################################################################
#
#	stop the control program if connected
#
########################################################################

sub stop_file {
    if ($conn and $iCname) {
	deleteAllTags();	# also clears @activeSymbols
	clearScan();
	$conn->send_now("$unitID.5");	# stop control program
    } else {
	info_display('red', "$unitID is not connected to a control program");
    }
} # stop_file

########################################################################
#
#	check_menu (newEntry, menuKey)
#	    iniData{menuKey} ==> [
#		menuRef,
#		menuPos,
#		entriesArRef,
#		entriesLim,
#		commandRef,
#	    ])
#
########################################################################

sub check_menu {
    my ($newEntry, $menuKey) = @_;
    print "check_menu: [$menuKey] '$newEntry'\n" if $opt_T;
    my $menuData = $iniData{$menuKey};
    my ($menuRef, $menuPos, $entriesArRef, $entriesLim, $commandRef) = @$menuData;
    if ($menuRef) {
	my $entry;
	foreach $entry (@$entriesArRef) {
	    if ($newEntry eq $entry) {
		return;				# avoid dual identical entries
	    }
	}
	push(@$entriesArRef, $newEntry);	# push a new entry at the back
	$menuRef->command(-label   => "$newEntry",	# must use local $newEntry below
			  -command => [ $commandRef, 0, $newEntry ]);
	if ($#$entriesArRef >= $entriesLim) {
	    $menuRef->menu->delete($menuPos);	# first dynamic menu entry
	    shift(@$entriesArRef);		# shift out the extra entry
	}
    } else {
	push(@$entriesArRef, $newEntry);	# not a menu list
    }
} # check_menu

########################################################################
#
#	initialise the program by reading ~/.iClive.ini if it exists
#	and initialising file list and search list in menus
#	IF there are no file arguments, open the last open file
#	ELSE	open the first file in the argument list
#		add any others to the file list menu
#
#	structure of ~/.iClive.ini
#	[files]
#		sort5.ic
#		sort5.lst
#		/tmp/trial.ic
#	[last open file]
#		sort5.ic
#	[searches]
#		pip			# default match type is -exact
#		[files]			# a curious -exact match
#		timer		n	# match type -nocase (<tab>n)
#		QX[\d+]\.[\d+]	r	# match type -regexp (<tab>r)
#		ix[\d+]\.[\d+]	rn	# is resolved to -regexp -nocase
#
#	since tabs cannot be entered in the search entry box (skips to text window)
#	use <tab> followed by search option in the search menu list
#	also precede each ini item by <tab>, since [files] may be a
#	legitimate search expression (watch Goedel here)
#
########################################################################

sub ini_program {
    my ($home, $menuData, $menuKey, $entry, $initialFile);
    ## restore file and search menu lists from ~/.iClive.ini
    if (($home = $ENV{HOME}) ne '' and open(INI, "$home/.iClive.ini")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$menuKey = $1;			# key found
		$menuData = $iniData{$menuKey};
    print "ini_program: menuKey [$menuKey] found\n" if $opt_T;
	    } elsif ($menuData and s/^\t(.*)$/$1/) {	# ini starts with <tab>
		$entry = $_;
		check_menu($entry, $menuKey);
	    }
	}
	close(INI);
    }	# ignore if ~/.iClive.ini cannot be opened or found
    $initialFile = shift @ARGV;			# ARGV may be empty
    $initialFile = shift @lastFile unless $initialFile;
    open_file(0, $initialFile) if $initialFile;
    foreach $initialFile (@ARGV) {
	check_menu($initialFile, 'files');	# stuff the rest in the file menu list
    }
} # ini_program

########################################################################
#
#	quit program after checking if file needs saving
#	and current file and search menu lists have been written
#
########################################################################

sub quit_program {
    my ($home, $menuKey, $entriesArRef, $entry);
    deleteAllTags();	# also clears @activeSymbols
    clearScan();
    if (check_save()) {
	print "quit_program: fileName = '$fileName', lastFile = '@lastFile'\n" if $opt_T;
	if ($fileName and $fileName ne $newName) {
	    $lastFile[0] = $fileName;
	}
	## save file and search menu lists to ~/.iClive.ini
	if (($home = $ENV{HOME}) ne '') {
	    if (open(INI, ">$home/.iClive.ini")) {
		foreach $menuKey (sort keys %iniData) {
		    print INI "[$menuKey]\n";
		    $entriesArRef = @{$iniData{$menuKey}}->[2];
		    foreach $entry (@$entriesArRef) {
			print INI "\t$entry\n" if $entry;
		    };
		}
		close(INI);
	    } else {
		print STDERR "Can't open ~/.iClive.ini: $!\n";
	    }
	}
	exit(0);
    }
    ## continue if check_save() was cancelled
} # quit_program
#ifdef TIME_HIRES 

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    my $ti = tv_interval $t0, [gettimeofday];
    printf "%10.6f%s", $ti, $opt_t ? ": " : "\n";
    $t0 = [gettimeofday];
} # printMicroSeconds
#endif
