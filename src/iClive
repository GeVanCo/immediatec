#!/usr/bin/perl -P

########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	iClive display for iC sources and listings
#
#	iClive provides an edit window in which the text of a source
#	or listing can be displayed and optionally edited and saved.
#
#	iClive is normally a client of a running iC program. On startup
#	it requests the symbol table of the running program. It returns
#	a list of words from the symbol table on which it wants live
#	updates of the state of the nodes, named by each word in the
#	list. The running program then provides updates when the state
#	of any node from the list changes as soon as possible after the
#	change.
#
#	All words in the text which exactly match any token in the list
#	are marked with a colour depending on the current state of the
#	node - usually green for 0 and red for 1. These are called 'active'
#	words. Active words in the list which are preceded by ~ or ! or
#	which are followed by ~ show the inverse state of the node.
#
#	When the mouse cursor sits on an active word the value of the
#	node is displayed in a subwindow. This is useful for displaying
#	the current value of arithmetic nodes.
#
#	To be effective, the displayed text must be either the source of
#	the running iC program or a text derived from that source, such
#	as the iC listing. iClive then shows the logical statements of
#	the source and the colours will show what the current state is.
#	It is then easy to inspect the listing and relate states with
#	the logic.
#
#	For measuring reaction times the Module Time::HiRes is used.
#	This activates the -m option and flash display of short events.
#	Make sure you have installed Time::HiRes (provided in this distribution)
#define TIME_HIRES
#
########################################################################

use Tk;					# Slurp the module in
use Msg;
use Tk::TextUndo;
use Tk::Balloon;
use Tk::Dialog;
use strict;
#ifdef TIME_HIRES 
use Time::HiRes qw(sleep gettimeofday tv_interval);
my $t0 = [gettimeofday];	# start of program
my %delayedColour;	# colour that should be restored after a flash
#endif

########################################################################
#
#	Colour selection for background/foreground and false/true
#	$colourSelect[ftype] must match the definitions in 'icc.h'
#	Different ftypes select the 'cs' index to select four colours.
#	The last bit of cs selects the false/true colours.
#	The ftype INV_ALIAS has an odd 'cs' which inverts the colours.
#
#	To display clocks and glitches, the foreground is flashed white
#	for 50 milliseconds. Flashing the background looks confusing.
#
########################################################################

my @colourSelect  = ( 0,2,0,2,2,2,0,0,0,0,0,0,0,2,0,4,6,  # cs[ftype] 0 - 16
			2,0,1,0,0,0,0,0,0,0,0,0,0,0,4,6,  # ALIAS    17 - 32
		    );

#  live colouring     false 0          true 1             cs  ftype
my @tagBackground = ('PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
							# cs|010 no change
		     'PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
		    );
my @tagForeground = ('black'        , 'red'          ,  # 0 1 GATE
		     'black'        , 'red'          ,  # 2 3 ARITH
		     'black'        , 'white'        ,  # 4 5 CLCKL
		     'black'        , 'white'        ,  # 6 7 TIMRL
							# cs|010 flash glitch
		     'white'        , 'white'        ,  # 0 1 GATE
		     'white'        , 'white'        ,  # 2 3 ARITH
		     'white'        , 'black'        ,  # 4 5 CLCKL
		     'white'        , 'black'        ,  # 6 7 TIMRL
		    );

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
@<<<<<<< [-tTmh] [-s <host>] [-p <port>] [-f <font>] [file ...]
	$named
	-s host	host name of server    (default 'localhost')
	-p port	service port of server (default '8778')
	-f font	font to use in Text window (default '9x15')
	-t	trace run time changes
	-T	trace static debug messages
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-h	help, ouput this Usage text only

Menu buttons:
    File/New	provide an empty page for editing.
    File/Open	load the file named in the menu bar window.
    File/Save	store the file previously opened if modified
    File/SaveAs store the file by the name in the menu bar window.
    File/Quit	quit the program.

    Live	scan the text in the text window and generate live markings
    		for all words in the text, which represent variables in the
		currently running program. (The text should be related)
    Edit	clear the live markings in the text window. In this mode the
    		text may be edited.

    Search	select one of four search modes.
    		A search in the edit window for a text or regular expression
		in the menu bar window is initiated by the Return key, when
		the focus is in the menu bar window.
		All found items will be marked. Striking the Return key again
		will display a section of the text containing found items
		which were previously not displayed. Shift-Return will reverse
		the direction of scrolling.
Editing:
    This program uses the Tk::TextUndo widget, an extension of Tk::Text.
    In 'Live' mode when a 'live display' is shown the text is read only.
    When the 'Edit' button is pressed this program is a full featured editor. 
    The edit facilities of this program are described in the Tk::Text man
    page in the section 'BINDINGS' near the end. (Control-u is <<Undo>>)

Copyright (C) 2000-2001  John E. Wulff		<john.wulff@inka.de>
						  '@'
$Id: iClive,v 1.19 2002/06/12 06:30:46 jw Exp $
.

use vars qw($opt_T $opt_t $opt_m $opt_s $opt_p $opt_f $opt_h);
require "getopts.pl";
&Getopts('tTms:p:f:h');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

########################################################################
#
#	Initialize global variables
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $font = defined $opt_f ? $opt_f : '9x15';
my $unitID = 'L0';
my %symbolTable = ();	# $symbolTable{$symbol} [0, 1]   = ($ftype, $index)
my @activeSymbols;	# $activeSymbols[$index][0 .. 3] = ($ts,$val,$cs,[$sec,$usec])
my $stIndex = 0;
my $conn;

my $info = '';
my $iCname = '';	# name of connected iC control program
my $filename = '';	# name of currently loaded file
my $errorname = '';	# name of source with errors

$filename = $ARGV[0] unless @ARGV < 1;
my $search_text = $filename;
my $oldContents = '';

########################################################################
#
#	Create main window and menus
#
########################################################################

my $mainWindow = MainWindow->new();
$mainWindow->title("iClive");

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack('-side' => 'top', '-fill' => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton('-text' => 'File',
				    '-relief' => 'raised',
				    '-borderwidth' => 2,
				   )->pack('-side' => 'left',
					   '-padx' => 2,
					  );
$menuFile->command('-label' => 'New',    '-command' => \&new_text);
$menuFile->command('-label' => 'Open',   '-command' => \&load_file);
$menuFile->command('-label' => 'Save',   '-command' => \&save_file);
$menuFile->command('-label' => 'SaveAs', '-command' => \&saveAs_file);
$menuFile->separator();
$menuFile->command('-label' => 'Quit',   '-command' => \&quit_program);

########################################################################
#	Make menu
########################################################################
my $make_mb   = $menuBar->Menubutton('-text'        => 'Make',
				     '-relief'      => 'raised',
				     '-borderwidth' => 2,
				    )->pack('-side' => 'left',
					    '-padx' => 2,
					   );
$make_mb->command('-label' => 'Make C file',     '-command' => [ \&make_file, 0, 1 ]);
$make_mb->command('-label' => 'Make executable', '-command' => [ \&make_file, 0, 0 ]);

########################################################################
#	Run or Stop button
########################################################################
my $runButton  = $menuBar->Button('-text'        => 'Run ',
				  '-relief'      => 'raised',
				  '-borderwidth' => 2,
				  '-command'     => \&run_file,
			         )->pack('-side' => 'left',
				         '-padx' => 2,
				        );
my $runFlag = 0;

########################################################################
#	Live or Edit button
########################################################################
my $scanButton = $menuBar->Button('-text'        => 'Live',
				  '-relief'      => 'raised',
				  '-borderwidth' => 2,
				  '-command'     => \&scan,
			         )->pack('-side' => 'left',
				         '-padx' => 2,
				        );
my $scanFlag = 0;		# text is initially cleared

########################################################################
#	Search menu 
########################################################################
my $search_mb = $menuBar->Menubutton('-text'        => 'Search',
				     '-relief'      => 'raised',
				     '-borderwidth' => 2,
				    )->pack('-side' => 'left',
					    '-padx' => 2,
					   );
my $match_type = "-exact";	# default, alternatives -nocase -regexp

$search_mb->command('-label' => 'Search down', '-command' => [ \&search, 0, 1 ]);
$search_mb->command('-label' => 'Search up',   '-command' => [ \&search, 0, -1 ]);
$search_mb->separator();
########################################################################
#	Exact match
########################################################################
$search_mb->radiobutton('-label'    => 'Exact match',
			'-value'    => '-exact',
			'-variable' => \$match_type);
########################################################################
#	Ignore case
########################################################################
$search_mb->radiobutton('-label'    => 'Ignore case',
			'-value'    => '-nocase',
			'-variable' => \$match_type);
########################################################################
#	Regexp match
########################################################################
$search_mb->radiobutton('-label'    => 'Regexp match',
			'-value'    => '-regexp',
			'-variable' => \$match_type);
########################################################################
#	Regexp match - Ignore case
########################################################################
$search_mb->radiobutton('-label'    => 'Regexp Ignore case',
			'-value'    => 'rn',
			'-variable' => \$match_type);

########################################################################
#	Search entry
########################################################################
my $search = $menuBar->Entry('-width'        => 20,
			     '-textvariable' => \$search_text,
			    )->pack('-side' => 'left',
				    '-padx' => 2,
				   );
$search->bind('<KeyPress-Return>', [ \&search, 1 ]);		# scroll down
$search->bind('<Shift-KeyPress-Return>', [ \&search, -1 ]);	# scroll up

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
		   -relief => 'ridge',
		  )->pack(-side => 'bottom',
		  	  -fill => 'x',
		         );

########################################################################
#	Text window
########################################################################
my $text = $mainWindow->Scrolled('TextUndo',
		                 -scrollbars => 'osoe',
		                 -background => 'cornsilk1',
		                 -wrap       => 'none',
		                 -font       => $font,
		                )->pack(-fill   => 'both',
			                -expand => 1,
			               );

$text->eventAdd('<<Undo>>' => '<Control-u>');	# extra Undo binding

########################################################################
#	Balloon widget
########################################################################
my $balloon = $mainWindow->Balloon(-statusbar => $infoBar);
my $balloonAttached = 0;
$mainWindow->OnDestroy(sub { $balloon->destroy; });

########################################################################
#	Open the first file in the argument list
########################################################################

load_file() if $filename;

########################################################################
#	Connect to iCserver
########################################################################

connect_to_server();

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################

MainLoop;

########################################################################
#
#	Connect to iCserver
#	Register read events
#	Register I/O at iCserver and request Symbol Table
#
########################################################################

sub connect_to_server {
    $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
    if ($conn) {
	print "Connection $unitID at client.\n";
	$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });
	$conn->send_now($unitID);	# register I/O
	%symbolTable = ();
	$conn->send_now("$unitID.1");	# request Symbol Table
    } else {
	$infoBar->configure(-foreground => 'red');
	$info = "Could not connect to $host:$port - no live listing - edit only";
    }
}

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occurr if $conn and read events registered)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
#ifdef TIME_HIRES 
    printMicroSeconds() if $opt_m;
#endif
    if (defined $msg) {
	if (length $msg == 0) {
	    $rConn->disconnect();
	    $mainWindow->title("iClive $filename");
	    $infoBar->configure(-foreground => 'red');
	    $info = $iCname ?
		"$unitID disconnected from '$iCname' by server" :
		"$unitID is not connected to a control program";
	    deleteAllTags();	# also clears @activeSymbols
	    %symbolTable = ();	# clear symbol table so balloons dont show
	    undef $iCname;
	    undef $conn;
	    clearScan(1);	# detach balloon
	    ####################################################
	    # change text on run button to "Run"
	    ####################################################
	    $runButton->configure(-text => "Run ");
	    $runFlag = 0;
	} else {
	    print "$msg\n" if $opt_t;
	    my @symbols = split /;/, $msg;	# break up message
	    my $entry = shift @symbols;		# first entry is an operation
	    if ($entry =~ /$unitID\.(\d+)/) {
		if (($entry = $1) eq '1') {
		    ####################################################
		    # Symbol Table block
		    # Symbol table entries consist of two or three words.
		    # Usually symbol-id and ftype are received. In this
		    # case the ST-offset is the index. (computed by counting)
		    # For ALIASes the index of the Gate to which the
		    # ALIAS resolves is transmitted as a 3rd value.
		    ####################################################
		    while ($entry = shift @symbols) {
			my ($symbol, $ftype, $index) = split " ", $entry;
			$index = $stIndex unless defined $index;
			print "$index\t$symbol\t$ftype\n" if $opt_T;
			@{ $symbolTable{$symbol} } = ($ftype, $index);
			$stIndex++;
		    }
		} elsif ($entry eq '2') {
		    ####################################################
		    # End of Symbol Table
		    # The 2nd entry is the name of the running iC program.
		    # This name allows a check against the file name of
		    # the displayed text. (Assume it should match)
		    ####################################################
		    $iCname = shift @symbols;
		    $infoBar->configure(-foreground => 'blue');
		    $info = "$unitID connected to '$iCname' by server";
		    ####################################################
		    # change text on run button to "Stop"
		    ####################################################
		    $runButton->configure(-text => "Stop");
		    $runFlag = 1;		# run successful
		    $stIndex = 0;		# ready for next reception
		    scan();
		} elsif ($entry eq '3') {
		    ####################################################
		    # New data values
		    # Data value entries consist of ST-index and value
		    ####################################################
		    while ($entry = shift @symbols) {
			my ($index, $value) = split " ", $entry;
#ifdef TIME_HIRES 
			my $tNew;
			my ($cs, $tOld) = @{ $activeSymbols[$index] }[2, 3];
			$activeSymbols[$index][3] = $tNew = [gettimeofday];
			my $tRest = 50 - int(tv_interval($tOld, $tNew) * 1000);	# ms.
# print "index: $index value: $value rest: $tRest\n";
#else
			my $cs = $activeSymbols[$index][2];
#endif
			$cs ^= 1 if $value;			# change colour
			$activeSymbols[$index][1] = $value;	# for value display
			if ($activeSymbols[$index][0] & 01) {
#ifdef TIME_HIRES 
			    if ($tRest < 10) {
				colourTag("$index", $cs);	# normal colour
			    } else {
				colourTag("$index", $cs | 010);	# flash glitch
				# delay the colour change to make it visible
				$text->after(50, [ \&restoreTag, "$index" ]);
			    }
#else
			    colourTag("$index", $cs);		# normal colour
#endif
			    if ($cs == 5 or $cs == 7) {	# hi CLOCK or TIMER
				# turn colour off after 50 ms.
				$text->after(50, [ \&colourTag, "$index", $cs & ~01 ]);
			    }
			}
			if ($activeSymbols[$index][0] & 02) {
#ifdef TIME_HIRES 
			    $cs ^= 1;				# complement colour
			    if ($tRest < 10) {
				colourTag("$index~", $cs);	# latest $cs is saved
			    } else {
				colourTag("$index~", $cs | 010);# flash glitch
				# delay the colour change to make it visible
				$text->after(50, [ \&restoreTag, "$index~" ]);
			    }
#else
			    colourTag("$index~", $cs ^ 1);	# complement colour
#endif
			}
			if ($activeSymbols[$index][0] & 04) {
			    my $tag = "$index=";
			    my @ranges = $text->tagRanges($tag);
# print "value at index $index: $activeSymbols[$index][1] '@ranges'\n";
			    $text->configure(-state => 'normal');
			    for (my $i = 0; $i < @ranges; $i += 2) {
				my ($beg, $end) = @ranges[$i, $i+1];
				$text->delete($beg, $end);
				$text->insert($beg, " $value", $tag);
			    }
			    $text->configure(-state => 'disabled');
			}
#ifdef TIME_HIRES 
			printMicroSeconds() if $opt_m;
#endif
			print "$index	$value\n" if $opt_t;
		    }
		} else {
		    goto Spurious;
		}
	    } else {
		Spurious: warn "$unitID: spurious operation '$entry' ???\n";
	    }
	}
    }
}

########################################################################
#
#	Change the tag colours
#
########################################################################

sub colourTag {
    my ($tag, $cs) = @_;
# print "colourTag: $tag $cs\n";
    $text->tagConfigure($tag,
			'-background' => $tagBackground[$cs], 
			'-foreground' => $tagForeground[$cs],
		       );
#ifdef TIME_HIRES 
    $delayedColour{$tag} = $cs;		# save colour for end of flash
}

########################################################################
#
#	Restore the tag colour after a flash
#
#	If the value in %delayedColour were not used, another change
#	before the 50 ms flash is finished may come in and the end of
#	flash will then restore to the second last change. Now the
#	colour is saved in &colourTag and the end of the flash will
#	restore the very latest change.
#
########################################################################

sub restoreTag {
    my ($tag) = @_;
    my $cs = $delayedColour{$tag} & 07;	# latest colour ignoring flash
# print "restoreTag: $tag $cs\n";
    $text->tagConfigure($tag,
			'-background' => $tagBackground[$cs], 
			'-foreground' => $tagForeground[$cs],
		       );
#endif
}

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from bind('<Return>', [ \&search, 1 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy first paramater when called directly
#	use second parameter $_[1] (1 or -1)
#
#	2nd parameter:	1   Search down
#			-1  Search up
#
########################################################################

my ($prev_text, $prev_match, @lines, $si);	# has to be global, 'our' not portable yet

sub search {
    my $sd = $_[1];			# scroll direction
    my ($auxiliary, $current, $length, $i);
    if ($prev_text ne $search_text or $prev_match ne $match_type) {
	print "pattern: '$search_text' '$prev_text'\n" if $opt_T;
	$si = -1;			# see index
	@lines = ();
	$text->tagDelete('searchTag') if $prev_text;
	$text->tagConfigure('searchTag',
			    '-background' => 'gray', 
			   );
	if ($match_type eq 'rn') {
	    $match_type = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';	# fill as placeholder
	}
	$current = '1.0';
	$length = '0';
	while (1) {
	    eval {
		$current = $text->search('-count' => \$length,
				     $match_type, 
				     $auxiliary,
				     '--',
				     $search_text,
				     $current,
				     'end',
				    );
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		$infoBar->configure(-foreground => 'red');
		$info = "ERROR: $@";		# error in search - report in info bar
		last;
	    }
	    last unless $current and $length;
	    my @lineinfo = $text->dlineinfo($current);
	    if ($opt_T) {
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length '@lineinfo'\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    push @lines, $current;
	    $current = $text->index("$current + $length char");
	}
	$match_type = 'rn' if $auxiliary eq '-nocase';	# otherwise radio button skips
	$prev_text = $search_text;
	$prev_match = $match_type;
    }
    if ($i = @lines) {
	if ($si == -1) {
	    $infoBar->configure(-foreground => 'black');
	    $info = "/$search_text/ found $i times";
	    $i = 0;
	    $text->see($lines[$i]);
	} else {
	    for ($i = $si + $sd;
		($i = $i > $#lines ? 0 : $i < 0 ? $#lines : $i) != $si;
		$i += $sd) {
		$current = $lines[$i];
		unless ($text->dlineinfo($current)) {
		    $text->see($lines[$i]);	# this line was previously invisible
		    last;
		} else {
		    print "loop: $i $sd '$lines[$i]'\n" if $opt_T;
		}
	    }
	}
	print "see:  $i $sd '$lines[$i]' '$#lines'\n" if $opt_T and $i != $si;
	$si = $i;
    } elsif ($si == -1 and not $@) {
	$infoBar->configure(-foreground => 'red');
	$info = $search_text ? "/$search_text/ not found" : "";
	$si = 0;
    }
}

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    $text->configure(-state => 'normal');
    foreach my $index (0 .. $#activeSymbols) {
	my $ts = $activeSymbols[$index][0];
	if ($ts) {
	    if ($opt_T) {
		print(" $index")    if $ts & 01;	# normal
		print(" $index~")   if $ts & 02;	# inverted
		print(" $index=")   if $ts & 04;	# value
		print(" deleted\n");
	    }
	    if ($ts & 01) {
		$text->tagDelete("$index");
	    }
	    if ($ts & 02) {
		$text->tagDelete("$index~");
	    }
	    if ($ts & 04) {
		my $tag = "$index=";
		my @ranges = $text->tagRanges($tag);
		for (my $i = 0; $i < @ranges; $i += 2) {
		    $text->delete(@ranges[$i, $i+1]);
		}
		$text->tagDelete($tag);
	    }
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
}

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found and another for the inverted symbol, if required.
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program. Further updates occur, every time the
#	state of an active symbol changes.
#
#	Attach balloon processing while display is live.
#	Balloon processing is detached for a newly loaded file and when
#	the scan is cleared to allow clean editing.
#
########################################################################

my $bMsg = '';
my $sMsg = '';
my @wIdx = ('', '');  # Indices surrounding the current word.
my @lIdx = ('', '');  # Same for last word.

sub scan {
    my ($search_pattern, $current, $word, $i, $iw, $tag, $cs, $ts, $ftype, $index);

    deleteAllTags();	# also clears @activeSymbols

    if ($scanFlag) {
	$mainWindow->title("iClive $filename");
	clearScan();	# $scanFlag = 0
    } elsif ($conn and $iCname) {
	$mainWindow->title("iClive $filename $iCname");
	if ($filename !~ /$iCname/) {
	    $infoBar->configure(-foreground => 'red');
	    $info = "WARNING: '$filename' does not match connected control program '$iCname'"; 
	}

	$search_pattern = '[~\s]*[A-Z_a-z][\w]*(\.\w+)?\s*((~ )?---|=$)?';
	$current = '1.0'; my $length = '0';
	while (1) {
	    $current = $text->search('-count' => \$length,
				     '-regexp',
				     '--',
				     $search_pattern,
				     $current,
				     'end');
	    last if (!$current);
	    $iw = $i = $text->get($current, "$current + $length char");
	    $i =~ s/([~\t ]*)([\w.]+)([~\t ]*)/$1$3/;
	    if ($symbolTable{$2}) {
		($ftype, $index) = @{ $symbolTable{$2} };
		if (defined $index and $ftype) {
		    $tag = $index;
		    $word = $2;			# word is in the symbol table
		    $cs = $colourSelect[$ftype]; # initial colour with ALIAS inv
#ifdef TIME_HIRES 
		    @{ $activeSymbols[$index] }[1 .. 3] = (0, $cs & ~01, [gettimeofday]);
#else
		    @{ $activeSymbols[$index] }[1, 2] = (0, $cs & ~01);	# clear inv
#endif
		    while ($i =~ m/~/g) {
			$cs ^= 1;		# complement initial colour selection
		    }
		    $tag .= '~' if ($ts = $cs & 01); # adjust tag name if inverted
		    $ts++;			# convert to a mask 0 => 01, 1 => 02
		    print "$tag	$word	'$iw'\n" if $opt_T;
		    unless ($activeSymbols[$index][0] & $ts) {
			$activeSymbols[$index][0] |= $ts; # 01|02 leaves 03 for both
			colourTag($tag, $cs);	# initial tag colour
		    }
		    $text->tagAdd($tag, $current, "$current + $length char");
		    if ($iw =~ /[\w.]+\s*=$/) {
			$tag = "$index=";
			print "$tag	$word	'$iw'\n" if $opt_T;
			unless ($activeSymbols[$index][0] & 04) {
			    $activeSymbols[$index][0] |= 04; # for analog value display
			    colourTag($tag, 2);	# ARITH tag colour never changed
			}
			$text->insert("$current lineend", " 0", $tag);
		    }
		} else {
		    $infoBar->configure(-foreground => 'CadetBlue');
		    $index = '<undef>' if not defined $index;
		    $info = "SYSTEM WARNING: symbolTable{$2}  index = $index ftype = $ftype";
		    warn "$info\n";

		}
	    }
	    $current = $text->index("$current + $length char");
	}

	####################################################################
	# Send list of active symbols to the iC control process. Only the
	# state (logic or arithmetic) for the symbols in this list need to
	# be updated for this display, since the others are not displayed.
	# It is immaterial for the control program in which logic
	# sense the symbol is displayed, except for inverted ALIASes.
	####################################################################

	my $msg = "";
	foreach $index (0 .. $#activeSymbols) {
	    if ($activeSymbols[$index][0]) {
		print "$index\n" if $opt_T;
		if (length $msg > 391) {		# REPLY - 9 in icc.h
		    $conn->send_now("$unitID.3$msg");	# intermediate active symbols
		    $msg = "";
		}
		$msg .= ";$index";
	    }
	}
	$conn->send_now("$unitID.4$msg");		# send last active symbols

	####################################################################
	# Attach balloon processing
	####################################################################

	unless ($balloonAttached) {
	    $balloon->attach($text,
	       -balloonmsg      => \$bMsg,
	       -statusmsg       => \$sMsg,
	       -balloonposition => 'mouse', # not used since postcommand returns real position
	       -postcommand     => sub {
		    if ($wIdx[0] eq $wIdx[1]) {
			# No word under mouse - dont post the balloon
			return 0;
		    } else {
			my ($ftype, $index, $val);
			# Have a word under mouse - change the message:
			my $word = $text->get($wIdx[0], $wIdx[1]);
			# Skip if it contains non-word chars or is not in Symbol Table
			return 0 if $word =~ /\W/;
			while (not defined ($index = $symbolTable{$word}[1])) {
			    # Try if I/O like IX0.0 QX10.7 or TX0.0_14
			    return 0 if $word !~ /^[IQT]X\d+$/;
			    $word = $text->get($wIdx[0], "$wIdx[1] lineend");
			    $word =~ s/^([IQT]X\d+\.\d(_\d+)?).*$/$1/;
			}
			$ftype = $symbolTable{$word}[0];
			$val = $activeSymbols[$index][1];
			$val ^= 1 if $colourSelect[$ftype] & 01; # inv ALIAS
			$bMsg = "$val";
			$sMsg = "$word: $val";
			$text->tag('add', 'sel', $wIdx[0] => $wIdx[1]);
			# a good place to put the balloon is below the last char in the word
			my $i = $text->index("$wIdx[1] - 1 chars");
			my @p = $text->bbox($i);
			my $x = $text->rootx + $p[0] + $p[2] - 4;
			my $y = $text->rooty + $p[1] + $p[3] + 2;
			return "$x,$y";
		    }
		},
	       -motioncommand   => sub {
		    my $x = $text->pointerx - $text->rootx;
		    my $y = $text->pointery - $text->rooty;
		    @wIdx = ($text->index("\@$x,$y wordstart"),
			$text->index("\@$x,$y wordend"));
		    if ($wIdx[0] eq $lIdx[0] and $wIdx[1] eq $lIdx[1]) {
			# Same word - dont cancel the balloon.
			return 0;
		    } else {
			# New word under mouse
			# cancel it so a new balloon will be posted.
			$text->SelectionClear;
			@lIdx = @wIdx;
			return 1;
		    }
		},
	    );
	    $balloonAttached = 1;
	}

	####################################################################
	# change text on scan button to 'Edit'
	####################################################################

	$scanButton->configure(-text => 'Edit');
	$text->configure(-state => 'disabled');
	$scanFlag = 1;		# scan successful
    } else {
	$info = "";
	connect_to_server();	# will call scan() if connect was successful
    }
}

########################################################################
#
#	clearScan
#	detach balloon processing
#	prepare for scan
#	clear active symbols for faster processing of connected controller
#
########################################################################

sub clearScan {
    if ($balloonAttached) {
	$balloon->detach($text);
	$balloonAttached = 0;
    }
    $scanButton->configure(-text => 'Live');
    $scanFlag = 0;		# text has been cleared of all tags
    return if @_;		# called from disconnect
    $info = "";
    $conn->send_now("$unitID.4") if $conn;	# clear active symbols
}

########################################################################
#
#	check if a file has been modified and needs to be saved
#
#	IF contents has changed AND Button 'Yes' is pressed
#		saves $filename
#		changes entry box text to $filename if successful
#	ELSE does nothing
#	no regex matches allowed for make_file()
#
########################################################################

sub check_save {
    my $ret = 1;
    my $contents = $text->get("1.0", "end - 1 chars");
    if ($contents ne $oldContents) {
	my $oldText = $search_text;
	$search_text = $filename;
	my $dialog = $text->Dialog (-title   => 'Modified file',
				    -bitmap  => 'question',
				    -text    => 'Save previous modified file?',
				    -buttons => [qw(Yes No Cancel)],
				   );
	my $answer = $dialog->Show();
	if ($answer eq 'Cancel') {
	    $ret = 0;			# cancel operation
	} elsif ($answer eq 'Yes') {
	    $ret = save_file(1);	# save previous modified file
	}
	$search_text = $oldText if $ret;
    }
    return $ret;
}

########################################################################
#
#	new_text clears the text area
#
########################################################################

sub new_text {
    deleteAllTags();	# also clears @activeSymbols
    clearScan();
    if (check_save()) {
	$text->delete("1.0", "end");
	$oldContents = $search_text = $filename = '';
	$mainWindow->title("iClive");
    }
}

########################################################################
#
#	load_file checks to see what the filename is and loads it if possible
#	optional paramater:	1	load unconditionally
#
########################################################################

sub load_file {
    if ($search_text) {
	my ($unconditional) = @_;	# optional paramater
	deleteAllTags();	# also clears @activeSymbols
	clearScan();
	if ($unconditional or check_save()) {
	    my $oldname = $filename;
	    if ($search_text =~ /^\w+(\.\w+)?/) {
		$filename = $search_text;
	    } elsif ($errorname) {
		$filename = $errorname;
		$errorname = '';
	    }
	    stat($filename);
	    if (-f _ and -r _) {
		$text->Load($filename);
		$oldContents = $text->get("1.0", "end - 1 chars");
		$mainWindow->title("iClive $filename");
		$infoBar->configure(-foreground => 'black');
		$info = "File '$filename' loaded";
	    } else {
		$infoBar->configure(-foreground => 'red');
		$info = "ERROR: Could not open $filename"; 
		$search_text = $filename = $oldname;	# restore filename
	    }
	    $prev_text = '';	# start a new search
	}
    } else {
	$infoBar->configure(-foreground => 'red');
	$info = "Enter a filename in the Search Box"; 
    }
}

########################################################################
#
#	save_file saves the file previously loaded or last saved
#	optional paramater:	1	save unconditionally
#
########################################################################

sub save_file {
    my $ret = 1;
    if ($filename) {
	my ($save) = @_;	# optional paramater
	deleteAllTags();	# also clears @activeSymbols
	clearScan();	# take away all live text
	my $contents = $text->get("1.0", "end - 1 chars");
	if ($save or $contents ne $oldContents) {
	    if (open(FH, ">$filename")) {
		$oldContents = $contents;
		my $length = length $oldContents;
		print FH $oldContents;
		close (FH);
		$mainWindow->title("iClive $filename");
		$infoBar->configure(-foreground => 'black');
		$info = "File '$filename', '$length' bytes saved";
	    } else {
		$infoBar->configure(-foreground => 'red');
		$info = "ERROR: Could not open '$filename' for writing"; 
		$ret = 0;
	    }
	} else {
	    $infoBar->configure(-foreground => 'blue');
	    $info = "FILE '$filename' has not changed - not written"; 
	}
    } elsif ($search_text) {
	$ret = saveAs_file();
    } else {
	$infoBar->configure(-foreground => 'red');
	$info = "Save unnamed modified text first"; 
	$ret = 0;
    }
    $search_text = $filename if $ret;
    return $ret;
}

########################################################################
#
#	saveAs_file saves the file using the filename in the entry box
#
########################################################################

sub saveAs_file {
    my $ret = 1;
    if ($search_text) {
	my $oldname = $filename;
	$filename = $search_text;
	if (save_file($filename ne $oldname) == 0) {
	    $filename = $oldname;	# restore filename
	    $mainWindow->title("iClive $filename");
	}
    } else {
	$infoBar->configure(-foreground => 'red');
	$info = "Enter a filename in the Search Box"; 
	$ret = 0;
    }
    return $ret;
}

########################################################################
#
#	Make a target file generated from $filename (C file or executable)
#	check if $filename is an iC source (*.ic) and needs saving
#	generate a new target file if target is older than $filename
#
#	2nd parameter:	1   Make C file
#			0   Make executable
#
########################################################################

sub make_file {
    my $cFlag = $_[1];		# make C file if true
    if ($filename =~ /(\w+)\.lst6?/) {
	$search_text = "$1.ic";	# listing should never be modified
	load_file(1);		# load the corresponding iC source unconditionally
    } else {
	deleteAllTags();	# also clears @activeSymbols
	clearScan();
    }
    if ($filename !~ /(\w+)\.ic/) {
	$infoBar->configure(-foreground => 'blue');
	$info = "WARNING: cannot make '$filename' (must end in .ic)"; 
    } elsif (check_save()) {	# make sure check_save() has no regex matches
	my $baseName = $1;	# so that $1 is valid
	my $targetName = $cFlag ? "$baseName.c" : $baseName;
	my $ftime = (stat($filename))[9];
	my $mtime = (stat($targetName))[9];
	my $ret = 0;
	$errorname = '';
	if ($mtime < $ftime) {
	    my @args = ("iCmake", $filename);
	    if ($cFlag) {
		splice(@args, 1, 0, '-b');	# iCmake -b to suppress making executable
	    }
	    print "system @args\n" if $opt_t;
	    $ret = system(@args) >> 8;
	    if ($ret) {
		$errorname = $filename;
		$search_text = "$baseName.lst";
		load_file();		# load the listing file (iC is up to date)
		$search_text = '^\*\*\* ';	# regular expression to find errors in listing
		$prev_text = '';		# start a new search
		$match_type = '-regexp';
		search();			# carry out the search setting markers
		$infoBar->configure(-foreground => 'red');
		$info = "ERROR: '$targetName' cannot be made from '$errorname' (return = $ret)"; 
	    } else {
		$infoBar->configure(-foreground => 'blue');
		$info = "'$targetName' successfully made"; 
	    }
	} else {
	    $infoBar->configure(-foreground => 'blue');
	    $info = "'$targetName' is up to date"; 
	}
    } # ELSE operation was cancelled by check_save()
}

########################################################################
#
#	run the executable file generated from $filename
#	check if $filename is an iC source (*.ic) and needs saving
#	generate name of executable file from $filename
#	run executable if it exists, is executable and newer than source
#
########################################################################

sub run_file {
    if ($runFlag) {
	stop_file();	# $runFlag = 0
    } elsif ($conn and $iCname) {
	$infoBar->configure(-foreground => 'red');
	$info = "$unitID is connected to '$iCname' (Stop it to run '$filename')";
    } elsif ($filename !~ /(\w+)\.ic/) {
	$infoBar->configure(-foreground => 'blue');
	$info = "WARNING: cannot run '$filename' (must end in .ic)"; 
    } elsif (check_save()) {
	deleteAllTags();	# also clears @activeSymbols
	clearScan();
	my $processName = $1;
	my $ftime = (stat($filename))[9];
	my $mtime = (stat($processName))[9];
	if (not -f _) {
	    $infoBar->configure(-foreground => 'red');
	    $info = "ERROR: no file named '$processName' (Make it first)"; 
	} elsif (not -x _) {
	    $infoBar->configure(-foreground => 'red');
	    $info = "ERROR: '$processName' not executable ??"; 
	} elsif ($mtime < $ftime) {
	    $infoBar->configure(-foreground => 'blue');
	    $info = "WARNING: '$processName' is older than '$filename' (Make again)"; 
	} else {
	    my $pid;
	    FORK: {
		if ($pid = fork) {
		    # parent process
		    scan();	# make connection with the new control program
		} elsif (defined $pid) {	# $pid is zero if defined
		    # dispatch child process
		    my @call = ($processName);
		    splice @call, 1, 0, '-p', $opt_p if defined $opt_p;
		    splice @call, 1, 0, '-t' if defined $opt_t;
		    splice @call, 1, 0, '-m' if defined $opt_m;
		    print "@call\n";
		    exec @call;
		} elsif ($! =~ /No more process/) {
		    # EAGAIN, recoverable fork error
		    sleep 5;
		    redo FORK;
		} else {
		    # weird fork error
		    die "Can't fork: $!\n";
		}
	    }
	}
    } # ELSE operation was cancelled by check_save()
}

########################################################################
#
#	stop file after checking if file needs saving
#
########################################################################

sub stop_file {
    if ($conn and $iCname) {
	deleteAllTags();	# also clears @activeSymbols
	clearScan();
	$conn->send_now("$unitID.5");	# stop control program
    } else {
	$infoBar->configure(-foreground => 'red');
	$info = "$unitID is not connected to a control program";
    }
}

########################################################################
#
#	quit program after checking if file needs saving
#
########################################################################

sub quit_program {
    deleteAllTags();	# also clears @activeSymbols
    clearScan();
    if (check_save()) {
	exit(0);
    }
}
#ifdef TIME_HIRES 

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    my $ti = tv_interval $t0, [gettimeofday];
    printf "%10.6f%s", $ti, $opt_t ? ": " : "\n";
    $t0 = [gettimeofday];
}
#endif
