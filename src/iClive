#!/usr/bin/perl -P

########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	iClive display for iC sources and listings
#
#	iClive provides an edit window in which the text of a source
#	or listing can be displayed and optionally edited and saved.
#
#	iClive is normally a client of a running iC program. On startup
#	it requests the symbol table of the running program. It returns
#	a list of words from the symbol table on which it wants live
#	updates of the state of the nodes, named by each word in the
#	list. The running program then provides updates when the state
#	of any node from the list changes as soon as possible after the
#	change.
#
#	All words in the text which exactly match any token in the list
#	are marked with a colour depending on the current state of the
#	node - usually green for 0 and red for 1. These are called 'active'
#	words. Active words in the list which are preceded by ~ or ! or
#	which are followed by ~ show the inverse state of the node.
#
#	When the mouse cursor sits on an active word the value of the
#	node is displayed in a subwindow. This is useful for displaying
#	the current value of arithmetic nodes.
#
#	To be effective, the displayed text must be either the source of
#	the running iC program or a text derived from that source, such
#	as the iC listing. iClive then shows the logical statements of
#	the source and the colours will show what the current state is.
#	It is then easy to inspect the listing and relate states with
#	the logic.
#
#	For measuring reaction times the Module Time::HiRes may be used.
#	This activates the -m option.
#	Make sure you have downloaded and installed Time::HiRes from CPAN
#	Uncomment the C++ comment in the next line
#//define TIME_HIRES
#
########################################################################

use Tk;					# Slurp the module in
use Msg;
use Tk::Balloon;
use strict;
#ifdef TIME_HIRES 
use Time::HiRes qw(sleep gettimeofday tv_interval);
my $t0 = [gettimeofday];	# start of program
my %delayedColour;	# colour that should be restored after a flash
#endif

########################################################################
#
#	Colour selection for background/foreground and false/true
#	$colourSelect[ftype] must match the definitions in 'icc.h'
#	Different ftypes select the 'cs' index to select four colours.
#	The last bit of cs selects the false/true colours.
#	The ftype INV_ALIAS has an odd 'cs' which inverts the colours.
#
#	To display clocks and glitches, the foreground is flashed white
#	for 50 milliseconds. Flashing the background looks confusing.
#
########################################################################

my @colourSelect  = ( 0,2,0,2,2,2,0,0,0,0,0,0,0,2,0,4,6,  # cs[ftype] 0 - 16
			2,0,1,0,0,0,0,0,0,0,0,0,0,0,4,6,  # ALIAS    17 - 32
		    );

#  live colouring     false 0          true 1             cs  ftype
my @tagBackground = ('PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
							# cs|010 no change
		     'PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
		    );
my @tagForeground = ('black'        , 'red'          ,  # 0 1 GATE
		     'black'        , 'red'          ,  # 2 3 ARITH
		     'black'        , 'white'        ,  # 4 5 CLCKL
		     'black'        , 'white'        ,  # 6 7 TIMRL
							# cs|010 flash glitch
		     'white'        , 'white'        ,  # 0 1 GATE
		     'white'        , 'white'        ,  # 2 3 ARITH
		     'white'        , 'black'        ,  # 4 5 CLCKL
		     'white'        , 'black'        ,  # 6 7 TIMRL
		    );

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
@<<<<<<< [-tmh] [-s <host>] [-p <port>] [-f <font>] [file ...]
	$named
	-s host	host name of server    (default 'localhost')
	-p port	service port of server (default '8778')
	-f font	font to use in Text window (default '9x15')
	-t	trace run time changes
	-T	trace static debug messages
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-h	help, ouput this Usage text only
Copyright (C) 2000-2001  John E. Wulff		<john.wulff@inka.de>
							  '@'
$Id: iClive,v 1.15 2001/04/15 06:38:08 jw Exp $
.

use vars qw($opt_T $opt_t $opt_m $opt_s $opt_p $opt_f $opt_h);
require "getopts.pl";
&Getopts('tTms:p:f:h');		# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

########################################################################
#
#	Initialize global variables
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $font = defined $opt_f ? $opt_f : '9x15';
my $unitID = 'L0';
my %symbolTable = ();	# $symbolTable{$symbol} [0, 1]   = ($ftype, $index)
my @activeSymbols;	# $activeSymbols[$index][0 .. 3] = ($ts,$val,$cs,[$sec,$usec])
my $stIndex = 0;
my $conn;

my $info = '';
my $iCname = '';
my $filename = '';

$filename = $ARGV[0] unless @ARGV < 1;

########################################################################
#
#	Create main window and menus
#
########################################################################

my $mainWindow = MainWindow->new();
$mainWindow->title("iClive");

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack('-side' => 'top', '-fill' => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton('-text' => 'File',
				    '-relief' => 'raised',
				    '-borderwidth' => 2,
				   )->pack('-side' => 'left',
					   '-padx' => 2,
					  );
$menuFile->command('-label' => 'New',  '-command' => \&new_text);
$menuFile->command('-label' => 'Load', '-command' => \&load_file);
$menuFile->command('-label' => 'Save', '-command' => \&save_file);
$menuFile->separator();
$menuFile->command('-label' => 'Quit', '-command' => sub { exit(0); } );

########################################################################
#	Scan or Clear button
########################################################################
my $scanButton = $menuBar->Button('-text'        => 'Scan',
				  '-relief'      => 'raised',
				  '-borderwidth' => 2,
				  '-command'     => \&scan,
			         )->pack('-side' => 'left',
				         '-padx' => 2,
				        );
my $scanFlag = 0;		# text is initially cleared

########################################################################
#	Search menu 
########################################################################
my $search_mb = $menuBar->Menubutton('-text'         => 'Search',
				     '-relief'       => 'raised',
				     '-borderwidth'  => 2,
				     )->pack('-side' => 'left',
					     '-padx' => 2
					    );
my $match_type = "-exact";	# default, alternatives -nocase -regexp
$search_mb->separator();
########################################################################
#	Exact match
########################################################################
$search_mb->radiobutton('-label'    => 'Exact match',
			'-value'    => '-exact',
			'-variable' => \$match_type);
########################################################################
#	Ignore case
########################################################################
$search_mb->radiobutton('-label'    => 'Ignore case',
			'-value'    => '-nocase',
			'-variable' => \$match_type);
########################################################################
#	Regexp match
########################################################################
$search_mb->radiobutton('-label'    => 'Regexp match',
			'-value'    => '-regexp',
			'-variable' => \$match_type);
########################################################################
#	Regexp match - Ignore case
########################################################################
$search_mb->radiobutton('-label'    => 'Regexp Ignore case',
			'-value'    => 'rn',
			'-variable' => \$match_type);
$search_mb->separator();

########################################################################
#	Search entry
########################################################################
my $search = $menuBar->Entry('-width' => 20,
			        )->pack('-side' => 'left',
				        '-padx' => 2,
				       );
$search->bind('<KeyPress-Return>', [ \&search, 1 ]);		# scroll down
$search->bind('<Shift-KeyPress-Return>', [ \&search, -1 ]);	# scroll up

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
		   -relief => 'ridge',
		  )->pack(-side => 'bottom',
		  	  -fill => 'x',
		         );

########################################################################
#	Text window
########################################################################
my $text = $mainWindow->Scrolled('Text',
		                 -scrollbars => 'osoe',
		                 -background => 'cornsilk1',
		                 -wrap       => 'none',
		                 -font       => $font,
		                )->pack(-fill   => 'both',
			                -expand => 1,
			               );

########################################################################
#	Balloon widget
########################################################################
my $balloon = $mainWindow->Balloon(-statusbar => $infoBar);
my $balloonAttached = 0;
$mainWindow->OnDestroy(sub { $balloon->destroy; });

########################################################################
#	Open the first file in the argument list
########################################################################

load_file() if $filename;

########################################################################
#	Connect to iCserver
########################################################################

connect_to_server();

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################

MainLoop;

########################################################################
#
#	Connect to iCserver
#	Register read events
#	Register I/O at iCserver and request Symbol Table
#
########################################################################

sub connect_to_server {
    $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
    if ($conn) {
	print "Connection $unitID at client.\n";
	$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });
	$conn->send_now($unitID);	# register I/O
	%symbolTable = ();
	$conn->send_now("$unitID.1");	# request Symbol Table
    } else {
	$infoBar->configure(-foreground => 'red');
	$info = "Could not connect to $host:$port - no live listing - edit only";
    }
}

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occurr if $conn and read events registered)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
#ifdef TIME_HIRES 
    printMicroSeconds() if $opt_m;
#endif
    if (defined $msg) {
	if (length $msg == 0) {
	    $rConn->disconnect();
	    $infoBar->configure(-foreground => 'red');
	    $info = $iCname ?
		"$unitID disconnected from '$iCname' by server" :
		"$unitID not connected to a control program";
	    deleteAllTags();	# also clears @activeSymbols
	    %symbolTable = ();	# clear symbol table so balloons dont show
	    undef $iCname;
	    undef $conn;
	    clearScan(1);	# detach balloon
	} else {
	    print "$msg\n" if $opt_t;
	    my @symbols = split /;/, $msg;	# break up message
	    my $entry = shift @symbols;		# first entry is an operation
	    if ($entry =~ /$unitID\.(\d+)/) {
		if (($entry = $1) eq '1') {
		    ####################################################
		    # Symbol Table block
		    # Symbol table entries consist of two or three words.
		    # Usually symbol-id and ftype are received. In this
		    # case the ST-offset is the index. (computed by counting)
		    # For ALIASes the index of the Gate to which the
		    # ALIAS resolves is transmitted as a 3rd value.
		    ####################################################
		    while ($entry = shift @symbols) {
			my ($symbol, $ftype, $index) = split " ", $entry;
			$index = $stIndex unless defined $index;
			print "$index\t$symbol\t$ftype\n" if $opt_T;
			@{ $symbolTable{$symbol} } = ($ftype, $index);
			$stIndex++;
		    }
		} elsif ($entry eq '2') {
		    ####################################################
		    # End of Symbol Table
		    # The 2nd entry is the name of the running iC program.
		    # This name allows a check against the file name of
		    # the displayed text. (Assume it should match)
		    ####################################################
		    $iCname = shift @symbols;
		    $stIndex = 0;		# ready for next reception
		    scan();
		} elsif ($entry eq '3') {
		    ####################################################
		    # New data values
		    # Data value entries consist of ST-index and value
		    ####################################################
		    while ($entry = shift @symbols) {
			my ($index, $value) = split " ", $entry;
#ifdef TIME_HIRES 
			my $tNew;
			my ($cs, $tOld) = @{ $activeSymbols[$index] }[2, 3];
			$activeSymbols[$index][3] = $tNew = [gettimeofday];
			my $tRest = 50 - int(tv_interval($tOld, $tNew) * 1000);	# ms.
# print "index: $index value: $value rest: $tRest\n";
#else
			my $cs = $activeSymbols[$index][2];
#endif
			$cs ^= 1 if $value;			# change colour
			$activeSymbols[$index][1] = $value;	# for value display
			if ($activeSymbols[$index][0] & 01) {
#ifdef TIME_HIRES 
			    if ($tRest < 10) {
				colourTag("$index", $cs);	# normal colour
			    } else {
				colourTag("$index", $cs | 010);	# flash glitch
				# delay the colour change to make it visible
				$text->after(50, [ \&restoreTag, "$index" ]);
			    }
#else
			    colourTag("$index", $cs);		# normal colour
#endif
			    if ($cs == 5 or $cs == 7) {	# hi CLOCK or TIMER
				# turn colour off after 50 ms.
				$text->after(50, [ \&colourTag, "$index", $cs & ~01 ]);
			    }
			}
			if ($activeSymbols[$index][0] & 02) {
#ifdef TIME_HIRES 
			    $cs ^= 1;				# complement colour
			    if ($tRest < 10) {
				colourTag("$index~", $cs);	# latest $cs is saved
			    } else {
				colourTag("$index~", $cs | 010);# flash glitch
				# delay the colour change to make it visible
				$text->after(50, [ \&restoreTag, "$index~" ]);
			    }
#else
			    colourTag("$index~", $cs ^ 1);	# complement colour
#endif
			}
			if ($activeSymbols[$index][0] & 04) {
			    my $tag = "$index=";
			    my @ranges = $text->tagRanges($tag);
# print "value at index $index: $activeSymbols[$index][1] '@ranges'\n";
			    for (my $i = 0; $i < @ranges; $i += 2) {
				my ($beg, $end) = @ranges[$i, $i+1];
				$text->delete($beg, $end);
				$text->insert($beg, " $value", $tag);
			    }
			}
#ifdef TIME_HIRES 
			printMicroSeconds() if $opt_m;
#endif
			print "$index	$value\n" if $opt_t;
		    }
		} else {
		    goto Spurious;
		}
	    } else {
		Spurious: print "Spurious operation '$entry' for $unitID ???\n";
	    }
	}
    }
}

########################################################################
#
#	Change the tag colours
#
########################################################################

sub colourTag {
    my ($tag, $cs) = @_;
# print "colourTag: $tag $cs\n";
    $text->tagConfigure($tag,
			'-background' => $tagBackground[$cs], 
			'-foreground' => $tagForeground[$cs],
		       );
#ifdef TIME_HIRES 
    $delayedColour{$tag} = $cs;		# save colour for end of flash
}

########################################################################
#
#	Restore the tag colour after a flash
#
#	If the value in %delayedColour were not used, another change
#	before the 50 ms flash is finished may come in and the end of
#	flash will then restore to the second last change. Now the
#	colour is saved in &colourTag and the end of the flash will
#	restore the very latest change.
#
########################################################################

sub restoreTag {
    my ($tag) = @_;
    my $cs = $delayedColour{$tag} & 07;	# latest colour ignoring flash
# print "restoreTag: $tag $cs\n";
    $text->tagConfigure($tag,
			'-background' => $tagBackground[$cs], 
			'-foreground' => $tagForeground[$cs],
		       );
#endif
}

########################################################################
#
#	Search for a regular expression or exact match
#
########################################################################

my ($prev_pattern, $prev_match, @lines, $si);	# has to be global, 'our' not portable yet

sub search {
    my $sd = $_[1];			# scroll direction
    my ($search_pattern, $auxiliary, $current, $length, $i);
    $search_pattern = $search->get();
    if ($prev_pattern ne $search_pattern or $prev_match ne $match_type) {
	print "pattern: '$search_pattern' '$prev_pattern'\n" if $opt_T;
	$si = -1;			# see index
	@lines = ();
	$text->tagDelete('searchTag') if $prev_pattern;
	$text->tagConfigure('searchTag',
			    '-background' => 'gray', 
			   );
	if ($match_type eq 'rn') {
	    $match_type = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';	# fill as placeholder
	}
	$current = '1.0';
	$length = '0';
	while (1) {
	    eval {
		$current = $text->search('-count' => \$length,
				     $match_type, 
				     $auxiliary,
				     '--',
				     $search_pattern,
				     $current,
				     'end',
				    );
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		$infoBar->configure(-foreground => 'red');
		$info = "ERROR: $@";		# error in search - report in info bar
		last;
	    }
	    last unless $current and $length;
	    my @lineinfo = $text->dlineinfo($current);
	    if ($opt_T) {
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length '@lineinfo'\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    push @lines, $current;
	    $current = $text->index("$current + $length char");
	}
	$match_type = 'rn' if $auxiliary eq '-nocase';	# otherwise radio button skips
	$prev_pattern = $search_pattern;
	$prev_match = $match_type;
    }
    if ($i = @lines) {
	if ($si == -1) {
	    $infoBar->configure(-foreground => 'black');
	    $info = "/$search_pattern/ found $i times";
	    $i = 0;
	    $text->see($lines[$i]);
	} else {
	    for ($i = $si + $sd;
		($i = $i > $#lines ? 0 : $i < 0 ? $#lines : $i) != $si;
		$i += $sd) {
		$current = $lines[$i];
		unless ($text->dlineinfo($current)) {
		    $text->see($lines[$i]);	# this line was previously invisible
		    last;
		} else {
		    print "loop: $i $sd '$lines[$i]'\n" if $opt_T;
		}
	    }
	}
	print "see:  $i $sd '$lines[$i]' '$#lines'\n" if $opt_T and $i != $si;
	$si = $i;
    } elsif ($si == -1 and not $@) {
	$infoBar->configure(-foreground => 'red');
	$info = $search_pattern ? "/$search_pattern/ not found" : "";
	$si = 0;
    }
}

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    foreach my $index (0 .. $#activeSymbols) {
	my $ts = $activeSymbols[$index][0];
	if ($ts) {
	    if ($opt_T) {
		print(" $index")    if $ts & 01;	# normal
		print(" $index~")   if $ts & 02;	# inverted
		print(" $index=")   if $ts & 04;	# value
		print(" deleted\n");
	    }
	    if ($ts & 01) {
		$text->tagDelete("$index");
	    }
	    if ($ts & 02) {
		$text->tagDelete("$index~");
	    }
	    if ($ts & 04) {
		my $tag = "$index=";
		my @ranges = $text->tagRanges($tag);
		for (my $i = 0; $i < @ranges; $i += 2) {
		    $text->delete(@ranges[$i, $i+1]);
		}
		$text->tagDelete($tag);
	    }
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
}

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found and another for the inverted symbol, if required.
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program. Further updates occur, every time the
#	state of an active symbol changes.
#
#	Attach the balloon processing while display is live.
#	Balloon processing is detached for newly loaded file to allow
#	clean editing.
#
########################################################################

my $bMsg = '';
my $sMsg = '';
my @wIdx = ('', '');  # Indices surrounding the current word.
my @lIdx = ('', '');  # Same for last word.

sub scan {
    my ($search_pattern, $current, $word, $i, $iw, $tag, $cs, $ts, $ftype, $index);

    deleteAllTags();	# also clears @activeSymbols

    if ($scanFlag) {
	clearScan();	# $scanFlag = 0
    } else {
	if ($conn) {
	    if ($filename =~ /$iCname/) {
		$mainWindow->title("iClive $filename $iCname");
	    } else {
		$infoBar->configure(-foreground => 'red');
		$info = "WARNING: '$filename' does not match connected control program '$iCname'"; 
	    }

	    $search_pattern = '[~\s]*[A-Z_a-z][\w]*(\.\w+)?\s*((~ )?---|=$)?';
	    $current = '1.0'; my $length = '0';
	    while (1) {
		$current = $text->search('-count' => \$length,
					 '-regexp', 
					 '--',
					 $search_pattern,
					 $current,
					 'end');
		last if (!$current);
		$iw = $i = $text->get($current, "$current + $length char");
		$i =~ s/([~\t ]*)([\w.]+)([~\t ]*)/$1$3/;
		if ($symbolTable{$2}) {
		    ($ftype, $index) = @{ $symbolTable{$2} };
		    if (defined $index and $ftype) {
			$tag = $index;
			$word = $2;			# word is in the symbol table
			$cs = $colourSelect[$ftype]; # initial colour with ALIAS inv
#ifdef TIME_HIRES 
			@{ $activeSymbols[$index] }[1 .. 3] = (0, $cs & ~01, [gettimeofday]);
#else
			@{ $activeSymbols[$index] }[1, 2] = (0, $cs & ~01);	# clear inv
#endif
			while ($i =~ m/~/g) {
			    $cs ^= 1;		# complement initial colour selection
			}
			$tag .= '~' if ($ts = $cs & 01); # adjust tag name if inverted
			$ts++;			# convert to a mask 0 => 01, 1 => 02
			print "$tag	$word	'$iw'\n" if $opt_T;
			unless ($activeSymbols[$index][0] & $ts) {
			    $activeSymbols[$index][0] |= $ts; # 01|02 leaves 03 for both
			    colourTag($tag, $cs);	# initial tag colour
			}
			$text->tagAdd($tag, $current, "$current + $length char");
			if ($iw =~ /[\w.]+\s*=$/) {
			    $tag = "$index=";
			    print "$tag	$word	'$iw'\n" if $opt_T;
			    unless ($activeSymbols[$index][0] & 04) {
				$activeSymbols[$index][0] |= 04; # for analog value display
				colourTag($tag, 2);	# ARITH tag colour never changed
			    }
			    $text->insert("$current lineend", " 0", $tag);
			}
		    } else {
			$infoBar->configure(-foreground => 'CadetBlue');
			$info = "SYSTEM WARNING: \$symbolTable{$2} $symbolTable{$2}[ '$index' , '$ftype' ]";
		    }
		}
		$current = $text->index("$current + $length char");
	    }

	    ####################################################################
	    # Send list of active symbols to the iC control process. Only the
	    # state (logic or arithmetic) for the symbols in this list need to
	    # be updated for this display, since the others are not displayed.
	    # It is immaterial for the control program in which logic
	    # sense the symbol is displayed, except for inverted ALIASes.
	    ####################################################################

	    my $msg = "";
	    foreach $index (0 .. $#activeSymbols) {
		if ($activeSymbols[$index][0]) {
		    print "$index\n" if $opt_T;
		    if (length $msg > 391) {		# REPLY - 9 in icc.h
			$conn->send_now("$unitID.3$msg");	# intermediate active symbols
			$msg = "";
		    }
		    $msg .= ";$index";
		}
	    }
	    $conn->send_now("$unitID.4$msg");		# send last active symbols

	    unless ($balloonAttached) {
		$balloon->attach($text,
		   -balloonmsg      => \$bMsg,
		   -statusmsg       => \$sMsg,
		   -balloonposition => 'mouse', # not used since postcommand returns real position
		   -postcommand  => sub
			{
			    if ($wIdx[0] eq $wIdx[1]) {
				# No word under mouse - dont post the balloon
				return 0;
			    } else {
				my ($ftype, $index, $val);
				# Have a word under mouse - change the message:
				my $word = $text->get($wIdx[0], $wIdx[1]);
				# Skip if it contains non-word chars
				# or is not in Symbol Table
				return 0 if $word =~ /\W/;
				while (not defined ($index = $symbolTable{$word}[1])) {
				    # Try if I/O like IX0.0 QX10.7 or TX0.0_14
				    return 0 if $word !~ /^[IQT]X\d+$/;
				    $word = $text->get($wIdx[0], "$wIdx[1] lineend");
				    $word =~ s/^([IQT]X\d+\.\d(_\d+)?).*$/$1/;
				}
				$ftype = $symbolTable{$word}[0];
				$val = $activeSymbols[$index][1];
				$val ^= 1 if $colourSelect[$ftype] & 01; # inv ALIAS
				$bMsg = "$val";
				$sMsg = "$word: $val";
				$text->tag('add', 'sel', $wIdx[0] => $wIdx[1]);
				# Find a good place to put the balloon
				# right below the last char in the word
				my $i = $text->index("$wIdx[1] - 1 chars");
				my @p = $text->bbox($i);
				my $x = $text->rootx + $p[0] + $p[2] - 4;
				my $y = $text->rooty + $p[1] + $p[3] + 2;
				return "$x,$y";
			    }
			},
		   -motioncommand => sub
			{
			    my $x = $text->pointerx - $text->rootx;
			    my $y = $text->pointery - $text->rooty;
			    @wIdx = ($text->index("\@$x,$y wordstart"),
				$text->index("\@$x,$y wordend"));
			    if ($wIdx[0] eq $lIdx[0] and $wIdx[1] eq $lIdx[1]) {
				# Same word - dont cancel the balloon.
				return 0;
			    } else {
				# New word under mouse
				# cancel it so a new balloon will be posted.
				$text->SelectionClear;
				@lIdx = @wIdx;
				return 1;
			    }
			},
		);
		$balloonAttached = 1;
	    }
	    $scanButton->configure(-text => "Clear");
	    $scanFlag = 1;		# scan successful
	} else {
	    $info = "";
	    connect_to_server();	# will call scan() if connect was successful
	}
    }
}

########################################################################
#
#	clearScan
#	prepare for scan
#	clear active symbols for faster processing of connected controller
#
########################################################################

sub clearScan {
    if ($balloonAttached) {
	$balloon->detach($text);
	$balloonAttached = 0;
    }
    $scanButton->configure(-text => "Scan");
    $scanFlag = 0;		# text has been cleared of all tags
    return if @_;		# called from disconnect
    $info = "";
    $conn->send_now("$unitID.4") if $conn;	# clear active symbols
}

########################################################################
#
#	new_text clears the text area
#
########################################################################

sub new_text {
    deleteAllTags();	# also clears @activeSymbols
    clearScan();
    $text->delete("1.0", "end");
}

########################################################################
#
#	load_file checks to see what the filename is and loads it if possible
#
########################################################################

sub load_file {
    my $newname = $search->get();
    if ($newname) {
	$filename = $newname;
    }
    unless (open(FH, "$filename")) {
	$infoBar->configure(-foreground => 'red');
	$info = "ERROR: Could not open $filename"; 
	return; 
    }
    new_text();				# clear the text area
    my $length = 0;
    while (<FH>) {
	$length += length $_;
	$text->insert("end", $_);
    }
    close (FH);
    $mainWindow->title("iClive $filename");
    if ($newname and $filename !~ /$iCname/) {
	$infoBar->configure(-foreground => 'red');
	$info = $iCname ?
	    "WARNING: '$filename' does not match connected control program '$iCname'" :
	    "$unitID not connected to a control program";
    } else {
	$infoBar->configure(-foreground => 'black');
	$info = "File '$filename', '$length' bytes loaded";
    }
    $prev_pattern = '';			# start a new search
}

########################################################################
#
#	save_file saves the file using the filename in the entry box
#
########################################################################

sub save_file {
    deleteAllTags();	# also clears @activeSymbols
    clearScan();	# take away all live text
    unless (open(FH, ">$filename")) {
	$infoBar->configure(-foreground => 'red');
	$info = "ERROR: Could not open $filename for writing"; 
	return; 
    }
    my $contents = $text->get("1.0", "end - 1 chars");
    my $length = length $contents;
    print FH $contents;
    close (FH);
    $infoBar->configure(-foreground => 'black');
    $info = "File '$filename', '$length' bytes saved";
}
#ifdef TIME_HIRES 

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    my $ti = tv_interval $t0, [gettimeofday];
    printf "%10.6f%s", $ti, $opt_t ? ": " : "\n";
    $t0 = [gettimeofday];
}
#endif
