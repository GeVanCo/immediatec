#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2016  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iClive; display for iC sources and listings
#
#	A full description is in the POD documentation at the end
#
#	For measuring reaction times the Module Time::HiRes is used.
#	This is activated by the -m option.
#	Make sure you have installed Time::HiRes
#
########################################################################

use Tk;			# The graphical user interface toolkit perl/Tk
			##                   by Nick Ing-Simmons
use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use Tk::Balloon;
use Tk::Dialog;
use Cwd;
use strict;
use warnings;
use Time::HiRes qw(sleep gettimeofday tv_interval);
my $t0 = [gettimeofday()];	# start time of program
my %delayedColour;	# colour that should be restored after a flash
my $shift_control_state = 0;
my @argv = ();

########################################################################
#
#	Colour selection for background/foreground and false/true
#	$colourSelect[ftype] must match the definitions in 'icg.h'
#	Different ftypes select the 'cs' index to select four colours.
#	The last bit of cs selects the false/true colours.
#	ALIAS ftype's are generated by adding MAX_FTY (22) to ftype.
#	ftype MAX_FTY+GATE+INV has an odd 'cs' which inverts the colours.
#	Allow for GATE as well as GATEX by making INV (inversion << 1).
#
#	To display clocks and glitches, the foreground is flashed white
#	for 50 milliseconds. Flashing the background looks confusing.
#	Uses Tk::After. Flash 2 clocks in a row white. This happens if
#	CLOCK or TIMER has 2 slave gates which are fired together.
#
#	the following 2 arrays are indexed by gt_fni is ftype (see icc.h)
#
#	UDFA	ARITH	GATE	GATEX	RI_BIT	S_SH	R_SH	D_SH	0-8
#	CH_BIT	S_FF	R_FF	D_FF	CH_AR	F_SW	F_CF	F_CE	9-15
#	CLCK	TIMR	TRAB	OUTW	OUTX	CLCKL	TIMRL	F_ERR	16-23
#	MAX_FTY	+ARITH	+GATE	+GATEX	+GATE+INV  ...	+CLCKL	+TIMRL	23-28...44-45
#
#	ftype-abbreviations are used for debugging to list the Symbol Table.
#	They are also indexed by gt_fni (holds ftype). (lines up with FOPS in icc.h)
#
## #define	FOPS	"UA _EsrHVSRDvIFGCTBWX:!e"	/* DEBUG display of ftypes */
#
## list of ftypes fromm icc.h
## #define	FULL_FTYPE
#	"UDFA","ARITH","GATE","GATEX","RI_BIT","S_SH","R_SH","D_SH",
#	"CH_BIT","S_FF","R_FF","D_FF","CH_AR","F_SW","F_CF","F_CE","CLCK","TIMR",
#	"TRAB","OUTW","OUTX","CLCKL","TIMRL","F_ERR",
#
########################################################################

my @abbrevSelect  = ( 'U','A',' ','_','E','s','r','H','V','S','R','D','v','I','F','G',
		      'C','T','B','W','X',':','!',		     # as[ftype] 0 - 22
		      'e','aA','a ','a_','~ ','~_','?','?','?','?','?','?','?','?','?',
		      '?','?','?','?','?','a:','a!',		     # ALIAS    23 - 45
		    );

my @full_ftype    = ( 'UDFA','ARITH','GATE','GATEX','RI_BIT','S_SH','R_SH','D_SH',
		      'CH_BIT','S_FF','R_FF','D_FF','CH_AR','F_SW','F_CF','F_CE','CLCK','TIMR',
		      'TRAB','OUTW','OUTX','CLCKL','TIMRL',	     # as[ftype] 0 - 22
		      'F_ERR','ARITH_ALIAS','GATE_ALIAS ','GATEX_ALIAS','INV_ALIAS ','INVX_ALIAS',
		      '?','?','?','?','?','?','?','?','?','?','?','?','?','?',
		      'CLCkL_ALIAS','TIMRL_ALIAS',		     # ALIAS    23 - 45
		    );

my @colourSelect  = ( 0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,0,0,0,2,2,0,4,6, # cs[ftype] 0 - 22
		      0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,6, # ALIAS    23 - 45
		    );

#  live colouring     false 0          true 1             cs  ftype
my @tagBackground = ('PaleGreen1'   , 'yellow2'      ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
							## cs|010 no change
		     'PaleGreen1'   , 'yellow2'      ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
		    );
my @tagForeground = ('black'        , 'red'          ,  # 0 1 GATE
		     'black'        , 'red'          ,  # 2 3 ARITH
		     'black'        , 'white'        ,  # 4 5 CLCKL
		     'black'        , 'white'        ,  # 6 7 TIMRL
							## cs|010 flash glitch
		     'white'        , 'white'        ,  # 0 1 GATE
		     'white'        , 'white'        ,  # 2 3 ARITH
		     'white'        , 'white'        ,  # 4 5 CLCKL
		     'white'        , 'white'        ,  # 6 7 TIMRL
		    );

#		key      $c3      $dir       $reg       $stop
my %pGroup = (	'{' => [ '}', '-forwards',  '[{}\'"]',     'end', ],
		'}' => [ '{', '-backwards', '[{}\'"]',     '1.0', ],
		'(' => [ ')', '-forwards',  '[()\'"]',     'end', ],
		')' => [ '(', '-backwards', '[()\'"]',     '1.0', ],
		'[' => [ ']', '-forwards',  '[\\[\\]\'"]', 'end', ],
		']' => [ '[', '-backwards', '[\\[\\]\'"]', '1.0', ],
	     );

my %keyWords = (
	imm	=> 1,		# immediate type modifiers
	immC	=> 1,
	bit	=> 1,		# immediate types
	int	=> 1,
	clock	=> 1,
	timer	=> 1,
	void	=> 1,
	assign	=> 1,		# immediate parameter modifier
	if	=> 1,		# immediate keywords
	else	=> 1,
	switch	=> 1,
	this	=> 1,
	return	=> 1,
	extern	=> 1,
	while	=> 1,		# only used in C code
	for	=> 1,
	static	=> 1,
	iConst	=> 1,		# immediate built-in variables
	iClock	=> 1,
	FORCE	=> 1,		# immediate built-in functions
	LATCH	=> 1,
	DLATCH	=> 1,
	D	=> 1,
	DR	=> 1,
	DR_	=> 1,
	DSR	=> 1,
	DSR_	=> 1,
	SR	=> 1,
	SR_	=> 1,
	SRX	=> 1,
	SRR	=> 1,
	SRR_	=> 1,
	ST	=> 1,
	SRT	=> 1,
	JK	=> 1,
	SH	=> 1,
	SHR	=> 1,
	SHR_	=> 1,
	SHSR	=> 1,
	SHSR_	=> 1,
	RISE	=> 1,
	FALL	=> 1,
	CHANGE	=> 1,
	CLOCK	=> 1,
	TIMER	=> 1,
	TIMER1	=> 1,
	use	=> 1,		# pragmas
	no	=> 1,
	restore	=> 1,
	alias	=> 1,
	strict	=> 1,
	FOR	=> 1,		# iCa keywords
	IF	=> 1,
	ELSE	=> 1,
	ELSIF	=> 1,
	"{{"	=> 1,
	"}}"	=> 1,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
use vars qw($opt_ $opt_T $opt_q $opt_z $opt_S $opt_t $opt_m $opt_d $opt_s $opt_p $opt_i);
use vars qw($opt_F $opt_l $opt_w $opt_g $opt_A @opt_L $opt_u $opt_X $opt_h);
my $ofh = select(STDERR);	# save old file handle
$= = 1000;			# stop page overflow (default 60 lines)
select($ofh);			# retore old file handle

format STDERR =
Usage:
@<<<<< [ -umtTqh][ -s <host>][ -p <port>][ -i <inst>][ -F <font>][ -l <num>]
 $named
       [ -w <num>][ -g <geometry>][ -A <cmd>][ -d <deb>][ <file> ...]
       [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -s host host name of server    (default 'localhost')
    -p port service port of server (default '8778')
    -i inst initial instance selection (default ''; 1 to 3 numeric chars)
    -F font font or font size to use in Text window (default '20')
    -u      use edit undo facility (not recommended if using Live display)
    -l num  height of the Text window (default @<<)
					$opt_l
    -w num  width  of the Text window (default @<<) -w0 is terminal width
					$opt_w
    -g geom geometry for main window
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients (default 'iCbox')
            if iCsever is started by this @<<<<< call
					  $named
                      BUILD option
    -L<lx>  link extra library(s) eg -L lm -L rt or -L lm,lrt
                      DEBUG options
    -d deb  extra debug options (see iC-application -h)
    -t      trace gate activity in target application (-d1100)
    -m      output elapsed time in seconds and microseconds
    -T      trace output static debug messages
    -q      quiet - do not report clients connecting and disconnecting
    -h      help, ouput this Usage text only
    file ... one or more iC source files. The first will be opened. The
            rest will be stored in the File menu for later selection.
                      AUXILIARY app
    -R <app ...> run auxiliary app followed by -z and its arguments
                 as a separate process; -R ... must be last arguments.

 Menu buttons:                   Action                      Accelerator

    [File] ---- tear-off - menu can be moved and left open
       New      empty file for editing                            Alt-n
       Open     and load the selected file                        Alt-o
       Reload   the current file (usually modified externally)    Alt-R
       Swap.lst switch beteen iC-source and iC-Listing            Alt-l
       Save     the current file if modified                      Alt-s
       SaveAs   store the current file at the selected path       Alt-a
       Quit     quit the program                                  Alt-q
       -------- this is followed by a history of previous programs,
                which can be selected randomly

    [Build]     build the C file and then optionally the executable
                from the currently displayed iC program text.     Alt-b

    [Run Stop]  run or stop the executable application built from the
                currently displayed iC program text.              Alt-r

    [  -]       select no instance or -0 to -9 or extra instance passed
                with -i option. Run and Live use the selected instance.

    [Live       scan the text and generate live markings for all words,
                which represent variables in the currently running
                application - which should be built from the text
                to make a meaningful display. Text is 'read only'
                in this mode.                                     Alt-e
     Edit]      clears live markings in the Text window. In this mode
                the text may be edited with the facilities of Tk::Text,
                which is a full featured editor. The edit facilities
                are fully described in the @<<<<< man page under the
			    $named
                heading 'KEYBOARD BINDINGS'.  If called with the
                -u option, ctrl-U is the <<Undo>> binding.

    [ / ]       Put focus in Search Entry window if cleared.      Alt-/
                    (simulates vi)
                Else start or continue a search of text in
                the Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options and a history of previous searches.
       Search down      or                                       RETURN
                displays a new group of hits.
       Search up        or                                    Shift-RET
                reverses the direction of displaying hits.
       Clear            or double-click search Entry window or Ctrl-RET
                clears hits and the search Entry window.
     <>Go to line       or                                      Alt-RET
                goes to the line entered in the Entry window.
     <>Exact match
     <>Ignore case
     <>Regexp match
     <>Regexp+ignore case
       -------- this is followed by a history of previous search
                strings, which can be selected for a repeat search.

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Help]      Display the @<<<<< man page.                      Alt-h
			    $named

Copyright (C) 2000-2016  John E. Wulff          <immediateC@gmail.com>
						    '@'
$Id: iClive 1.63 $ uses Tk-@<<<<<<<<<
						    $Tk::VERSION
.

########################################################################
#	Restore geometry
########################################################################

my $arg = $ARGV[0];
if ($arg and $arg =~ /^\d+x\d+(\+\d+\+\d+)?$/) {
    $opt_g = $arg;		# iClive restored after logout and restore
    shift @ARGV;		# first ARGV was a geometry
}

########################################################################
#	Handle -R option - count leading options up to -R
#	splice -R to end - move app and remaining arguments to @runArgs
########################################################################

my ($argIndex, $blank, $app, @runArgs);
$argIndex = $blank = 0;
@runArgs = ();
# print "0 \@ARGV = '@ARGV'\n";
foreach (@ARGV) {
    if (s/^-R(.*)$/$1/) {
	$blank = 1 if $_ eq "";		# -R
	$app = "";			# or -Rapp
	last;
    } elsif (s/^(-[^dspiFlwgAR]+)R(.*)$/$1/) {
	$app = $2;			# -abcR or -abcRapp
	$argIndex++;
	last;
    }
    $argIndex++;
}
# no warnings;
# print "1 \@ARGV = '@ARGV'	\$argIndex = $argIndex	\$app = '$app' $#ARGV\n";
# use warnings;
@runArgs = splice @ARGV, $argIndex;
if (defined $app) {
    shift(@runArgs) if $blank;
    unshift(@runArgs, $app) if $app ne "";
    splice(@runArgs, 1, 0, "-d1000");	# do not trace non-active timers TX0.n
}				# append a -z$opt_q later (-z not used in iClive)
# print "2 \@ARGV = '@ARGV'	\@runArgs = '@runArgs'\n"; exit;

########################################################################
#	Handle all remaining -switch options and non-switch options
########################################################################

use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    ''    => \$opt_,			# lone - (not used)
    '<>'  => sub { push(@argv, @_); },	# Transfer file argument to @argv
    't'   => \$opt_t,
    'T'   => \$opt_T,
    'S'   => \$opt_S,
    'm'   => \$opt_m,
    'u'   => \$opt_u,
    'X'   => \$opt_X,
    'q'   => \$opt_q,
    'z'   => \$opt_z,
    'd=i' => \$opt_d,
    's=s' => \$opt_s,
    'p=s' => \$opt_p,
    'i=i' => \$opt_i,
    'F=s' => \$opt_F,
    'l=i' => \$opt_l,
    'w=i' => \$opt_w,
    'g=s' => \$opt_g,
    'A=s' => \$opt_A,
    'L=s' => \@opt_L,
    'h'   => \$opt_h,
);
scalar @ARGV == 0 or die "*** ERROR: $named: '@ARGV' remaining after Getopt::Long Getoptions() ???\n";
print "\@argv = '@argv'	\@runArgs = '@runArgs'\n" if $opt_T;

########################################################################

exit(-1) if $opt_X;		# $named -X called in forked process if first exec fails

my $size = `stty size`;
chomp $size;
my @sizes = $size ? split ' ', $size : (35, 85);
print "size = '$size'\n" if $opt_T;
$opt_l = $sizes[0] unless $opt_l;	# if any higher than 35 on 768 pixel high screen, status bar is hidden
$opt_w = $sizes[1] if defined $opt_w and $opt_w == 0;	# adjust to terminal width
					# @sizes made the same as terminal size because on Debian systems 'man'
					# generates man pages the full width of the terminal (jw 20130829)
$opt_w = 85 unless $opt_w;		# 85 just allows all buttons to fit in the top menu bar (this wide anyway)
					# also gives a bit more room for oversize texts
print "opt_l = '$opt_l' opt_w = '$opt_w'\n" if $opt_T;
if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

if ($opt_q) {
    $opt_q = 'q';			# quiet option
} else {
    $opt_q = '';			# define $opt_q
}

$opt_A = 'iCbox' unless $opt_A;
$opt_S = 'iCserver' unless defined $opt_S;
my $u = '';
if ($opt_u) {
    use Tk::TextUndo;		# 7 times slower for live display and jerky
    $u = ' -u';			# show -u option in title when editing
}

my ($fontSize, $font_t, $boldfont_t, $font, $boldfont);
if (defined $opt_F) {
    if ($opt_F =~ /^\d+$/) {
	$fontSize = $opt_F;
    } else {
	$font_t = $opt_F;
	$fontSize = 20;
    }
}
unless ($font_t) {
    if ($ENV{COMSPEC}) {	# defined on Windows 98 and Windows XP
	$fontSize = 12 unless $fontSize;
	$font_t = "{Lucida Console} fontSize normal";
    } else {			# Linux
	$fontSize = 20 unless $fontSize;
	$font_t = "-adobe-courier-medium-r-normal--fontSize-100-100-100-m-90-iso8859-1";
    }
}
if ($font_t =~ /medium/) {
    $boldfont_t = $font_t;
    $boldfont_t =~ s/medium/bold/;
} else {
    $boldfont_t = "-adobe-courier-bold-r-normal--fontSize-100-100-100-m-90-iso8859-1";
}
change_font(0, 0);		# set initial font size to $fontSize

@opt_L = split(/,/, join(',', @opt_L));	# allow -L lm,rt instead of -L lm -L rt

no warnings;
print "opt_F = '$opt_F' fontSize = '$fontSize'\nfont     = '$font'\n" if $opt_T;
use warnings;

########################################################################
#
#	Handle signals
#
#	NOTE: a signal to be caught by one of the callbacks below will
#	not be processed, until this application receives focus or handles
#	some other event internally (Problem with Tk::MainLoop())
#
########################################################################

## $SIG{QUIT} = \&quit_program;	# catch signal from (X) button
## $SIG{TERM} = \&quit_program;	# catch signal from signal 15

## $SIG{HUP} = \&catch_sig;	# catch signal 1
## $SIG{INT} = \&catch_sig;	# catch signal 2
## $SIG{QUIT} = \&catch_sig;	# catch signal 3
## $SIG{TERM} = \&catch_sig;	# catch signal 15

$SIG{PIPE} = \&catch_sig;	# catch signal in syswrite() in Msg.pm line 103

########################################################################
#
#	Initialize global variables
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my %symbolTable = ();	# $symbolTable{$symbol} [0, 1]   = ($ftype, $index)
my $maxSymbolLength = 4;
my @activeSymbols;	# $activeSymbols[$index][0 .. 3] = ($ts,$val,$cs,[$sec,$usec])
my $stIndex = 0;
my $conn;

my $info = '';		# info messages in status bar
my $infoDisplaying = 0;
my @infoMessages = ();

my $fileName = '';	# name of currently loaded file (should be iC or derivative)
my $fileTime = 0;	# last modified time of currently loaded file
my $readOnly = '';	# set ' (RO)' - true - if file in buffer is read-only
my $procName = '';	# name of runnable iC control program
my $instName = '';	# name of runnable iC control program with instance extension
my $regName = '';
my $runName = '';	# name of running iC control program
my $C_channel = 0;	# receiver channel from control program
my $D_channel = 0;	# sender channel to control program
my $searchText = '';
my $oldContents = '';
my $newName = 'unknown.ic';
my $cwd = cwd;
print "cwd = $cwd\n" if $opt_T;

my $fileTypes = [
    ['iC Source Files',  ['.ic',  '.ica',  '.ih',   ], ['TEXT', ], ],
    ['iC Listing Files', ['.lst',                   ], ['TEXT', ], ],
    ['C  Source Files',  ['.c',   '.h',             ], ['TEXT', ], ],
    ['Text Files',       ['.txt', '.text',          ],             ],
    ['Text Files',       ['',                       ], ['TEXT', ], ],
    ['All Files',        ['*',                      ],             ],
];

# in scan() Tk::Text->search() does not accept a pre-compiled regex qr/.../
# This pattern colours all leading and trailing spaces (used initially)
# my $scanPattern = '[~\s]*(-\s*\d+|\w[\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)\s*((~ )?---|=$)?';
# This pattern colours only one leading space or tab or '~' and one trailing space or tab; with numbers
# my $scanPattern = '(\s?|~\s*)(-\s*\d+|\w[\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)(\s*((~ )?---|=$)|\s)?';
# This pattern colours only one leading space or tab or '~' and one trailing space or tab; leave out numbers
# NOTE the order of the regexes in the final (\s*((~ )?---|=$)|\s) - the final single white space is last or
my $scanPattern = '(\s?|~\s*)([A-Z_a-z][\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)(\s*((~ )?---|=$)|\s)?';
my $bMsg = '';		# balloon message
my $wIdx = '';		# Index of current wordstart
my $pIdx = '';		# Index of previous wordstart

# has to be global, 'our' not portable yet
my ($home);
my (@hits, @groups, $gi, $gl, $centre, $lineCnt);
my $prevText = '';
my $prevMatch = '';
my $prevStart = 0;
my $prevLast  = 0;
my $server  = 0;

########################################################################
#
#	Create main window and menus
#
#	NOTE: parameters in -command => [ ] closures are taken from the
#	      time the command was executed - not when event takes place
#
########################################################################

my $mainWindow = MainWindow->new();
if ($opt_g) {
    if ($opt_g =~ /^(\d+x\d+)?([+-]\d+[+-]\d+)?$/) {
	$mainWindow->geometry($opt_g);
    } else {
	warn "bad geometry string '$opt_g' - ignored\n";
	$opt_g = '';
    }
}
$mainWindow->title("$named$u");
$mainWindow->protocol('WM_DELETE_WINDOW', \&quit_program);	# Windows (X) pressed

if (($home = $ENV{HOME}) ne '' and
    (-d "$home/.iC" or mkdir "$home/.iC")) {
    if ($opt_T or not -f "$home/.iC/$named.bit") {
	if (open(INI, ">$home/.iC/$named.bit")) {
	    print "$named: generate a new minimise icon file\n";
	    print INI << "EOF";
/* minimise icon 'iC' for iClive */
\#define ic_width 48
\#define ic_height 48
static unsigned char ic_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1c,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0x1c,
    0xe0, 0x00, 0x00, 0xe0, 0xff, 0x1f,
    0xf0, 0x01, 0x00, 0xf8, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xfe, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xff, 0xff, 0x1f,
    0xf8, 0x03, 0x80, 0x7f, 0x00, 0x1f,
    0xf0, 0x01, 0xc0, 0x1f, 0x00, 0x1c,
    0xe0, 0x00, 0xe0, 0x07, 0x00, 0x18,
    0x00, 0x00, 0xf0, 0x03, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0x01, 0x00, 0x00,
    0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7c, 0x00, 0x00, 0x00,
    0xf8, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf8, 0x01, 0x3c, 0x00, 0x00, 0x00,
    0xf8, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0xf8, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0xf8, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0xf0, 0x01, 0x00, 0x00,
    0xf0, 0x01, 0xf0, 0x03, 0x00, 0x00,
    0xf0, 0x01, 0xe0, 0x07, 0x00, 0x18,
    0xf0, 0x01, 0xc0, 0x1f, 0x00, 0x1c,
    0xf0, 0x01, 0x80, 0x7f, 0x00, 0x1f,
    0xf0, 0x01, 0x00, 0xff, 0xff, 0x1f,
    0xf0, 0x01, 0x00, 0xfe, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xf8, 0xff, 0x0f,
    0xf8, 0x03, 0x00, 0xe0, 0xff, 0x03,
    0xf8, 0x03, 0x00, 0x00, 0x7f, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
EOF
	    close(INI);
	} else {
	    warn "ERROR: Can't open ~/.iC/$named.bit: $!\n";
	}
    }
    $mainWindow->iconbitmap("\@$home/.iC/$named.bit");
}

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack(-side => 'top', -fill => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton(-text               => 'File',
				    -relief             => 'raised',
				    -borderwidth        => 2,
				    -takefocus          => 1,
				    -highlightthickness => 1,
				    -tearoff            => 1,		# 0 - tear off
				   )->pack(-side => 'left', -padx => 2);
$menuFile->command(-label       => 'New',				# 1
		   -accelerator => 'Alt-n',
		   -command     => \&new_text);
$menuFile->command(-label       => 'Open',				# 2
		   -accelerator => 'Alt-o',
		   -command     => \&open_file);
$menuFile->command(-label       => 'Reload',				# 3
		   -accelerator => 'Alt-R',
		   -command     => \&reload_file);
$menuFile->command(-label       => 'Open.lst',				# 4 $menuFile->entryconfigure(4, -label => "$1.lst");
		   -accelerator => 'Alt-l',
		   -command     => \&open_list);
$menuFile->command(-label       => 'Save',				# 5
		   -accelerator => 'Alt-s',
		   -command     => [ \&save_file, 0, 0 ]);
$menuFile->command(-label       => 'SaveAs',				# 6
		   -accelerator => 'Alt-a',
		   -command     => \&saveAs_file);
$menuFile->separator();							# 7
$menuFile->command(-label       => 'Quit',				# 8
		   -accelerator => 'Alt-q',
		   -command     => \&quit_program);
$menuFile->separator();							# 9
my $menuFileStart = 10;				# first dynamic entry:  # 10
my @dynamicFiles  = ();				# maintain local dynamic entries
my $menuFileLim   = 10;				# number of dynamic entries

my @lastFile      = ();				# save last open file

########################################################################
#	Build menu
########################################################################
my $menuBuild = $menuBar->Menubutton(-text               => 'Build',
				     -relief             => 'raised',
				     -borderwidth        => 2,
				     -takefocus          => 1,
				     -highlightthickness => 1,
				     -tearoff            => 0,		# no tear off
				    )->pack(-side => 'left', -padx => 2);
$menuBuild->command(-label       => 'Build executable',
		    -accelerator => 'Alt-b',
		    -command     => [ \&build_file, 0, 0 ]);
$menuBuild->command(-label       => 'Save &Build unconditionally',
		    -accelerator => 'Alt-u',
		    -command     => [ \&build_file, 0, 1 ]);
$menuBuild->command(-label       => 'Build C file only',
		    -accelerator => 'Alt-c',
		    -command     => [ \&build_file, 0, 2 ]);
if ($opt_T) {
    $menuBuild->command(-label   => 'Symbol Table by name',
			-command => [ \&output_symbol_table, 0, 0 ]);
    $menuBuild->command(-label   => 'Symbol Table by index',
			-command => [ \&output_symbol_table, 0, 1 ]);
    $menuBuild->command(-label   => 'T to iCserver',			# iCserver prints table
			-command => sub { conn_send_now('T') if $conn; });
    $menuBuild->command(-label   => 'X to iCserver',			# stop iCserver
			-command => sub { conn_send_now('X') if $conn; });
}
my $makeName = '';
my $restartFlag = 0;

########################################################################
    #	Run or Stop button
    ########################################################################
my $menuRun  = $menuBar->Button(-text        => 'Run ',
				-relief      => 'raised',
				-width       => 4,
				-borderwidth => 2,
				-command     => \&run_file,
			       )->pack(-side => 'left', -padx => 2);

########################################################################
#	Instance button
########################################################################
my ($instanceText, $instance, $oldInstance);
my @instanceOptions = (
    [""  , ''],
    ["-0", 0 ],
    ["-1", 1 ],
    ["-2", 2 ],
    ["-3", 3 ],
    ["-4", 4 ],
    ["-5", 5 ],
    ["-6", 6 ],
    ["-7", 7 ],
    ["-8", 8 ],
    ["-9", 9 ]
);

$instanceText = $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = $opt_i;
	$instanceText = "-$instance";
	if (length $instance > 1) {
	    push @instanceOptions, [$instanceText, $instance];
	}
    } else {
	warn "$named: badly formed option -i $opt_i - ignored\n";
    }
}
$oldInstance = $instanceText;
print "instanceText=$instanceText, instance=$instance\n" if $opt_T;

my $menuInst  = $menuBar->Optionmenu(-command      => \&change_instance,
				     -textvariable => \$instanceText,
				     -variable     => \$instance,
				     -options      => \@instanceOptions
				    )->pack(-side => 'left', -padx => 2);

########################################################################
#	Live or Edit button
########################################################################
my $menuScan = $menuBar->Button(-text        => 'Live',
				-relief      => 'raised',
				-width       => 4,
				-borderwidth => 2,
				-command     => \&scan,
			       )->pack(-side => 'left', -padx => 2);
my $scanFlag = 0;		# text is initially cleared

########################################################################
#	Search button
########################################################################
my $searchButton = $menuBar->Button(-text        => '/',
				    -relief      => 'raised',
				    -borderwidth => 2,
				    -command     => [ \&search_text, 0, undef, 0 ],	# Release-1
				   )->pack(-side => 'left', -padx => 2);
$searchButton->bind('<ButtonPress-1>',	[ \&SearchMenu, \$searchButton, ]);

########################################################################
#	Search menu
########################################################################

my $searchMenu = $mainWindow->Menu();	# filled dynamically
my $searchTimer;
my $matchType = "-exact";		# default, alternatives -nocase -regexp

$searchMenu->command(-label       => 'Search down',			# 1
		     -accelerator => 'Return',
		     -command     => [ \&search_text, 1, undef, 0 ]);
$searchMenu->command(-label       => 'Search up',			# 2
		     -accelerator => 'Shift-Ret',
		     -command     => [ \&search_text, 1, undef, 1 ]);
$searchMenu->command(-label       => 'Clear',				# 3
		     -accelerator => 'Ctrl-Ret',
		     -command     => [ \&search_text, 1, '',    0 ]);
########################################################################
#	Goto line number
########################################################################
$searchMenu->radiobutton(-label    => 'Go to line',			# 4
			 -accelerator => 'Alt-Ret',
			 -value    => 'g',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 2 ]);
########################################################################
#	Exact match
########################################################################
$searchMenu->radiobutton(-label    => 'Exact match',			# 5
			 -value    => '-exact',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Ignore case
########################################################################
$searchMenu->radiobutton(-label    => 'Ignore case',			# 6
			 -value    => '-nocase',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match
########################################################################
$searchMenu->radiobutton(-label    => 'Regexp match',			# 7
			 -value    => '-regexp',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match - Ignore case
########################################################################
$searchMenu->radiobutton(-label    => 'Regexp Ignore case',		# 8
			 -value    => 'ri',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
$searchMenu->separator();						# 9
my $searchMenuStart  = 10;			# first dynamic entry:  #10
my @dynamicSearches  = ();			# maintain local dynamic entries
my $searchMenuLim    = 10;			# number of dynamic entries

########################################################################
#	Search entry
########################################################################
my $entrySearch = $menuBar->Entry(-width        => 20,
				  -textvariable => \$searchText,
				 )->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom in button
########################################################################
$menuBar->Button(-text        => '-',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', -2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom out button
########################################################################
$menuBar->Button(-text        => '+',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', 2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Help button
########################################################################
$menuBar->Button(-text        => 'Help',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => \&fork_help,
		)->pack(-side => 'right', -padx => 2);

########################################################################
#	Ini data for file and search menu lists
########################################################################
my %iniMenuData = (
    files	=> [
	$menuFile->menu,	# menuRef,	file menu
	\@dynamicFiles,		# entriesArray,	maintain local dynamic entries
	$menuFileStart,		# menuPos,	start of dynamic entries
	$menuFileLim,		# entriesLim,	number of dynamic entries
	\&open_file,		# commandRef,	call back for open file
    ],
    'last open file' => [
	0,			# menuRef,	no menu
	\@lastFile,		# entriesArray,	save last open file, line # and instance
	0,
	0,			# entriesLim,	(not used)
	0,
    ],
    searches	=> [
	$searchMenu,		# menuRef,	search menu
	\@dynamicSearches,	# entriesArray,	maintain local dynamic entries
	$searchMenuStart,	# menuPos,	start of dynamic entries
	$searchMenuLim,		# entriesLim,	number of dynamic entries
	\&search_text,		# commandRef,	call back for search text
    ],
);

my %matchExtensions = (
    -exact	=> '',
    -nocase	=> '	i',
    -regexp	=> '	r',
    ri		=> '	ri',
    g		=> '	g',
);
my %matchRestores = (
    e		=> '-exact',
    i		=> '-nocase',
    r		=> '-regexp',
    ri		=> 'ri',
    g		=> 'g',
);

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
				 -relief       => 'ridge',
				)->pack(-side => 'bottom', -fill => 'x');

########################################################################
#	Text window
########################################################################
my $text;
no warnings;
print "opt_F = '$opt_F' fontSize = '$fontSize'\nfont     = '$font'\n" if $opt_T;
use warnings;
if ($opt_u) {
    $text = $mainWindow->Scrolled('TextUndo',
				     -scrollbars => 'osoe',
				     -setgrid    => 2,
				     -background => 'cornsilk1',
				     -wrap       => 'none',	# horizontal scrollbar
				     -font       => $font,
				    )->pack(-fill => 'both', -expand => 1);
    $text->eventAdd('<<Undo>>' => '<Control-u>');	# extra Undo binding
} else {
    $text = $mainWindow->Scrolled('Text',
				     -scrollbars => 'osoe',
				     -setgrid    => 2,
				     -background => 'cornsilk1',
				     -wrap       => 'word',	# no horizontal scrollbar
				     -font       => $font,
				    )->pack(-fill => 'both', -expand => 1);
}
unless ($opt_g) {
    $text->configure (-width  => $opt_w);
    $text->configure (-height => $opt_l);
}

my $yScrollbar = $text->Subwidget('yscrollbar');
my $xScrollbar = $text->Subwidget('xscrollbar');

####### Key and Mouse button bindings ##################################
####### Search entry bindings ##########################################
$entrySearch->bind('<KeyPress>',		[ \&set_shift_control     ]); # Set Shift/Control state
$entrySearch->bind('<KeyRelease>',		[ \&reset_shift_control   ]); # Reset Shift/Control state
$entrySearch->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$entrySearch->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$entrySearch->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear search
$entrySearch->bind('<Double-1>',		[ \&search_now, '',    0  ]); # clear search
$entrySearch->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
####### File menu bindings #############################################
$entrySearch->bind('<Alt-Key-R>',		[ \&reload_file           ]); # active in Live mode
$entrySearch->bind('<Alt-Key-l>',		[ \&open_list             ]); # active in Live mode
$entrySearch->bind('<Alt-Key-q>',		[ \&quit_program          ]); # active in Live mode
$entrySearch->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
####### Run/Stop button binding ########################################
$entrySearch->bind('<Alt-Key-r>',		[ \&run_file              ]); # active in Live mode
####### Live/Edit button binding #######################################
$entrySearch->bind('<Alt-Key-e>',		[ \&scan                  ]); # active in Live mode
####### Help button binding ############################################
$entrySearch->bind('<Alt-Key-h>',		[ \&fork_help             ]); # active in Live mode
####### X-Movement bindings #### Y-Movement used by Entry #############
$entrySearch->bind('<Key-Down>',		[ \&scroll_text, 1        ]); # scroll down
$entrySearch->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$entrySearch->bind('<Key-Next>',		[ \&scroll_text, $opt_l-2 ]); # next page
$entrySearch->bind('<Key-Prior>',		[ \&scroll_text, -$opt_l+2]); # prior page
$entrySearch->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$entrySearch->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
####### Text window bindings ###########################################
$text      ->bind('<KeyPress>',			[ \&set_shift_control     ]); # Set Shift/Control state
$text      ->bind('<KeyRelease>',		[ \&reset_shift_control   ]); # Reset Shift/Control state
$text      ->bind('<Button-1>',			[ \&report_cursor         ]); # change in cursor position
$text      ->bind('<ButtonRelease>',		[ \&adjust_live           ]);
$text      ->bind('<Double-1>',			[ \&pick_word             ]); # select a search word (clashes with Text-binding)
$text      ->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
####### Y-Scrollbar bindings ###########################################
$yScrollbar->bind('<KeyPress>',			[ \&set_shift_control     ]); # Set Shift/Control state
$yScrollbar->bind('<Key-R>',			[ \&reload_file           ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-R>',		[ \&reload_file           ]); # active in Live mode
$yScrollbar->bind('<Key-l>',			[ \&open_list             ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-l>',		[ \&open_list             ]); # active in Live mode
$yScrollbar->bind('<Key-q>',			[ \&quit_program          ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-q>',		[ \&quit_program          ]); # active in Live mode
$yScrollbar->bind('<Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Key-Right>',		[ \&scroll_x_text, 1      ]); # scroll right
$yScrollbar->bind('<Key-Left>',			[ \&scroll_x_text, -1     ]); # scroll left
$yScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$yScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
$yScrollbar->bind('<ButtonRelease>',		[ \&adjust_live           ]);
$yScrollbar->bind('<KeyRelease>',		[ \&adjust_live           ]);
$yScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$yScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$yScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear
$yScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
####### X-Scrollbar bindings ###########################################
$xScrollbar->bind('<KeyPress>',			[ \&set_shift_control     ]); # Set Shift/Control state
$xScrollbar->bind('<Key-Down>',			[ \&scroll_text, 1        ]); # scroll down
$xScrollbar->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$xScrollbar->bind('<Key-Next>',			[ \&scroll_text, $opt_l-2 ]); # next page
$xScrollbar->bind('<Key-Prior>',		[ \&scroll_text, -$opt_l+2]); # prior page
$xScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$xScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
$xScrollbar->bind('<ButtonRelease>',		[ \&adjust_live           ]);
$xScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$xScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$xScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear
$xScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
########################################################################
#	The Tk::Text Widget uses no Alt bindings - so we use them here
####### File menu bindings #############################################
$text      ->bind('<Alt-Key-n>',		[ \&new_text              ]); # not active in Live mode
$text      ->bind('<Alt-Key-o>',		[ \&open_file             ]); # not active in Live mode
$text      ->bind('<Alt-Key-R>',		[ \&reload_file           ]); # active in Live mode
$text      ->bind('<Alt-Key-l>',		[ \&open_list             ]); # active in Live mode
$text      ->bind('<Alt-Key-s>',		[ \&save_file, 0          ]); # not active in Live mode
$text      ->bind('<Alt-Key-a>',		[ \&saveAs_file           ]); # not active in Live mode
$text      ->bind('<Alt-Key-q>',		[ \&quit_program          ]); # active in Live mode
####### Build menu bindings ############################################
$text      ->bind('<Alt-Key-b>',		[ \&build_file, 0         ]); # not active in Live mode
$text      ->bind('<Alt-Key-u>',		[ \&build_file, 1         ]); # not active in Live mode
$text      ->bind('<Alt-Key-c>',		[ \&build_file, 2         ]); # not active in Live mode
####### Run/Stop button binding ########################################
$text      ->bind('<Alt-Key-r>',		[ \&run_file              ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-r>',		[ \&run_file              ]);
$yScrollbar->bind('<Key-r>',			[ \&run_file              ]);
$yScrollbar->bind('<Key-s>',			[ \&run_file              ]);
####### Live/Edit button binding #######################################
$text      ->bind('<Alt-Key-e>',		[ \&scan                  ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-e>',		[ \&scan                  ]);
$yScrollbar->bind('<Key-e>',			[ \&scan                  ]);
####### Help button binding ############################################
$text      ->bind('<Alt-Key-h>',		[ \&fork_help             ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-h>',		[ \&fork_help             ]);
$yScrollbar->bind('<Key-h>',			[ \&fork_help             ]);
####### Change font size with Alt - and Alt + ##################
$text      ->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$text      ->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
$yScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$yScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
$xScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$xScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font

########################################################################
#	Balloon widget
########################################################################
my $balloon = $mainWindow->Balloon(-state => 'balloon');
my $balloonAttached = 0;

########################################################################
#	Bug in Tk-804.027 (possibly only on MAC OsX-1.3-darwin)
#	next (commented) statement causes XS_TK__Callback_Call error
#	just forget about it ???	JW 2005/02/02
########################################################################
# $mainWindow->OnDestroy(sub { $balloon->destroy; });
$mainWindow->bind('<Configure>',		[ \&adjust_live           ]);

########################################################################
#	Connect to iCserver
########################################################################
print "$named: initial register_at_server\n" if $opt_T;
register_at_server();

########################################################################
#	Optionally run -R option
########################################################################
if (@runArgs) {
    splice(@runArgs, 1, 0, "-s", "$host") unless $host eq "localhost" or $host eq "127.0.0.1";
    splice(@runArgs, 1, 0, "-p", "$port") unless $port eq "8778";
    splice(@runArgs, 1, 0, "-z$opt_q",);	# -z not used in iClive - place holder
    fork_and_exec(@runArgs);
}

########################################################################
#	Initialise file and search menu lists, open the first file.
#	NOTE:
#	must be called after register_at_server() - if not causes
#	search to misbehave with some program texts. The first $text->see()
#	positions first window with the named location at the top of
#	the window, rather than in the middle of the window - but only
#	with 'adobe ...' fonts - '9x15' works OK - STRANGE JW 25/07/2009
########################################################################
print "$named: initialise program\n" if $opt_T;
ini_program();

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################
MainLoop();
exit(0);

####### End of main program ############################################

########################################################################
#	Catch miscellaneous signals
########################################################################

sub catch_sig {
    my $signame = shift;
    die "$named: Somebody sent me a SIG$signame: $!";
} # catch_sig

########################################################################
#
#	Display information on the info bar
#	(make sure all displays to info bar go via this routine)
#	Parameter 1:	delay in milliseconds
#	Parameter 2:	colour (change if $message ne '')
#	Parameter 3:	message text
#
#	messages  are queued and displayed at <delay> ms intervals
#
########################################################################

sub info_display {
    push @infoMessages, @_;	# must always be 3 parameters
    display_callback() unless $infoDisplaying;	# wait if displaying
} # info_display

sub display_callback {
    my ($delay, $colour, $message);
    while (@infoMessages) {
	($delay, $colour, $message) = splice @infoMessages, 0, 3;	# shift 3
	$infoBar->configure(-foreground => $colour) if $message ne '';
	$info = $message;	# display now
	print "display_callback: '$info'\n" if $opt_T;
	if ($delay) {
	    $infoDisplaying = 1;
	    $text->after($delay, \&display_callback);	# call self in delay ms
	    return;
	}
    }
    $infoDisplaying = 0;	# current display will stay - ready for imm change
} # display_callback

########################################################################
#
#	Tag all comments in text with tag 'ctag'	BLUE
#	Tag all keywords in program text with tag 'bd'	BOLD
#
########################################################################

sub tagComments {
    # Tk::Text->search() does not accept a pre-compiled regex qr/.../
    my $reg = '(/[/*]|[[*]/|[\'"]|\w+)';	# /* // */ ' " words
    my $stop = '';
    my $length = 1;
    my $current = '1.0';	# start of text
    print "tagComments: $current\n" if $opt_T;
    $text->tagDelete('cTag', 'bd');
    $text->tagConfigure('cTag', -foreground => 'blue');
    $text->tagConfigure('bd',   -font       => $boldfont);
    my $cStart = '';
    my $state = "P";		# Program text
    while (1) {
	$current = $text->search(-count => \$length,
				 -regexp,
				 -forwards,
				 '--',
				 $reg,		# search regular expression
				 $current,	# start index
				 'end',		# stop index
				);
	last unless $current;
	my $atom = $text->get($current, "$current + $length char");
	print "tagComments: $current '$atom'\n" if $opt_T;
	if ($atom eq '"' or $atom eq "'") {
	    my $c4 = $text->get($text->index("$current - 1 char"));
	    my $c5 = $text->get($text->index("$current - 2 char"));
	    if (($c4 eq "\\" and $c5 ne "\\") ||	# ignore \" and \' but not \\" and \\'
		($atom eq "'" and $c4 eq "-" and $c5 ne "'")) {
		$atom = '';		# also ignore -' LOGC flag in listing but not '-' and -"
	    }
	}
	if ($state eq "S") {		# string constant
	    if ($atom eq '"') {
		$state = "P";
	    }
	} elsif ($state eq "H") {	# character constant
	    if ($atom eq "'") {
		$state = "P";
	    }
	} elsif ($state eq "C") {	# C comment
	    if ($atom eq "*/") {
		$current = $text->index("$current + $length char");
		$text->tagAdd('cTag', $cStart, $current);
		$state = "P";		# end of C comment found
		next;
	    } elsif ($atom eq "/*") {
		info_display(2000, 'red', "$named: '$current' /* found during comment");
	    }
	} elsif ($atom eq '"') {	# $state eq "P"
	    $state = "S";		# start of string found
	} elsif ($atom eq "'") {
	    $state = "H";		# start of character constant found
	} elsif ($atom eq "/*") {
	    $state = "C";		# start of C comment found
	    $cStart = $current;
	} elsif ($atom eq "*/") {
	    info_display(2000, 'red', "$named: '$current' */ found after end of comment");
	} elsif ($atom eq "//") {
	    $cStart = $current;		# start of C++ comment found ($state remains "P")
	    $current = $text->index("$current lineend");
	    $text->tagAdd('cTag', $cStart, $current);
	    next;
	} elsif ($keyWords{$atom}) {
	    $cStart = $current;		# keyword found ($state remains "P")
	    $current = $text->index("$current + $length char");
	    $text->tagAdd('bd', $cStart, $current);
	    next;
	}
	$current = $text->index("$current + $length char");
    }
} # tagComments

########################################################################
#
#	Report the cursor position in the info bar
#	Highlight matching braces, parantheses and square brackets
#
########################################################################

sub report_cursor {
    my $c1 = '';
    my $c2 = '';
    my $c3 = '';
    my $dir = '';
    my $reg = '';
    my $stop = '';
    my $length = 0;
    my $n = 0;
    my $cursor = $text->index('insert');		# '27.0'
    $cursor =~ m/(\d+)\.(\d+)/;
    my $y = $1;
    my $x = $2 + 1;
    my $current = '';
    $text->tagDelete('pTag');
    unless ($scanFlag) {
	my $x1 = $2 - 1;
	if ($x1 >= 0) {
	    my $c = $text->get("$y.$x1");
	    if ($c =~ /[{}()\[\]]/) {
		$text->tagConfigure('pTag',
				    -background => 'lightblue',
				    -foreground => 'black',
				   );
		$c1 = $c;
		($c2, $dir, $reg, $stop) = @{ $pGroup{$c1} };
		$current = $cursor = "$y.$x1";
		$text->tagAdd('pTag', "$y.$x1");
		while (1) {
		    $current = $text->index("$current + 1 char") if $dir eq "-forwards";
		    $current = $text->search(-count => \$length,
					     -regexp,
					     $dir,	# -backwards or -forwards
					     '--',
					     $reg,	# search regular expression
					     $current,	# start index
					     $stop,	# stop index
					    );
		    last unless $current;
		    $c3 = $text->get($current);
		    print("$cursor '$c1 $c2' $dir $reg $stop n = $n '$current' $c3 $length\n") if $opt_T;
		    if ($c3 eq $c1) {
			$n++ if $n < 0x7f;	# nesting depth limit 127
		    } elsif ($c3 eq $c2) {
			if ($n < 0x7f and $n-- <= 0) {
			    print "\n" if $opt_T;
			    $text->tagAdd('pTag', $current);
			    last;		# matching brace found
			}
		    } elsif ($c3 eq '"' or $c3 eq "'") {
			my $c4 = $text->get($text->index("$current - 1 char"));
			my $c5 = $text->get($text->index("$current - 2 char"));
			if ($c3 eq '"') {
			    $n ^= 0x80 unless ($n & 0x100) or ($c4 eq '\\' and $c5 ne '\\');	# must be greater than nesting depth limit
			} else {
			    $n ^= 0x100 unless ($n & 0x80) or ($c4 eq '\\' and $c5 ne '\\');	# "'"
			}
		    }
		}
	    }
	}		#    info_display(0, 'black', "$cursor '$c1 $c2' $dir $reg $stop n = $n '$current' $c3");
    }
    info_display(0, 'black', "line $y, char $x");	# 'line 27 char 1'
} # report_cursor

########################################################################
#
#	Set Shift/Control Key state only in Live mode
#	none			0	balloon shows value of variable
#	Shift_L			1	balloon shows index in S.T. (useful in checking for ALIASES)
#	Control_L		2	balloon shows ftype as mnemonic
#	Shift_L+Control_L	3	balloon shows ftype as number
#	NOTE: iClive window must have focus for KeyPress and KeyRelease to be recognised
#
########################################################################

sub set_shift_control {
    if ($scanFlag) {
	my $k;				# Live mode
	if (($k = $Tk::event->K) eq "Shift_L" or $k eq "Shift_R") {
	    $shift_control_state |= 01;
	} elsif ($k eq "Control_L" or $k eq "Control_R") {
	    $shift_control_state |= 02;
	} else {
	    $shift_control_state = 0;
	}	# my $n = $Tk::event->N; info_display(0, 'black', "Press   KeySym=$k, numeric=$n");
    }
    report_cursor();
} # set_shift_control

########################################################################
#
#	Reset Shift/Control Key state only in Live mode
#
########################################################################

sub reset_shift_control {
    if ($scanFlag) {
	my $k;				# Live mode
	if (($k = $Tk::event->K) eq "Shift_L" or $k eq "Shift_R") {
	    $shift_control_state &= ~01;
	} elsif ($k eq "Control_L" or $k eq "Control_R") {
	    $shift_control_state &= ~02;
	} else {
	    $shift_control_state = 0;
	}	# my $n = $Tk::event->N; info_display(0, 'red', "Release KeySym=$k, numeric=$n");
    }
} # reset_shift_control

########################################################################
#
#	Adjust live display to only the text in the view window.
#
#	This speeds up live display enourmously - especially on very
#	large listing texts eg. 10,000 lines, where 15 seconds were needed
#	to build the live display and live updates were then still sluggish
#	approx. 0.5 seconds near the end of the text. Worse still my 2.5 GHz
#	processor was stretched to the limit to keep the live display up to
#	date, although 99% or more of the changes did not affect the current
#	text visible in the text window. With the change live displays come
#	up in a fraction of a second no matter how large the text is. All
#	one can see when scrolling the text window is a blink in '1' variables.
#	Measured 2 ms for a typical 26 line window. CPU loading between 0 and
#	10% for an application displaying 4 shift registers changing every
#	50 ms. Associated network traffic 25K.
#
#	Since this activation may come from several binds resulting in the
#	same $start and $last lines, do_scan only once when line numbers
#	change.
#
#	$prevStart and $prevLast must be cleared when changing file or instance
#	in case the text in the window is similar.
#
#	The computation of $start and $last from $end has always yielded
#	integer values with the fractions returned by $text->yview().
#	If this were not the case, function int($start+0.5) could be used.
#	Perl seems to do this internally on the 16th precision digit ???
#	Tested empircally JW 20050404
#	Failed for very large files, so modified using int	JW 20101016
#
#	parameter 1:	$_[0], has HASH ref when callback from bind
#	parameter 2:	$_[1], do_scan unconditionally if true
#
########################################################################

sub adjust_live {
    if ($scanFlag) {
	$shift_control_state = 0;
	my @position = $text->yview();
	my $end = $text->index('end');	# re-compute in case text has changed
	$end =~ s/(\d+).*/$1/;
	my $e = $end -1;
	my $start = int $e * $position[0] + 1.5;	# 1 line early for wrapped lines
	my $last = int $e * $position[1] + 2.5;
	my $l = $last - 2;
	$last = $end if $last > $end;
	if ($start != $prevStart or $last != $prevLast or $_[1]) {
	    if (@activeSymbols) {
		deleteAllTags();	# delete tags and all previous active symbols
		clear_scan();		# clear active symbols in connected iC controller process
	    }
	    do_scan("$start.0", "$last.0");
	    $prevStart = $start;
	    $prevLast  = $last;
	    printMicroSeconds("adjust live");
no warnings;
	    print "do_scan complete, $start, $last, '$_[1]'\n" if $opt_t and not $opt_q;
use warnings;
	}
	info_display(0, 'dark green', "line $start to line $l") if $searchText eq '';
    }
} # adjust_live

########################################################################
#
#	Send message to $conn now
#
########################################################################

sub conn_send_now {
    my ($msg) = @_;
    eval {
	$conn->send_now($msg);
    }; warn "eval: $@" if $@;
}  # conn_send_now

########################################################################
#
#	Register at iCserver
#	connection is maintained until iClive shuts down or iCserver disconnects
#
#	Inhibit Nagle's algorithm
#
#	Register read events
#	Register I/O at iCserver and request Symbol Table if $scanFlag is set
#
########################################################################

sub register_at_server {
    my $i = 0;
    if ($server >= 0) {
	Msg->inhibit_nagle(1,		# inhibit Nagle's algorithm for real time response
	    defined $opt_d && ($opt_d & 2),	# trace recv messages
	    defined $opt_d && ($opt_d & 1));	# trace send messages
	until ($conn) {
	    $conn = Msg->connect($host, $port, \&rcvd_msg_from_server, 1); # return imme if connect fails
	    if ($conn) {
		print STDERR "$named connecting at server\n" unless $opt_q;
		$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });
		info_display(2000, 'blue', "Connection to '$host:$port'");
	    } elsif ($host ne "localhost" and $host ne "127.0.0.1") {
		print "$named: '$host:iCserver -p $port -A $opt_A' cannot be started here - start it on $host\n";
		$server = -1;		# no iCserver possible
		last;
	    } elsif ($server > 0) {
		if ($i++ < 4) {
		    print "$named: $i: wait 2 seconds for iCserver to start\n" if $opt_T;
		    select undef, undef, undef, 2;
		} else {
		    print "$named: waited 8 seconds for 'iCserver -p $port -A $opt_A' to start - give up\n";
		    $server = -1;	# something wrong with iCserver
		    last;
		}
	    } else {
		my @s = split(" ", $opt_S);
		print "\@s = '@s'\n" if $opt_T;
		splice(@s, 1, 0, "-p", "$port") unless $port eq "8778";
		splice(@s, 1, 0, "-z$opt_q", "-k", "-A", "$opt_A");	# block STDIN for chained iCserver
		print "\@s = '@s'\n" if $opt_T;
		fork_and_exec(@s);	# start iCserver
		$server = 1;		# remember that this iCtherm started iCserver
	    }				# try to connect immediately
	}
    }
    if ($instName ne '') {
	if ($conn) {
	    if ($regName eq '') {
		my $ret = '';
		my $Registrations = "N-$instName,RC$instName,SD$instName,Z";
		$regName = $instName;		# register but may not connect to application
		print "$named: Registrations: $Registrations\n" if $opt_T;
		conn_send_now($Registrations);
		info_display(2000, 'blue', "Register as '-$instName'");
		my ($tmsg, $terr) = $conn->rcv_now();
no warnings;
		print "$named: Reply: '$tmsg' err = '$terr'\n" if $opt_T;
		$i = 1;
		REPEAT:
		if ($tmsg !~ /^(\d+),(\d+)$/) {	# analyse registration reply now
		    rcvd_msg_from_server($conn, $tmsg, $terr);
		    unless ($conn) {
			print "$named: failed to register on attempt $i\n" if $opt_T;
			goto FAILED_TO_REGISTER;	# stop trying if registered twice
		    }
		    ($tmsg, $terr) = $conn->rcv_now();
		    print "$named: Reply: '$tmsg' err = '$terr' ($i)\n" if $opt_T;
		    die "registration failed\n" if $i++ >= 3;
		    goto REPEAT;	# cannot use while, because $1 $2 not in scope - if OK
		}
use warnings;
		$C_channel = $1;	# receiver channel from control program
		$D_channel = $2;	# sender channel to control program
		print "$named: registered: C_channel = $C_channel, D_channel = $D_channel\n" if $opt_T;
		conn_send_now("$D_channel:2");	# poll application to see if it is live
	    }
	} else {
	    FAILED_TO_REGISTER: info_display(2000, 'red',
		"Could not connect to '$host:$port' - no live listing - edit only");
	}
    }
} # register_at_server

########################################################################
#
#	Unregister current session from iCserver
#
########################################################################

sub unregister_from_server {
    if ($regName ne '') {
	print "$named: unregister '$regName' '$D_channel:0'.\n" if $opt_T;
	conn_send_now("$D_channel:0");
	my $UnRegistrations = "n-$regName,rC$regName,sD$regName";
	$regName = '';
	print "$named: UnRegistrations: $UnRegistrations\n" if $opt_T;
	$mainWindow->title("$named$u: $fileName$readOnly");
	conn_send_now($UnRegistrations);
    }
    clear_all();
} # unregister_from_server

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occurr if $conn and read events registered)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
    die "named: rcvd on a strange connection '$rConn', should be '$conn'\n$msg\n" if $rConn ne $conn;
    if (defined $msg) {
	my $len = length $msg;
	print "($len)$msg< iCserver\n" if $opt_T;
	if ($len == 0) {
	    print "$named: rcvd zero length message - disconnect\n" if $opt_T;
	    info_display(2000, 'red', "$named: disconnected by iCserver");
	    unregister_from_server();
	    $scanFlag = 0;
	    $menuScan->configure(-text => 'Live');
	    $regName = $runName = '';
	    $menuRun->configure(-text => 'Run ');
	    print "$named: rcvd_msg_from_server(0) buttons to 'Run ' 'Live'\n" if $opt_T;
	    $mainWindow->title("$named$u: $fileName$readOnly");
	    $makeName = '';
	    $conn->disconnect;		# should only happen when iCserver shuts down
	    $conn = 0;
	    info_display(2000, 'red', "iCserver has disconnected $named from '$host:$port'");
	} else {
	    my ($msg1);
	    printMicroSeconds("received message from server");
	    print "rcvd '$msg'\n" if $opt_t and not $opt_q;
	    foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
		my @symbols = split /;/, $msg1;	# break up message
		my $entry = shift @symbols;		# first entry is an operation
		if ($entry =~ /$C_channel\:(\d+)/) {
		    if (($entry = $1) eq '1') {
			print "received '$C_channel:1'\n" if $opt_T;
			####################################################
			## Symbol Table block
			## Received Symbol table entries consist of two or three words.
			## Usually symbol-id and ftype are received. In this
			## case the ST-offset is the index. (computed by counting)
			## For ALIASes the index of the Gate to which the
			## ALIAS resolves is transmitted as a 3rd value.
			## For bit I/O names IX0.0 etc, add a second entry IX0_0
			## For number constants 0 1 etc, add a second entry _0 _1
			## For negative constants -1 etc, add a second entry __1
			####################################################
			while ($entry = shift @symbols) {
			    my ($symbol, $ftype, $index) = split " ", $entry;
			    my ($l);
			    $index = $stIndex unless defined $index;
			    print "$index\t$symbol\t$ftype\n" if $opt_T;
			    @{ $symbolTable{$symbol} } = ($ftype, $index);
			    if ($symbol =~ s/^([IQT]X\d+)\.(\d+(_\d+)?)$/$1_$2/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    elsif ($symbol =~ s/^-(\d+)$/__$1/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    elsif ($symbol =~ s/^(\d+)$/_$1/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    if ($opt_T and ($l = length $symbol) > $maxSymbolLength) {
				$maxSymbolLength = $l;
			    }
			    $stIndex++ unless ($symbol =~ /\[\s*\d+\s*\]/);
			}
		    }
		    elsif ($entry eq '2') {
			if ($runName eq '') {	# block 2nd receive of ch:2;<name>
			    print "received '$C_channel:2'\n" if $opt_T;
			    ####################################################
			    ## Application is running
			    ## The 2nd entry is the name of the running iC program.
			    ## This name allows a check against the file name of
			    ## the displayed text. (Assume it should match)
			    ## change text on run button to 'Stop'
			    ####################################################
			    $runName = shift @symbols;
			    $mainWindow->title("$named$u: $fileName$readOnly $runName");
			    info_display(2000, 'blue', "'$runName' is running");
			    $menuRun->configure(-text => 'Stop');
			    print "$named: rcvd_msg_from_server received :2 'Stop' scanFlag = '$scanFlag'\n" if $opt_T;
			    if ($scanFlag) {
				%symbolTable = ();
				print "$named: Request Symbol Table '$D_channel:1'.\n" if $opt_T;
				conn_send_now("$D_channel:1");	# request Symbol Table
			    }
			}
		    }
		    elsif ($entry eq '3') {
			print "received '$C_channel:3'\n" if $opt_T;
no warnings;
			####################################################
			## New data values
			## Data value entries consist of ST-index and value
			####################################################
			my $normalFlag = 0;			# state currently diasabled
			while ($entry = shift @symbols) {
			    my ($index, $value) = split " ", $entry;
			    my ($tRest, $cs, $tNew, $tOld);
			    ($cs, $tOld) = @{ $activeSymbols[$index] }[2, 3];
			    unless (${$tOld}[0] and ${$tOld}[1]) {
				$tOld = [gettimeofday()];	# found uninitialised values
				if ($opt_T) {
				    my ($symbol, $ft, $ix);
				    foreach $symbol (keys %symbolTable) {
					($ft, $ix) = @{ $symbolTable{$symbol} };
					if ($ix == $index) {
					    print "$symbol	($ix) ftype: $ft value: $value cs: '$cs' ### uninitialised time\n";
					    last;		# $symbol becomes undef outside loop
					}
				    }
				}
			    }
			    $activeSymbols[$index][3] = $tNew = [gettimeofday()];
			    $tRest = 50 - int(tv_interval($tOld, $tNew) * 1000);	# ms.
			    print "index: $index value: $value rest: $tRest\n" if $opt_T;
			    $cs ^= 1 if $value;			# change colour
			    $activeSymbols[$index][1] = $value;	# for value display
			    if ($activeSymbols[$index][0] & 01) {
				if ($tRest < 10) {
				    colourTag("$index", $cs);	# normal colour
				} else {
				    colourTag("$index", $cs | 010);	# flash glitch
				    ## delay the colour change to make it visible
				    $text->after(50, [ \&restoreTag, "$index" ]);
				}
				if ($cs == 5 or $cs == 7) {	# hi CLOCK or TIMER
				    ## turn colour off after 50 ms.
				    $text->after(50, [ \&colourTag, "$index", $cs & ~01 ]);
				}
			    }
			    if ($activeSymbols[$index][0] & 02) {
				$cs ^= 1;				# complement colour
				if ($tRest < 10) {
				    colourTag("$index~", $cs);	# latest $cs is saved
				} else {
				    colourTag("$index~", $cs | 010);# flash glitch
				    ## delay the colour change to make it visible
				    $text->after(50, [ \&restoreTag, "$index~" ]);
				}
			    }
			    if ($activeSymbols[$index][0] & 04) {
				my $tag = "$index=";
				my @ranges = $text->tagRanges($tag);
				print "value at index $index: $activeSymbols[$index][1] '@ranges'\n" if $opt_T;
				unless ($normalFlag) {
				    $text->configure(-state => 'normal');
				    $normalFlag = 1;	# state normal until loop end
				}
				for (my $i = 0; $i < @ranges; $i += 2) {
				    my ($beg, $end) = @ranges[$i, $i+1];
				    $text->delete($beg, $end);
				    $text->insert($beg, " $value", $tag);
				}
			    }
			    printMicroSeconds("symbol table entry");
			    print "$index	$value\n" if $opt_t and not $opt_q;
			}
			if ($normalFlag) {
			    $text->configure(-state => 'disabled');
			}
use warnings;
		    }
		    elsif ($entry eq '4') {
			####################################################
			## End of Symbol Table
			####################################################
			info_display(2000, 'blue', "'$runName' Symbol Table received");
			$stIndex = 0;		# ready for next reception
			printMicroSeconds("symbol table end");
			print "received '$C_channel:4'\n" if $opt_T;
			$scanFlag = 1;
			adjust_live(-1, -1);
		    }
		    elsif ($entry eq '5') {
			####################################################
			## Application has stopped - received :5
			####################################################
			print "received '$C_channel:5'\n" if $opt_T;
			info_display(2000, 'blue', $regName ne '' ?
			    "'$regName' was stopped" :
			    "application was stopped - not registered !?");
			clear_all();
			$runName = '';
			$mainWindow->title("$named$u: $fileName$readOnly");
			$makeName = '';
			if ($restartFlag) {
			    $restartFlag = 0;
			    run_file();	# restart after scan detects out of date build
			} else {
			    ####################################################
			    ## change text on run button to 'Run '
			    ####################################################
			    $menuRun->configure(-text => 'Run ');
			    print "$named: rcvd_msg_from_server received :5 'Run '\n" if $opt_T;
			}
			if ($scanFlag) {
			    $menuScan->configure(-text => 'wait');
			    print "$named: rcvd_messgae_from_server received :5 'wait'\n" if $opt_T;
			}
		    }
		    elsif ($entry ne '0') {	# ignore :0 messages
			print "received '$C_channel:$entry'\n" if $opt_T;
			goto Spurious;
		    }
		}
		elsif ($entry =~ /0:(\d+)/) {	# channel 0:1; warning from iCserver
		    if (($entry = $1) eq '1') {
			####################################################
			## Warning from iCserver. $msg is 0:1;<warning message>
			####################################################
			$msg =~ /^0:1;(.*)/;
			print "$named: Warning: $1\n" if $opt_T;
			info_display(2000, 'red', $1);
			last;	# used whole of $msg - ignore splits on ',' and ';'
		    }
		    elsif ($entry ne '0') {	# ignore :0 messages
			goto Spurious;
		    }
		}
		else {
		    Spurious: warn "$named: spurious operation '$entry' ???\n";
		}
		printMicroSeconds("stored one message");
	    }
	    print "rcvd end\n" if $opt_t and not $opt_q;
	}
    } else {
	print "undefined message< iCserver\n" if $opt_T;
    }
} # rcvd_msg_from_server

########################################################################
#
#	Change the tag colours
#
########################################################################

sub colourTag {
    my ($tag, $cs) = @_;
    print "colourTag: $tag $cs\n" if $opt_T;
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
    $delayedColour{$tag} = $cs;		# save colour for end of flash
} # colourTag

########################################################################
#
#	Restore the tag colour after a flash
#
#	If the value in %delayedColour were not used, another change
#	before the 50 ms flash is finished may come in and the end of
#	flash will then restore to the second last change. Now the
#	colour is saved in &colourTag and the end of the flash will
#	restore the very latest change.
#
########################################################################

sub restoreTag {
    my ($tag) = @_;
    my $cs = $delayedColour{$tag} & 07;	# latest colour ignoring flash
    print "restoreTag: $tag $cs\n" if $opt_T;
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
} # restoreTag

########################################################################
#
#	Double-click on a word to transfer it to Search entry window
#	parameter 1:	dummy for key bindings
#
#	Unfortunately this clashes with a Tk::Text binding:
#	[2] Double-clicking with mouse button 1 selects the word under the
#	   mouse and positions the insertion cursor at the beginning of the
#	   word.
#
#	In practice pick_word() is executed first and marks the selection
#	in black (search found). Underneath the Text selection is also
#	there and can be shown and used for editing by clearing the search
#	with ctrl-Return.
#
#	Double-click pick_word works well in Live mode, where the above
#	is not a problem. For this reason this feature is only active
#	in Live mode.
#
#	You may prefer to allow this in Edit mode
#	- simply comment if ($scanflag) { ... } lines
#
########################################################################

sub pick_word {
# if ($scanFlag) {	### comment to allow pick_word in Edit mode
    my $start_index = $text->index('insert wordstart');
    my $end_index = $text->index('insert lineend');
    my $line = $text->get($start_index, $end_index);
    $line =~ m/^([\w.]+)/;
    if (defined $1) {
	print "pick_word '$1'\n" if $opt_T;
	$entrySearch->focus();		# initiate search entry
	search_now(1, $1, 0);		# search for first word only
    }
# }			### comment to allow pick_word in Edit mode
} # pick_word

########################################################################
#
#	Pop up search menu from search button after 200 ms
#
########################################################################

sub SearchMenu {
    my ($dummy, $buttonRef) = @_;
    my $buttonState = $$buttonRef->cget(-state);
    my $buttonText  = $$buttonRef->cget(-text);
    if ($buttonState ne 'disabled') {
	my $xWin = $mainWindow->rootx;
	my $yWin = $mainWindow->rooty;
	print "button '$buttonText' xWin = '$xWin' yWin = '$yWin'\n" if $opt_T;
	$searchTimer = $mainWindow->after(200,
	    sub { $searchMenu->post($xWin + 276, $yWin +  32); });
    }
    print "Pop up search button '$buttonText' '$buttonState'\n" if $opt_T;
} # SearchMenu

########################################################################
#
#	Cancel search menu from search button before 200 ms are up
#
########################################################################

sub SearchCancel {
    $searchMenu->unpost();
    $searchTimer->cancel() if defined $searchTimer;
    print "Cancel search\n" if $opt_T;
} # SearchCancel

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from
#		eg: bind('<KeyPress-Return>', [ \&search_text, undef, 0 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy first parameter when called directly.
#	Use this is buttonFlag.
#
#		parameter 1:	buttonFlag - false (0) when [/] release else true
#		parameter 2:	newSearchText
#		    "		undef	use $searchText from Entry widget
#		    "		''	clear the search
#		parameter 3:	0  Search down	(default)
#		    "		1  Search up	(save searchText when clearing)
#		    "		2  Go to line
#		    "		4  Special search down - suppress search statistics
#
#	search_text() is mostly called from a pop up, which does not close,
#	until search_text() has completed execution. If the search action
#	involves scrolling, the text covered by the pop up before scrolling
#	and not covered after scrolling is left blank.
#
#	To fix this, postpone the search and scrolling action until after
#	search_text() has completed execution, by posting the callback
#	search_now(). No actual delay is necessary.
#
#	When called from build_file() to search for /^*** /, which finds Error or
#	Warning lines, suppress search statistics to retain display from build
#
########################################################################

sub search_text {
    my ($buttonFlag, $newSearchText, $direction) = @_;
no warnings;
    print "search_text: \$buttonFlag = '$buttonFlag' \$searchText = '$searchText'\n" if $opt_T;
use warnings;
    unless ($buttonFlag) {
	SearchCancel();				# do this first - no delays yet
	if ($searchText eq '' or not defined $searchText) {
	    $entrySearch->focus();		# initiate search entry (simulates vi)
	    return;
	}
    }
    $text->after(0, [ \&search_now, @_ ]);	# allow pop up to go away
} # search_text

sub search_now {
    my ($buttonFlag, $newSearchText, $direction) = @_;
    my ($saveText, $saveMatch, $option, $auxiliary, $current, $hl, $length);
    my $tmpText;
    my $suppress = $direction & 0x04;	# extract additional parameter 3 info
    $direction &= 0x03;			# remove suppress bit
    if (defined $newSearchText) {
	if ($newSearchText eq '' and $direction) {	# save search text when clearing
	    ($saveText, $saveMatch) = ($searchText, $matchType);
	}
	($searchText, $option) = split(/\t/, $newSearchText);
	$matchType = $option ? $matchRestores{$option} : '-exact';
    }
    $searchText = '' if not defined $searchText;
    $text->tagDelete('gotoTag');
    while ($direction == 2 or $matchType eq 'g') {	# really if() {.. last; ..return;}
	########################################################################
	##	Go to line $searchText (do exact match search if not numeric)
	########################################################################
	if ($searchText eq '') {
	    $searchText = $current = "1.0";
	} elsif ($searchText =~ s/^(\d+\.(\d+|end)|end).*$/$1/) {
	    $current = "$1";
	} elsif ($searchText =~ s/^(\d+).*$/$1/) {
	    $current = "$1.0";
	} else {
	    $matchType = '-exact';	# try exact match - most likely
	    last;
	}
	print "goto: '$searchText' '$current' '$matchType' $direction\n" if $opt_T;
	$matchType = 'g';
	$text->see($current);
	## grey out the whole line - until mouse moves - visible in Edit and Live mode
	$text->tagConfigure('gotoTag',
			    -background => 'grey',
			    -foreground => 'black',
			   );
	$text->tagAdd('gotoTag', "$current linestart", "$current lineend");
	$text->markSet('insert', $current);
	$text->tagLower('gotoTag');	# put any search results in foreground
	report_cursor();
	$tmpText = "$searchText$matchExtensions{$matchType}";
	check_menu($tmpText, 'searches');
	$prevText = $searchText;
	$prevMatch = $matchType;
	return;
    }
    if ($prevText ne $searchText or $prevMatch ne $matchType) {
	########################################################################
	#	Start of a new search
	########################################################################
	print "pattern: \$searchText '$searchText' \$matchType '$matchType' \$prevText '$prevText' \$prevMatch '$prevMatch'\n" if $opt_T;
	@hits = ();
	@groups = ();
	$gl = 0;
	$text->tagDelete('searchTag') if $prevText;
	$text->tagConfigure('searchTag',
			    -background => 'black',	# same as 'less' colouring
			    -foreground => 'white',	# stands out amongst live colours
			   );				# cannot see live status though except overhang
	if ($matchType eq 'ri') {
	    $matchType = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';			# fill as placeholder
	}
	$current = '1.0';
	$length = '0';

	########################################################################
	#	Actual searches storing results in @hits
	#	for every hit set a 'searchTag'
	########################################################################
	while (1) {
	    eval {
		$current = $text->search(-count => \$length,	# number of characters matched
					 $matchType,	# -exact -nocase -regexp
					 $auxiliary,	# -nocase -forwards (filler), (never search backwards)
					 '--',		# forces next argument to be pattern
					 $searchText,	# search pattern
					 $current,	# start index - moves with every iteration
					 'end',		# stop index
					);
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		info_display(0, 'red', "ERROR: $@");	# error in search
		last;
	    }
	    last unless $current and $length;		# end of pattern search or 0 length match (clear)
	    if ($opt_T) {
		my @lineinfo = $text->dlineinfo($current);
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length '@lineinfo'\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    $current =~ /(\d+)\.(\d+)/;
	    push @hits, [ $current, $1, $2, $length, ];
	    $current = $text->index("$current + $length char");	# point bejond hit
	}
	$matchType = 'ri' if $auxiliary eq '-nocase';	# otherwise radio button skips
	if (($hl = scalar @hits) > 0) {
	    if ($searchText ne '^\*\*\* ') {	# regular expression to find errors in listing
		$tmpText = "$searchText$matchExtensions{$matchType}";
		check_menu($tmpText, 'searches');
	    }
	    ########################################################################
	    #	Analyse hits and group them into display groups.
	    #   Pseudo_code for new algorithm (August 2009).
	    #
	    #	The previous 2 algorithms were much longer.
	    #	They actually missed showing some hits under some circumstances.
	    ########################################################################
	    # re-compute window details in case text and/or window has changed
	    $text->yview('moveto', 0);		# window to top left of text so bbox works
	    my ($x, $y, $w, $lineHeight) = $text->bbox("1.0");
	    print "bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
	    my $h = $text->height;		# current height of display window in pixels
	    my $height = int($h/$lineHeight);	# current height of display window in lines
	    my $endm = $text->index('end');
	    $endm =~ m/(\d+)\.(\d+)/;
	    $lineCnt = $1 - 1;			# current length of text in lines
	    my $groupFirst = undef;
	    my $prevGroupHeight = 0;
	    my ($groupHeight, $groupTop, $aRef);
	    while (($aRef = shift @hits)) {
		($current, $y, $x, $length) = @$aRef;
		if (defined $groupFirst) {
		    if (($groupHeight = $y - $groupFirst) >= $height) {
			$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
			$groupTop = 0 if $groupTop < 0;
			push @groups, $groupTop / $lineCnt;
			$groupFirst = $y;	# start of new group
			$prevGroupHeight = 0;
		    } else {
			$prevGroupHeight = $groupHeight;
		    }
		} else {
		    $groupFirst = $y;		# first item in search
		}
	    }
	    if (defined $groupFirst) {
		$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
		$groupTop = 0 if $groupTop < 0;
		push @groups, $groupTop / $lineCnt;
	    }

	    $gi = -1;				# see index
	    $gl = scalar @groups;
	    my $plural = $gl > 1 ? 's' : '';
	    info_display(1000, 'dark green', "/$searchText/ found $hl times in $gl group$plural") unless $suppress;
	    $text->tagRaise('searchTag') if $gl;	# put any search results in foreground
	}
	$prevText = $searchText;
	$prevMatch = $matchType;
	$entrySearch->focus();
    }
    ########################################################################
    #	Use @groups to scroll over the groups forwards or backwards.
    #	Initial group index is $gi = -1. Used to determine scroll start for
    #	immediate backward scroll.
    #	Even for a single group, re-position group every time RETURN is pressed,
    #	because the hits could have been moved by manual scrolling.
    ########################################################################
    if ($gl > 0) {
	my $infoFlag = ($gi < 0 or $gl < 2) ? 0 : 1;	# allows search statistics info to stay
	if (not $direction) {
	    $gi++;			# forward scroll
	    if ($gi >= $gl) {
		$gi = 0;
		if ($infoFlag) {
		    info_display(1000, 'dark red', "search hit BOTTOM, continuing at TOP");
		    $infoFlag = 0;
		}
	    }
	} else {
	    $gi--;			# backward scroll
	    if ($gi < 0) {
		if ($infoFlag and $gi == -1) {	# -2 is first time backwards
		    info_display(1000, 'dark red', "search hit TOP, continuing at BOTTOM");
		    $infoFlag = 0;
		}
		$gi = $gl - 1;
	    }
	}
	if ($infoFlag) {
	    info_display(0, 'black', '');	# clears display_info
	}
	$text->yview('moveto', $groups[$gi]);	# move forward or backward to next group
	print("moveto line @{[$lineCnt*$groups[$gi]+1]}\n") if $opt_T;
	adjust_live();
    } elsif ($gl == 0 and not $@) {	# do not overwrite search eval error message
	if ($searchText ne '') {
	    info_display(0, 'red', "/$searchText/ not found");	# report every time
	} else {
	    info_display(0, 'dark red', "search cleared");
	    if ($scanFlag) {
		$yScrollbar->focus();
	    } else {
		$text->focus();
	    }
	}
    }
    if ($saveText) {
	($searchText, $matchType) = ($saveText, $saveMatch);
    }
} # search_now

########################################################################
#
#	Clear_all
#
########################################################################

sub clear_all {
    deleteAllTags();	# also clears @activeSymbols
    %symbolTable = ();	# clear symbol table so balloons dont show
    clear_scan(1);	# detach balloon
} # clear_all

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    $text->configure(-state => 'normal');
    $text->focus();
    foreach my $index (0 .. $#activeSymbols) {
	my $ts = $activeSymbols[$index][0];
	if ($ts) {
	    if ($opt_T) {
		print(" $index")    if $ts & 01;	# normal
		print(" $index~")   if $ts & 02;	# inverted
		print(" $index=")   if $ts & 04;	# value
		print(" deleted\n");
	    }
	    if ($ts & 01) {
		$text->tagDelete("$index");
	    }
	    if ($ts & 02) {
		$text->tagDelete("$index~");
	    }
	    if ($ts & 04) {
		my $tag = "$index=";
		my @ranges = $text->tagRanges($tag);
		for (my $i = 0; $i < @ranges; $i += 2) {
		    $text->delete(@ranges[$i, $i+1]);
		}
		$text->tagDelete($tag);
	    }
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
    if ($readOnly) {
	$text->configure(-state => 'disabled');	# read-only file
    }
} # deleteAllTags

########################################################################
#
#	Live/Edit - switch between clear_scan and do_scan
#
########################################################################

sub scan {
    deleteAllTags();		# also clears @activeSymbols
    if ($scanFlag) {
	reset_scan();
    } elsif ($conn) {
	$scanFlag = 1;
	$menuScan->configure(-text => 'wait');
	print "$named: scan 'wait'\n" if $opt_T;
	if ($runName ne '') {
	    print "$named: Request Symbol Table '$D_channel:1'.\n" if $opt_T;
	    conn_send_now("$D_channel:1");	# request Symbol Table
	}
    } else {
	print "not connected ???\n" if $opt_T;
	register_now();
    }
} # scan

########################################################################
#
#	Reset $scanFlag and then clear_scan()
#		parameter 1:	1  skips clear active symbols in application
#
#    if ($opt_u) {
#	########################################################################
#	# in 'Live' mode 'variable =' displays are seen as edits which can be undone
#	# in 'Edit' mode unless the undo stack is cleared
#	########################################################################
#	$text->editReset;	# clears the undo and redo stacks for Tk::TextUndo
#    }
#    This code does not work for Tk::TextUndo ??? not imlemented for Tk::Text
#    $text->editReset does not clear the undo stack
#
########################################################################

sub reset_scan {
    if ($scanFlag) {
	$scanFlag = 0;
	$menuScan->configure(-text => 'Live');
	if ($runName ne '') {
	    clear_scan(@_);
	}
    }
} # reset_scan

########################################################################
#
#	Clear scan and detach balloon processing. Prepare for scan.
#	Clear active symbols for faster processing of connected controller
#		parameter 1:	1  skips clear active symbols in application
#
########################################################################

sub clear_scan {
    if ($balloonAttached) {
	$balloon->detach($text);
	$balloonAttached = 0;
    }
    unless (@_) {		# skip if parameter 1 set
	info_display(0, 'black', '') if $searchText eq '';	# clears display_info unless search
	if ($conn) {
	    ####################################################################
	    ## clear active symbols in connected iC controller process
	    ## reset last D_channel value in iCserver
	    ####################################################################
	    if ($runName ne '') {
		print "clear_scan() sends '$D_channel:5,$D_channel:0'\n" if $opt_T;
		conn_send_now("$D_channel:5,$D_channel:0");
	    }
	}
    }
} # clear_scan

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found and another for the inverted symbol, if required.
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program. Further updates occur, every time the
#	state of an active symbol changes.
#
#	Attach balloon processing while display is live.
#	Balloon processing is detached for a newly loaded file and when
#	the scan is cleared to allow clean editing.
#
########################################################################

sub do_scan {
    my ($current, $last) = @_;
    my ($length, $word, $i, $iw, $tag, $cs, $ts, $ftype, $index, $t, $comment);
    print "do_scan: instName = '$instName' regName = '$regName' makeName = '$makeName'\n" if $opt_T;
    if (defined $instName and $instName ne '') {
	if ($instName ne $regName) {
	    unregister_from_server();
	    register_now();	# register at new process
	    return;
	}
	if (defined $makeName and $makeName ne '') {
	    my $dialog = $text->Dialog (-title   => 'Modified build',
					-bitmap  => 'question',
					-text    => 'Start up to date build?',
					-buttons => [qw(Yes No Cancel)],
				       );
	    my $dialogBar = $dialog->Label(-textvariable => \$makeName,
					   -relief       => 'ridge',
					  )->pack(-side => 'bottom', -fill => 'x');
	    my $answer = $dialog->Show();
	    if ($answer eq 'Cancel') {
		return 0;			# cancel operation
	    } elsif ($answer eq 'Yes') {
		print "do_scan: stop '$instName' start '$makeName'\n" if $opt_T;
		stop_file();			# $runName = ''
		$restartFlag = 1;		# restart after receiving stopped message
		return 0;
	    }
	}
	if ($fileName !~ /\b$procName\./) {
	    info_display(2000, 'red',
		"WARNING: '$fileName$readOnly' does not match connected control program '$runName'");
	    $scanFlag = 0;
	    $menuScan->configure(-text => 'Live');	# no live words scanned yet
	    return;
	}
	$text->configure(-state => 'normal');
	$current = '1.0' unless defined $current;
	$last    = 'end' unless defined $last;
	$length = '0';
	while (1) {
	    $current = $text->search(-count => \$length,
				     '-regexp',
				     '--',
				     $scanPattern,
				     $current,
				     $last);
	    last if (!$current);
	    $iw = $i = $text->get($current, "$current + $length char");
	    ########################################################################
	    # Match simple variables, IEC-1131 and derivatives as well as immC array members
	    ########################################################################
	    $i =~ s/(-)?([~\t ]*)(-\s*\d+|\w[\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)([~\t ]*)/$2$7/;
	    $word = defined $1 ? "$1$3" : $3;	# word for the symbol table
no warnings;
	    $tag = "'$word' length=$length, iw='$iw' i='$i' 1='$1' 2='$2' 3='$3' 5='$5' 6='$6'\n" if $opt_T;
use warnings;
	    $word =~ s/\s//g;			# delete any white space
	    if (defined $word and $symbolTable{$word}) {
		($ftype, $index) = @{ $symbolTable{$word} };
		if (defined $index and $ftype) {
		    print $tag if $opt_T;
		    $tag = $index;		# word is in the symbol table
		    $cs = $colourSelect[$ftype]; # initial colour with ALIAS inv
		    @{ $activeSymbols[$index] }[1 .. 3] = (0, $cs & ~01, [gettimeofday()]);
		    $comment = 0;
		    foreach ($text->tagNames($current)) {
			if ($_ eq "cTag") {
			    $comment = 1;
			    last;
			}
		    }
		    if (not $comment) {
			########################################################################
			# live display outside of comments
			# only comments are tagged with 'cTag' and possibly 'sel'
			########################################################################
			while ($i =~ m/~/g) {
			    $cs ^= 1;		# complement initial colour selection
			}
			$tag .= '~' if ($ts = $cs & 01); # adjust tag name if inverted
			$ts++;			# convert to a mask 0 => 01, 1 => 02
			print "$tag	$word	'$iw'\n" if $opt_T;
			unless (($t = $activeSymbols[$index][0]) and ($t & $ts)) {
			    ## using $t | $ts causes warning of uninitialised value in (|)
			    $activeSymbols[$index][0] |= $ts; # 01|02 leaves 03 for both
			    colourTag($tag, $cs);	# initial tag colour
			}
			$text->tagAdd($tag, $current, "$current + $length char");
		    }
		    elsif ($cs == 2 and $iw =~ /[\w.]+(\s*\[\s*\d+\s*\])?\s*=$/) {
			########################################################################
			# only live display in a comment is 'symbol =' at and of a comment line
			########################################################################
			print "$tag	$word	'$iw' ftype = $ftype\n" if $opt_T;
			unless ($activeSymbols[$index][0] and $activeSymbols[$index][0] & 04) {
			    $activeSymbols[$index][0] |= 05; # for analog value display
			    colourTag($tag, 2);	# ARITH tag colour never changed
			}
			$text->tagAdd($tag, $current, "$current + $length char");
			$tag = "$index=";
			colourTag($tag, 2);	# ARITH tag colour never changed
			$current = $text->index("$current + $length char");
			$text->insert("$current lineend", " 0", $tag);
			$length = 0;
		    }
		}
		## ELSE - there may be spurious words in symbolTable with undefined data
		##        as explained in "Programming Perl 3rd ed. page 254" - IGNORE
	    }
	    $current = $text->index("$current + $length char");
	}

	####################################################################
	## Send list of active symbols to the iC control process. Only the
	## state (logic or arithmetic) for the symbols in this list need to
	## be updated for this display, since the others are not displayed.
	## It is immaterial for the control program in which logic
	## sense the symbol is displayed, except for inverted ALIASes.
	####################################################################

	my $msg = '';
	foreach $index (0 .. $#activeSymbols) {
	    if ($activeSymbols[$index][0]) {
		if ((length($msg) + length($index)) > 1393) {	# REPLY 1400 - (6+1) in tcpc.h
		    conn_send_now("$D_channel:3$msg");	# send intermediate active symbols
		    printMicroSeconds("sent one active symbol string to server");
		    print "sent '$D_channel:3$msg'\n" if $opt_t and not $opt_q;
		    $msg = '';
		}
		print "$index\n" if $opt_T;
		$msg .= ";$index";			# ch:3 max 6, term 1
	    }
	}
	if ($msg) {
	    conn_send_now("$D_channel:4$msg");		# send last active symbols
	    printMicroSeconds("sent last active symbol string to server");
	    print "sent '$D_channel:4$msg'\n" if $opt_t and not $opt_q;
	}
	conn_send_now("$D_channel:0");			# reset last value in iCserver

	####################################################################
	## Attach balloon processing
	####################################################################

	unless ($balloonAttached) {
	    $balloon->attach($text,
	       -balloonmsg      => \$bMsg,
	       -balloonposition => 'mouse', # not used since postcommand returns real position
	       -postcommand     => sub {
		    my ($word, $stem, $ftype, $index, $val, $wlen, $wlen_1);
		    ## Have a word under mouse - change the message:
		    $stem = $text->get($wIdx, "$wIdx lineend");
		    ## Skip if word starts with a non-word char
		    return 0 if not $stem or $stem =~ /^\W/;	# first character is not \w
		    print "$stem\n" if $opt_T;
		    ## Try bit I/O like IX0.0 QX10.7 or TX0.0_14 first
		    if ($stem =~ /^([IQT]X\d+\s*\.\s*[0-7](_\d+)?)/) {
			$word = $1;		# bit I/O variable found
			$wlen = length $word;
		    }
		    elsif ($stem =~ /^(\w[\w\$]*(\s*\[\s*\d+\s*\])?)/) {
			$word = $1;		# number or variable found
			$wlen = length $word;
			if ($word =~ /\d+/) {
			    $stem = $text->get("$wIdx linestart", "$wIdx + $wlen chars");
			    if ($stem =~ /((-\s*)\d+)\s*$/) {
				$word = $1;	# negative number
				$wlen = length $word;
				$wlen_1 = length $2;
				$wIdx = $text->index("$wIdx - $wlen_1 chars");
				$word =~ s/\s//g;	# delete possible white space around '-'
			    }
			}
		    } else {
			return 0;		# unlikely with \W test above
		    }
		    $word =~ s/\s//g;		# delete possible white space around '.' and '[]'
		    print "	word = $word\n" if $opt_T;
		    if (not defined ($index = $symbolTable{$word}[1])) {
			return 0;		# not found in S.T.
		    }
		    $wlen_1 = $wlen - 1;
		    $ftype = $symbolTable{$word}[0];
		    $val = $activeSymbols[$index][1]; $val = 0 unless $val;
		    print "	wlen = $wlen, val = $val, index = $index, ftype = $ftype, shift_control_state = $shift_control_state\n" if $opt_T;
		    $val ^= 1 if $colourSelect[$ftype] & 01; # inv ALIAS
		    ########################################################################
		    #	Shift/Control Key state
		    #	none			0	balloon shows value of variable
		    #	Shift_L			1	balloon shows index in S.T. (useful in checking for ALIASES)
		    #	Control_L		2	balloon shows ftype as mnemonic
		    #	Shift_L+Control_L	3	balloon shows ftype as number
		    ########################################################################
		    if ($shift_control_state == 0) {
			$bMsg = "$val";
		    } elsif ($shift_control_state == 1) {
			$bMsg = "index=$index";
		    } elsif ($shift_control_state == 2) {
			$bMsg = "ftype=$full_ftype[$ftype]";
		    } elsif ($shift_control_state == 3) {
			$bMsg = "ftype=$ftype";
		    }
		    $text->tag('add', 'sel', $wIdx, "$wIdx + $wlen chars");
		    ## a good place to put the balloon is below the last char in the word
		    my $i = $text->index("$wIdx + $wlen_1 chars");
		    my @p = $text->bbox($i);
no warnings;
		    my $x = $text->rootx + $p[0] + $p[2] - 4;
		    my $y = $text->rooty + $p[1] + $p[3] + 2;
use warnings;
		    return "$x,$y";
		},	# end of -postcommand
	       -motioncommand   => sub {
		    my $x = $text->pointerx - $text->rootx;
		    my $y = $text->pointery - $text->rooty;
		    $wIdx = $text->index("\@$x,$y wordstart");
		    if ($wIdx eq $pIdx) {
			## Same word as previous word - dont cancel the balloon.
			return 0;
		    } else {
			## New word under mouse
			## cancel it so a new balloon will be posted.
			$text->SelectionClear;
			$pIdx = $wIdx;		# save as previous word
			return 1;
		    }
		},	# end of -motioncommand
	    );		# end of attach() call
	    $balloonAttached = 1;
	}

	####################################################################
	## change text on scan button to 'View' (RO) or 'Edit'
	####################################################################

	$text->tagRaise('searchTag') if $gl;	# put any search results in foreground
	if ($readOnly) {
	    $menuScan->configure(-text => 'View');
	} else {
	    $menuScan->configure(-text => 'Edit');
	}
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
	$scanFlag = 1;		# scan successful
    } else {
	info_display(2000, 'red', "no current runnable proces");
    }
} # do_scan

########################################################################
#
#	Register_now
#
########################################################################

sub register_now {
    $scanFlag = 1;
    $menuScan->configure(-text => 'wait');
    print "$named: register_now 'wait'\n" if $opt_T;
    register_at_server();
    # will call do_scan() if connect was successful via Request S.T and :2 reply
} # register_now

########################################################################
#
#	Check if a file has been modified and needs to be saved
#
#	IF contents has changed
#	    IF Button 'Yes' is pressed
#		saves $fileName
#		changes entry box text to $fileName if successful
#		return 1 if successful else 0
#	    ELSIF Button 'No' is pressed
#		return 0
#	    ELSIF Button 'Cancel' is pressed
#		return -1
#	ELSE
#	    return 1
#
########################################################################

sub check_save {
    my $contents = $text->get("1.0", "end - 1 chars");	# whole text
    if ($contents ne $oldContents) {
	if ($opt_T) {
	    my $l1 = length $contents;
	    my $l2 = length $oldContents;
	    print "length contents = $l1, length oldContents = $l2\n";
	}
	my $dialog = $text->Dialog (-title   => 'Modified file',
				    -bitmap  => 'question',
				    -text    => 'Save modified file?',
				    -buttons => [qw(Yes No Cancel)],
				   );
	my $dialogBar = $dialog->Label(-textvariable => \$fileName,
				       -relief       => 'ridge',
				      )->pack(-side => 'bottom', -fill => 'x');
	my $answer = $dialog->Show();
	if ($answer eq 'Yes') {
	    return save_file(0, 1);	# Yes - save modified $fileName
	} elsif ($answer eq 'No') {
	    return -1;			# No - abort saving
	} elsif ($answer eq 'Cancel') {
	    return 0;			# Cancel operation
	}
    } else {
	return 1;
    }
} # check_save

########################################################################
#
#	New text clears the text area
#
########################################################################

sub new_text {
    deleteAllTags();	# also clears @activeSymbols
    reset_scan();
    if (check_save()) {
	if ($readOnly) {
	    $text->configure(-state => 'normal');	# allow clearing new file
	    $readOnly = '';				# can modify text
	}
	$text->delete("1.0", "end");
	$oldContents = '';
	$fileName = $newName;
	$mainWindow->title("$named$u: $fileName$readOnly $runName");
    }
} # new_text

########################################################################
#
#	Reload the currently loaded iC $fileName unconditionally
#	because it was (possibly) altered externally (usually by vi)
#
########################################################################

sub reload_file {
    if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|ica|lst?|c|ini)$/) {
	open_file(1, "$1.ic");
    } else {
	info_display(2000, 'red', "ERROR: no file matching '$fileName$readOnly'");
    }
} # reload_file

########################################################################
#
#	Open the list file (file.lst) for the currently loaded iC $fileName
#	Alternatively open the corresponding file.ic
#
########################################################################

sub open_list {
    if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|ica|lst?|c|ini)$/) {
	if ($4 eq 'ic') {
	    if ($scanFlag) {
		deleteAllTags();	# also clears @activeSymbols
		reset_scan(1);		# must be done before open_file, because live expands text
		$scanFlag = 1;		# restore $scanFlag
	    }
	    open_file(0, "$1.lst");
	} else {
	    open_file(1, "$1.ic");	# $1.lst not saved, since generated and RO
	}
    } else {
	info_display(2000, 'red', "ERROR: no list file matching '$fileName$readOnly'");
    }
} # open_list

########################################################################
#
#	Opens a file if possible; then loads the contents
#		parameter 1:	1:          load unconditionally (discard changes)
#				0 or undef: save first if text is altered (default)
#		parameter 2:	file_name
#				'' use getOpenFile from Tk::FBox (default)
#	$fileName is assigned new file_name if successfully opened
#	this is done, rather than returning new name because open_file is often
#	called from a call-back, where the return value cannot be used
#
#	file_name must be 2nd parameter to line up with search_text(), which
#	has a dummy 1st parameter and whose 2nd parameter searchText is also
#	supplied from a menu via a closure set up in check_menu()
#	both are called via check_menu()
#
#	If a file is read-only, $readOnly is set, which executes
#		$text->configure(-state => 'disabled');
#	when going to Edit mode - also stops save but not saveAs
#
########################################################################

sub open_file {
    my ($unconditional, $fName) = @_;	# optional parameters
no warnings;
    print "open_file: \$unconditional = '$unconditional' \$fName = '$fName'\n" if $opt_T;
use warnings;
    $unconditional = 0 unless $unconditional;	# stops trace errors
    my $ci = 0;
    my $no = 0;
    unless (defined $fName and $fName ne '') {
	$fName = $mainWindow->getOpenFile(-filetypes => $fileTypes);
	unless (defined $fName and $fName ne '') {
	    print "open_file: $unconditional no file selected\n" if $opt_T;
	    info_display(2000, 'red', "no file selected");
	    return;			# global $fileName is not altered
	}
	$fName =~ s#^C:/cygwin## or $fName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	$fName =~ s#^$cwd/##;
    }
    if ($unconditional or $fName ne $fileName) {
	print "open_file: $unconditional $fName\n" if $opt_T;
	my $rName = $runName;
	$rName =~ s/-\d+//;		# check without instance number
	if ($rName and $fName !~ /^$rName/) {
	    # old file is running and is not derived from new file
	    info_display(2000, 'red', "'$runName' is still running - should be stopped unless compatible with '$fName'");
	    my $dialog = $text->Dialog (-title   => 'Still running',
					-bitmap  => 'question',
					-text    => 'Stop executable?',
					-buttons => [qw(Yes No Cancel)],
				       );
	    my $dialogBar = $dialog->Label(-textvariable => \$runName,
					   -relief       => 'ridge',
					  )->pack(-side => 'bottom', -fill => 'x');
	    my $answer = $dialog->Show();
	    if ($answer eq 'Yes') {
		print "open_file: open '$fName' stop '$runName'\n" if $opt_T;
		stop_file();			# $runName = ''
	    } elsif ($answer eq 'No') {
		print "open_file: open '$fName' leave '$runName'\n" if $opt_T;
		$no = 1;
	    } else {				# 'Cancel'
		info_display(2000, 'blue', "'$fName' was not loaded - '$runName' is still running");
		return 0;			# cancel operation
	    }
	}
	if ($unconditional or check_save()) {
	    stat($fName);
	    if (-f _ and -r _ and open(FH, "$fName")) {
		if ($scanFlag) {
		    deleteAllTags();		# required here to clear = values in text
		    clear_scan();		# $text -state now 'normal' for reading file
		}
		if ($readOnly) {		# applies to previously opened file
		    $text->configure(-state => 'normal');	# allow overwriting with new file
		}
		$readOnly = (-w _) ? '' : ' (RO)';	# set new read-only flag correctly
		print "$fName is read-only\n" if $readOnly and $opt_T;
		$text->tagDelete('cTag', 'bd');	# ->delete really slow if not done
		$text->delete("1.0", "end");	# clear the text area
		$oldContents = '';
		while (<FH>) {
		    $oldContents .= $_;
		}
		close(FH);
		## read last modified time from new stat now in case it changed since last stat
		$fileTime = (stat($fName))[9]; $fileTime = 0 unless defined $fileTime;
		$text->insert("end", $oldContents);
		my $length = length $oldContents;
		$fileName = $fName;	# alter global $fileName
		$mainWindow->title("$named$u: $fileName$readOnly $runName");
		tagComments();
		info_display(2000, 'black', "File $fileName$readOnly, $length bytes loaded");
		if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|ica|lst?|c|ini)$/) {
		    my ($s1, $s3, $s4) = ($1, $3, $4);
		    $procName = $s3;
		    if ($s4 eq 'ic') {
			$menuFile->entryconfigure(4, -label => "$s1.lst");
			check_menu($fileName, 'files');		# save ic name in file menu
		    } else {
			$menuFile->entryconfigure(4, -label => "$s1.ic");
			if ($s4 eq 'ica') {
			    check_menu($fileName, 'files');	# save ica name in file menu
			}
		    }
		    unless ($no) {
			$instName = "$procName$instanceText";	# previous executable was stopped
			$ci = change_instance();
			adjust_live(-1, -1);
		    }
		}
		$prevText = '';		# start a new search
		if ($readOnly) {
		    $text->configure(-state => 'disabled');	# read-only file
		}
		return if $ci;		# global $fileName and application has altered
	    } else {
		print "open_file: $unconditional ERROR: Could not open $fName\n" if $opt_T;
		check_menu($fName, 'files', 1);		# delete fName in the menu
		info_display(2000, 'red', "ERROR: Could not open $fName");
	    }
	}
	adjust_live();
    }
    return;
} # open_file

########################################################################
#
#	Saves the file previously loaded or last saved
#		2nd parameter:	1 overwrite file unconditionally (new destination)
#				0 or '' overwrite if contents has changed (default)
#
########################################################################

sub save_file {
    my $ret = 1;		# good return
    if (defined $fileName and $fileName ne $newName and $fileName ne '') {
	my ($unconditional) = $_[1];	# optional 2nd parameter
	my $ftime = (stat($fileName))[9]; $ftime = $fileTime unless defined $ftime;
	## allow non existing file to be written by setting to $fileTime if undef
	if ($ftime != $fileTime) {
	    info_display(2000, 'red', "'$fileName$readOnly' modified in background");
	    my $dialog = $text->Dialog (-title   => 'Modified since reading file',
					-bitmap  => 'question',
					-text    => 'Save to modified file?',
					-buttons => [qw(Yes No)],
				       );
	    my $dialogBar = $dialog->Label(-textvariable => \$fileName,
					   -relief       => 'ridge',
					  )->pack(-side => 'bottom', -fill => 'x');
	    my $answer = $dialog->Show();
	    if ($answer ne 'Yes') {
		info_display(2000, 'red', "'$fileName$readOnly' modified in background - not written");
		return 0;	# No or Cancel - report error
	    }
	    $unconditional = 1;	# definitely write to modified file
	}
	deleteAllTags();	# also clears @activeSymbols
	reset_scan(1);		# take away all live text
	my $contents = $text->get("1.0", "end - 1 chars");
	if ($unconditional or $contents ne $oldContents) {
	    ## test read-only. then rename to backup if $fileName exists
	    ## stat was done above
	    if (-f _ and not -w _) {
		info_display(2000, 'red', "ERROR: Could not save read-only file '$fileName$readOnly'");
		$ret = 0;	# error return
	    }
	    elsif (-f _ and not rename $fileName, "$fileName.bak") {	# is writable
		info_display(2000, 'red', "ERROR: Could not rename backup to '$fileName.bak'");
		$ret = 0;	# error return
	    }
	    elsif (open(FH, ">$fileName")) {
		$oldContents = $contents;
		my $length = length $oldContents;
		print FH $oldContents;
		close(FH);
		if ($readOnly) {
		    $text->configure(-state => 'normal');	# new writable file
		    $readOnly = '';				# can modify text
		}
		## read last modified time from new stat now as it changed since last stat
		$fileTime = (stat($fileName))[9]; $fileTime = 0 unless defined $fileTime;
		$mainWindow->title("$named$u: $fileName$readOnly $runName");
		tagComments();					# comments and/or keywords may have changed
		info_display(2000, 'black', "File $fileName$readOnly, $length bytes saved (backup $fileName.bak)");
		check_menu($fileName, 'files');
	    } else {
		info_display(2000, 'red', "ERROR: Could not open '$fileName$readOnly' for writing");
		$ret = 0;	# error return
	    }
	} else {
	    info_display(2000, 'blue', "File '$fileName$readOnly' has not changed - not written");
	}
    } else {
	$ret = saveAs_file();
    }
    return $ret;
} # save_file

########################################################################
#
#	Save file to suggested $fileName or to another selected file_name
#		return:		1  file successfully saved, instance is reset
#				0  failure - $fileName not changed
#	$fileName is assigned new file_name if successfully saved
#
########################################################################

sub saveAs_file {
    my $ret = 1;
    my $oldName = $fileName;
    $fileName = $mainWindow->getSaveFile(-filetypes => $fileTypes,
					 -initialfile => $fileName);
    if (defined $fileName and $fileName ne '') {
	if ($fileName ne $oldName) {
	    my $ftime = (stat($fileName))[9]; $ftime = $fileTime unless defined $ftime;
	    ## allow non existing file to be written by setting to $fileTime if undef
	    $fileTime = $ftime;
	}
	$fileName =~ s#^C:/cygwin## or $fileName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	$fileName =~ s#^$cwd/##;
	print "saveAs_file: $fileName\n" if $opt_T;
	if (save_file(0, $fileName ne $oldName) == 0) {
	    ## could not save $fileName
	    $fileName = $oldName;	# restore fileName
	    $mainWindow->title("$named$u: $fileName$readOnly $runName");
	    $ret = 0;
	} elsif ($fileName ne $oldName) {
	    if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|ica|lst?|c|ini)$/) {
		$procName = $3;
		$instanceText = $instance = '';		# reset instance
		$instName = "$procName$instanceText";
		change_instance();
	    }
	    $prevText = '';		# start a new search
	}
    } else {
	info_display(2000, 'red', "no file saved");
	$fileName = $oldName;	# restore fileName
	$ret = 0;
    }
    return $ret;
} # saveAs_file

########################################################################
#
#	Build a target file generated from $fileName (C file or executable)
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate a new target file if target is older than $fileName
#	or unconditional build was specified.
#
#	2nd parameter:	0   Build executable
#			1   Save & Build unconditionally
#			2   Build C file only
#
########################################################################

sub build_file {
    my $par2 = $_[1];
    my $saved = 0;
    if ($fileName !~ /(^[\w\.\\\/]+)\.ica?/) {
	info_display(2000, 'blue', "WARNING: cannot build '$fileName$readOnly' (must end in .ic or .ica)");
    } else {
	my $baseName = $1;
	my $buildName = "$fileName$readOnly";	# $fileName will change in open_file() if error
	my $targetName = $par2 == 2 ? "$baseName.c" : $baseName;
	deleteAllTags();		# also clears @activeSymbols
	reset_scan(1);			# must be done before save_file, because live expands text
	if ($par2 == 1) {
	    $saved = save_file(0, 1);	# save unconditionally
	} else {
	    $saved = check_save();
	    info_display(2000, 'dark green', "'$targetName' was not saved - no new build") if $saved < 0;
	}
	if ($saved > 0) {
	    my $ftime = (stat($fileName))[9]; $ftime = 0 unless defined $ftime;
	    my $mtime = (stat($targetName))[9]; $mtime = 0 unless defined $mtime;
	    my $ret = 0;
	    if ($par2 == 1 or $mtime < $ftime) {
		## system() requires signal CHLD to notify completion
		$SIG{CHLD} = 'DEFAULT';
		my @args = ("iCmake", "-qfasAd200", $fileName, "2>&1");	# -A useful for live display
		if ($par2 == 2) {		# link with static (debug) library - generate // x =
		    splice(@args, 1, 0, '-b');	# iCmake -b to suppress making executable
		} else {
		    my $lib;
		    my $i = 1;
		    foreach $lib (@opt_L) {
			splice(@args, $i, 0, '-L', $lib);	# add BUILD library options
			$i += 2;
		    }
		}
		print STDERR "\$ @args\n" unless $opt_q;
		my @errText = qx(@args);	# execute iCmake ...
		$ret = $? >> 8;
		my $len = @errText;
		my $gr = grep /^\*\*\* /, @errText;
		print "ret = $ret, len = $len, *** = $gr\n" if $opt_T;
		print STDERR @errText;
		$SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
		if ($ret or $gr) {
		    select undef, undef, undef, 2;
		    # iCmake += 20 for immac errors : += 1 for immcc errors
		    my $listName = $ret >= 20 ? "$baseName.ic" : "$baseName.lst";
		    open_file(1, $listName);	# load the generated file (iC is up to date)
		    $searchText = '^\*\*\* ';	# regular expression to find errors in listing
		    $prevText = '';		# start a new search
		    $matchType = '-regexp';	# NOTE: $fileName has changed
		    search_now(1, undef, 4);	# carry out the search, setting markers but no info display
		}
		if ($ret) {
		    info_display(2000, 'red',
			"ERROR: '$targetName' cannot be built from '$buildName' (return = $ret)");
		    warn "ERROR: '$targetName' cannot be built from '$buildName' (return = $ret)\n";
		} else {
		    if ($runName ne '') {
			$makeName = $targetName;# running process is not current build
		    }
		    my $build_warnings;
		    if ($gr) {
			$build_warnings = "built with $gr Warnings - can be run";
			warn "WARNING: '$targetName' $build_warnings\n";
			$build_warnings .= " after pressing Alt-l";
		    } else {
			$build_warnings = "successfully built";
		    }
		    info_display(2000, 'dark green', "'$targetName' $build_warnings");
		}
	    } else {
		info_display(2000, 'blue', "'$targetName' is up to date");
	    }
	} # ELSE operation was cancelled by check_save() or file could not be saved
    }
} # build_file

########################################################################
#
#	Start a new search with / or ALT-/ to simulate vi
#
########################################################################

sub new_search {
    print "new_search\n" if $opt_T;
    $searchText = '';		# clears search entry window
    search_text(0, '', 0);	# puts focus in search entry window
} # new_search

########################################################################
#
#	Scroll text left or right with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_x_text {
    my ($dummy, $increment) = @_;
    print "scroll_x increment = '$increment'\n" if $opt_T;
    $text->xview('scroll', $increment, 'units');
    adjust_live();
} # scroll_x_text

########################################################################
#
#	Scroll text up or down with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_text {
    my ($dummy, $increment) = @_;
    print "scroll increment = '$increment'\n" if $opt_T;
    $text->yview('scroll', $increment, 'units');
    adjust_live();
} # scroll_text

########################################################################
#
#	Position text Home or End
#
########################################################################

sub position_text {
    my ($dummy, $position) = @_;
    print "scroll position = '$position'\n" if $opt_T;
    $text->see($position);
    adjust_live();
} # position_text

########################################################################
#
#	Increase or decrease font size
#
#	change normal text font (includes underline text)
#	change 'bd' tagged words which are bold
#	do not change miscellanous button text fonts
#
########################################################################

sub change_font {
    my ($dummy, $increment) = @_;
    $fontSize += $increment;			# initial or new fontSize
    if ($fontSize < 8 || $fontSize > 22) {
	$fontSize -= $increment;		# keep fontSize within limits
    } else {
	print "font increment = '$increment' size = '$fontSize'\n" if $opt_T;
	$font       = $font_t;
	$boldfont   = $boldfont_t;
	$font       =~ s/fontSize/$fontSize/;	# no change if -F was a specified font
	$boldfont   =~ s/fontSize/$fontSize/;
	if ($increment) {
	    $text->configure(-font => $font);	# re-configure only for changed fonts
	    $text->tagConfigure('bd',  -font => $boldfont);
	    info_display(0, 'black', "font size $fontSize");
	}
    }
} # change_font

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    select undef, undef, undef, 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    print STDERR "\$ @_ &\n" unless $opt_q;
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Fork to the help process
#
########################################################################

sub fork_help {
    fork_and_exec('iCman', '-n', $named);
} # fork_help

########################################################################
#
#	Stop or run the executable file generated from $fileName
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate name of executable file from $fileName
#	run executable if it exists, is executable and newer than source
#
########################################################################

sub run_file {
    if ($runName ne '') {
	## running - stop application
	stop_file();
    } elsif ($fileName !~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|ica|lst?|c|ini)$/) {
	info_display(2000, 'blue', "WARNING: cannot run '$fileName$readOnly' (must end in .ic .ica .lst .c or .ini)");
    } elsif ($4 ne 'ic' or check_save()) {
	my $processName = $1;		# full path name of executable
	$procName = $3;			# execuatble without directory path
	if ($processName eq $procName) {
	    $processName = "./$processName";	# in case . is not in $PATH
	}
	deleteAllTags();		# also clears @activeSymbols
	clear_scan(1);
	print "run_file: $processName from $fileName\n" if $opt_T;
	my $ftime = (stat($fileName))[9];
	my $mtime = (stat($processName))[9];
	if (not -f _) {
	    info_display(2000, 'red', "ERROR: no file named '$processName' (Build it first)");
	} elsif (not -x _) {
	    info_display(2000, 'red', "ERROR: '$processName' not executable ??");
	} elsif ($mtime < $ftime) {
	    info_display(2000, 'blue', "WARNING: '$processName' is older than '$fileName$readOnly' (Build again)");
	} else {
	    $instName = "$procName$instanceText";
	    print "$named: register_at_server before fork_and_exec '$processName'\n" if $opt_T;
	    register_at_server();	# in case newly started
	    ## generate the call
	    $makeName = '';	# up to date build is running (unless deliberate No save)
	    my @call = ($processName);
	    splice @call, 1, 0, "-s", $opt_s if defined $opt_s;
	    splice @call, 1, 0, "-p", $opt_p if defined $opt_p;
	    splice @call, 1, 0, "-t" if defined $opt_t;
	    splice @call, 1, 0, "-d$opt_d" if defined $opt_d;
	    splice @call, 1, 0, "-m" if defined $opt_m;
	    splice @call, 1, 0, "-i$instance" if (defined $instance and $instance ne '');
	    splice @call, 1, 0, "-d1000";	# do not trace non-active timers TX0.n
	    splice @call, 1, 0, "-q" if $opt_q;	# allow user to control and stop app (no -z)
	    print "@call\n" if $opt_T;
	    ## fork and exec the call
	    fork_and_exec(@call);	# if application starts it will send back <ch>:2;<name>
	}
    } # ELSE operation was cancelled by check_save()
} # run_file

########################################################################
#
#	Stop the control program if connected
#
########################################################################

sub stop_file {
    info_display(2000, 'blue', "'$runName' stopping");
    if ($scanFlag) {
	conn_send_now("$D_channel:5");		# GET_END - clear S.T.
	$menuScan->configure(-text => 'wait');	# was 'Edit'
	print "$named: stop_file 'wait'\n" if $opt_T;
    }				# leave scanButton as 'Edit' if not $scanFlag
    conn_send_now("$D_channel:6,$D_channel:0");	# STOP_PROGRAM
    # receives "$C_channel:5" from application when it quits - sets 'Run ' then
} # stop_file

########################################################################
#
#	Change instance selection
#
########################################################################

sub change_instance {
    if ($instName ne $regName or $oldInstance ne $instanceText) {
	print "$named: change_instance from '$oldInstance' to '$instanceText'\n" if $opt_T;
	$instName = "$procName$instanceText";
	print "$named: from regName '$regName' to instName '$instName'\n" if $opt_T;
	unregister_from_server();
	register_at_server();
	####################################################
	## change text on run button to 'Run '
	####################################################
	$menuRun->configure(-text => 'Run ');
	$runName = '';		# if :2 is received will change back to <name>
	$mainWindow->title("$named$u: $fileName$readOnly");
	print "$named: change_instance 'Run '\n" if $opt_T;
	$oldInstance = $instanceText;
	if ($scanFlag) {
	    $menuScan->configure(-text => 'wait');
	    print "$named: change_instance scan to 'wait'\n" if $opt_T;
	}
	return 1;
    }
    return 0;
} # change_instance

########################################################################
#
#	check_menu (newEntry, menuKey[, delete])
#	Enter a new value into a particular menu
#	    iniMenuData{menuKey} ==> [
#		menuRef,	# [0]
#		entriesArray,	# [1]
#		menuPos,	# [2]
#		entriesLim,	# [3]
#		commandRef,	# [4]
#	    ]
#	'newEntry' is appended to (or moved to the bottom of) the 'menuKey' menu
#	when 'delete' is set, 'newEntry' in the menu is deleted and not replaced
#
#	Maintain local arrays @dynamicFiles and @dynamicSearches to map a regular
#	expression index pattern to a positional number, which can be used to
#	index menu entries with a numerical index. Entries in these local arrays
#	are always pushed on the end for new entries, shifted from the front to
#	delete the oldest entry, or spliced out to delete a previous entry from
#	the middle. A linear search in these arrays must be used to locate old
#	entries. A hash is not suitable, because several entries change their
#	numerical index every time an old entry is spliced out of the middle or
#	shifted from the front.  But since the number of entries (entriesLim) is
#	limited, this is not a serious drawback. These arrays, which are accessed
#	from 'iniMenuData' via 'entriesArray' parallels the arrays used internally
#	by the Tk menu system can be used to count and locate the numerical index
#	of dynamic menu entries.
#
########################################################################

sub check_menu {
    my ($newEntry, $menuKey, $delete) = @_;
    my $menuData = $iniMenuData{$menuKey};
    my ($menuRef, $entriesArray, $menuPos, $entriesLim, $commandRef) = @$menuData;

    my $e;
    my $n = 0;
    foreach $e (@$entriesArray) {
	if ($e eq $newEntry) {			# find newEntry in entriesArray
	    $e = splice(@$entriesArray, $n, 1);	# remove from middle of entriesArray
	    die "entry '$e' in entriesArray does not match call parameter '$newEntry', stopped" if $e ne $newEntry;
	    my $label = $menuRef->entrycget($menuPos+$n, '-label');	# check algorithm
	    die "entry '$e' in entriesArray does not match menu entry '$label', stopped" if $e ne $label;
	    print "check_menu: [$menuKey] '$e' removed from position $n of menu\n" if $opt_T;
	    $menuRef->delete($menuPos+$n) if $menuRef;	# delete old entry from menu
	    last;				# avoids indexing with a pattern, which fails
	}
	$n++;
    }
    push(@$entriesArray, $newEntry) unless $delete;	# add to end of entriesArray

    if ($opt_T) {
	if ($delete) {
	    print "check_menu: [$menuKey] '$newEntry' deleted\n";
	} else {
	    print "check_menu: [$menuKey] '$newEntry' added\n";
	}
    }
    if ($menuRef and not $delete) {		# menu for 'file' and 'searches' not 'last open file'
	if ($commandRef) {
	    print "check_menu: \$menuRef=$menuRef ->command(-label=>'$newEntry',-command=>['$commandRef',2,'$newEntry',0]\n" if $opt_T;
	    $menuRef->command(-label   => "$newEntry",	# must use local $newEntry below
			      -command => [ $commandRef, 2, $newEntry, 0 ]); # define 0 (down for search)
	}
	if (scalar @$entriesArray > $entriesLim) {
	    $e = shift(@$entriesArray);		# remove first entry in entriesArray
#	    my $label = $menuRef->entrycget($menuPos, '-label');	# check algorithm
#	    die "entry '$e' in entriesArray does not match menu entry '$label', stopped" if $e ne $label;
	    print "check_menu: [$menuKey] '$e' removed from front of menu\n" if $opt_T;
	    $menuRef->delete($menuPos);		# remove first dynamic menu entry
	}
    }
} # check_menu

########################################################################
#
#	Initialise the program by reading ~/.iC/iClive.ini if it exists
#	and initialising file list and search list in menus
#	IF there are no file arguments, open the last open file
#	ELSE	open the first file in the argument list
#		add any others to the file menu list
#
#	structure of ~/.iC/iClive.ini
#	[files]
#		sort5.ic
#		sort5.lst
#		/tmp/trial.ic
#	[last open file]
#		sort5.ic		# last open file
#		27.4			# line #
#		1			# instance
#	[searches]
#		pip			# default match type is -exact
#		[files]			# a curious -exact match
#		timer		i	# match type -nocase (<tab>i)
#		QX[\d+]\.[\d+]	r	# match type -regexp (<tab>r)
#		ix[\d+]\.[\d+]	ri	# is resolved to -regexp -nocase
#
#	since tabs cannot be entered in the search entry box (skips to Text window)
#	use <tab> followed by search option in the search menu list
#	also precede each ini item by <tab>, since [files] may be a
#	legitimate search expression (watch Goedel here)
#
########################################################################

sub ini_program {
    my ($menuData, $menuKey, $entry, $initialFile, $position, $home);
    ## restore file and search menu lists from ~/.iC/iClive.ini
    if (($home = $ENV{HOME}) ne '' and
	(-d "$home/.iC") and
	open(INI, "$home/.iC/$named.ini")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$menuKey = $1;			# key found
		$menuData = $iniMenuData{$menuKey};
		print "ini_program: menuKey [$menuKey] found\n" if $opt_T;
	    } elsif ($menuData and s/^\t(.*)$/$1/) {	# ini starts with <tab>
		$entry = $_;
		check_menu($entry, $menuKey);	# insert dynamic entries from ini file
	    }
	}
	close(INI);
    }	# ignore if ~/.iC/iClive.ini cannot be opened or found
    $initialFile = shift @argv;			# ARGV may be empty
    unless (defined $initialFile and $initialFile ne '') {
	($initialFile, $position, $entry) = @lastFile;
	if (not defined $entry and defined $position and $position =~ /^\d+$/) {
	    $entry = $position;
	}
	if (defined $position and $position !~ /^\d+\.\d+$/) {
	    $position = undef;
	}
no warnings;
	print "initialFile = '$initialFile' position = '$position' instance '$entry'\n" if $opt_T;
use warnings;
	if (defined $initialFile and not defined $opt_i) {
	    $instance = $entry;
	    if (defined $instance and $instance ne '') {
		$instanceText = "-$instance";
		if ($instance !~ /^[0-9]$/) {
		    push @instanceOptions, [$instanceText, $instance];
		    $menuInst->configure(-options => \@instanceOptions);
		}
	    }
	}
    }
    if (defined $initialFile and $initialFile ne '') {
	open_file(0, $initialFile);
    }
    if (defined $position and $position ne '' and $position ne "1.0") {
	$text->see($position);			# Tk has segmentation fault if $position eq ''
	## grey out the whole line - until mouse moves
	$text->tagAdd('sel', "$position linestart", "$position lineend");
    } else {
	$position = "1.0";
    }
    $text->markSet('insert', $position);
    foreach $initialFile (@argv) {
	check_menu($initialFile, 'files');	# stuff the rest in the file menu list
    }
} # ini_program

########################################################################
#
#	Quit program after checking if file needs saving
#	and current file and search menu lists have been written
#
#	Care has been taken, that the hash indices $fileName, $position
#	and $instance can never be the same - they have different signatures
#		$fileName	\w+\.(ic|lst|c)
#		$position	\d+\.\d+
#		$instance	\d+
#	It is of course possible to fudge a filename like "0", which clashes
#	with instance 0. But "0" should be the executable built from "0.ic".
#
########################################################################

sub quit_program {
    my ($menuKey, $entriesArray, $entry, $home);
    deleteAllTags();	# also clears @activeSymbols
    clear_scan();
    if (check_save()) {
	@lastFile = ();		# in case not fully shifted in ini_program due to $opt_i
	if (defined $fileName and $fileName ne $newName and $fileName ne '') {
	    push(@lastFile, ($fileName, $text->index('insert')));
	    if (defined $instance and $instance ne '') {
		push(@lastFile, $instance);
	    }
	}
	## save file and search menu lists to ~/.iC/iClive.ini
	if (($home = $ENV{HOME}) ne '' and
	    (-d "$home/.iC" or mkdir "$home/.iC") and
	    open(INI, ">$home/.iC/$named.ini")) {
	    foreach $menuKey (sort keys %iniMenuData) {
		print INI "[$menuKey]\n";
		print "INI: [$menuKey]\n" if $opt_T;
		$entriesArray = @{$iniMenuData{$menuKey}}[1];	# entriesArray
		foreach $entry (@$entriesArray) {
		    if (defined $entry and $entry ne '') {
			print INI "\t$entry\n";
			print "INI:	$entry\n" if $opt_T;
		    }
		}
	    }
	    close(INI);
	} else {
	    warn "ERROR: Can't open ~/.iC/$named.ini: $!\n";
	}
	print "$named: quit\n" if $opt_T;
	if ($server > 0) {
	    print "quit_program() sends 'X$named'\n" if $opt_T;
	   conn_send_now("X$named") if $conn;	# iClive started iCserver - stop it
	} elsif ($runName ne '') {
	    print "quit_program() sends '$D_channel:7,$D_channel:0'\n" if $opt_T;
	    conn_send_now("$D_channel:7,$D_channel:0");
	    ####################################################
	    ## causes application to send C_channel:2;<name>
	    ## is available in iCserver for next iClive start
	    ####################################################
	}
	print "quit_program() \$maindWindow->destroy()\n" if $opt_T;
	$mainWindow->destroy();
	print "quit_program() exit(0)\n" if $opt_T;
	exit(0);
    }
    ## continue if check_save() was cancelled
} # quit_program

########################################################################
#
#	Compute and print elapsed microseconds (activated by $opt_m)
#
########################################################################

sub printMicroSeconds {
    if ($opt_m) {
	my ($string) = @_;
	my ($sec, $usec);
	my $t1 = [gettimeofday()];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t and not $opt_q) {
	    printf "D%3d.%03d,%03d: %s:", $sec, int($usec/1000), $usec%1000, $string;
	} else {
	    printf "D%3d.%03d,%03d %s\n", $sec, int($usec/1000), $usec%1000, $string;
	}
    } elsif ($opt_t and not $opt_q) {
	print "D: ";
    }
    $t0 = [gettimeofday()];
} # printMicroSeconds

########################################################################
#
#	Output Symbol Table for debugging purposes
#	called by extra Build menu items activated by $opt_T
#
#	parameter 1	(ignore)
#	parameter 2	sorting order: 0 by name	1 by index
#
########################################################################

sub output_symbol_table {
    my $par2 = $_[1];
    if ($runName ne '') {
	my ($symbol, $index, $previndex);
	$previndex = -1;
	if ($par2 == 0) {
	    print "\nSymbol Table '$runName' by name\n";
	    print "-- ", "-" x $maxSymbolLength, " ----\n";
	    printf "%2s %-*s %4s\n", "ft", $maxSymbolLength, " name", "ix ";
	    print "-- ", "-" x $maxSymbolLength, " ----\n";
	    foreach $symbol (sort keys %symbolTable) {
		printf "%2s %-*s %4d\n",
		    $abbrevSelect[$symbolTable{$symbol}[0]],
		    $maxSymbolLength, $symbol,
		    $symbolTable{$symbol}[1];
	    }
	}
	elsif ($par2 == 1) {
	    print "\nSymbol Table '$runName' by index\n";
	    print "---- -- ", "-" x $maxSymbolLength, " -- ", "-" x $maxSymbolLength, "\n";
	    printf "%4s %2s %-*s %2s %-*s .. ...\n", "ix ",
		"ft", $maxSymbolLength, " name",
		"ft", $maxSymbolLength, " name";
	    print "---- -- ", "-" x $maxSymbolLength, " -- ", "-" x $maxSymbolLength;
	    foreach $symbol (sort {
				$symbolTable{$a}[1] <=> $symbolTable{$b}[1]
				||
				$a cmp $b
			    } keys %symbolTable)
	    {
		$index = $symbolTable{$symbol}[1];
		if ($index != $previndex) {
		    printf "\n%4d %2s %-*s", $index,
			$abbrevSelect[$symbolTable{$symbol}[0]],
			$maxSymbolLength, $symbol;
		    $previndex = $index;
		} else {
		    printf " %2s %-*s",
			$abbrevSelect[$symbolTable{$symbol}[0]],
			$maxSymbolLength, $symbol;
		}
	    }
	    print "\n";
	}
    } else {
	info_display(2000, 'red', "No Symbol Table - not connected to a running control program");
    }
} # output_symbol_table
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iClive - an editor and live debugger for immediate-C clients

=head1 SYNOPSIS

 iClive [ -umtTqh][ -s <host>][ -p <port>][ -i <inst>][ -F <font>][ -l <num>]
        [ -w <num>][ -g <geometry>][ -A <cmd>][ -d <deb>][ <file> ...]
        [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -s host host name of server    (default 'localhost')
    -p port service port of server (default '8778')
    -i inst initial instance selection (default ''; 1 to 3 numeric chars)
    -F font font or font size to use in Text window (default '20')
    -u      use edit undo facility (not recommended if using Live display)
    -l num  height of the Text window (default 35)
    -w num  width  of the Text window (default 85) -w0 is terminal width
    -g geom geometry for main window
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients (default 'iCbox')
            if iCsever is started by this iClive call
                      BUILD option
    -L<lx>  link extra library(s) eg -L lm -L rt or -L lm,lrt
                      DEBUG options
    -d deb  extra debug options (see iC-application -h)
    -t      trace gate activity in target application (-d1100)
    -m      output elapsed time in seconds and microseconds
    -T      trace output static debug messages
    -q      quiet - do not report clients connecting and disconnecting
    -h      help, ouput this Usage text only
    file ... one or more iC source files. The first will be opened. The
            rest will be stored in the File menu for later selection.
                      AUXILIARY app
    -R <app ...> run auxiliary app followed by -z and its arguments
                 as a separate process; -R ... must be last arguments.

 Menu buttons:                   Action                      Accelerator

    [File] ---- tear-off - menu can be moved and left open
       New      empty file for editing                            Alt-n
       Open     and load the selected file                        Alt-o
       Reload   the current file (usually modified externally)    Alt-R
       Swap.lst switch beteen iC-source and iC-Listing            Alt-l
       Save     the current file if modified                      Alt-s
       SaveAs   store the current file at the selected path       Alt-a
       Quit     the program                                       Alt-q
       -------- this is followed by a history of previous programs,
                which can be selected randomly

    [Build]     build the C file and then optionally the executable
                from the currently displayed iC program text.     Alt-b

    [Run Stop]  run or stop the executable application built from the
                currently displayed iC program text.              Alt-r

    [  -]       select no instance or -0 to -9 or extra instance passed
                with -i option. Run and Live use the selected instance.

    [Live       scan the text and generate live markings for all words,
                which represent variables in the currently running
                application - which should be built from the text
                to make a meaningful display. Text is 'read only'
                in this mode.                                     Alt-e
     Edit]      clears live markings in the Text window. In this mode
                the text may be edited with the facilities of Tk::Text,
                which is a full featured editor. The edit facilities
                are described in the Tk::Text man page or below under
                the heading 'KEYBOARD BINDINGS'.  If called with the
                -u option, ctrl-U is the <<Undo>> binding.

    [ / ]       Put focus in Search Entry window if cleared.      Alt-/
                    (simulates vi)
                Else start or continue a search of text in
                the Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options and a history of previous searches.
       Search down      or                                       RETURN
                displays a new group of hits.
       Search up        or                                    Shift-RET
                reverses the direction of displaying hits.
       Clear            or double-click search Entry window or Ctrl-RET
                clears hits and the search Entry window.
     <>Go to line       or                                      Alt-RET
                goes to the line entered in the Entry window.
     <>Exact match
     <>Ignore case
     <>Regexp match
     <>Regexp+ignore case
       -------- this is followed by a history of previous search
                strings, which can be selected for a repeat search.

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Help]      Display this man page.                            Alt-h

=head1 DESCRIPTION

B<iClive> is an Integrated Development Environment (IDE) for editing
and debugging iC programs.

In B<Edit> mode B<iClive> provides an edit window in which the text
of a source or listing can be displayed, edited and saved.  B<iClive>
uses the Tk::Text widget whose features are described under the heading
"KEYBOARD BINDINGS" below.  An extension Tk::TextUndo may be used
to provide an UNDO facility while editing. This extension used to be
problematic for the 'live display' - it was 7 times slower in making
arithmetic updates and it caused the window to jump to the last updated
text for value changes in the control application. This made the 'live
display' hard to interpret. This does not happen with Tk::Text and
does not seem to be a problem anymore.  Nevertheless Tk::Text remains
the default until more extensive tests have been done.  If you want
to activate the UNDO facility use iClive -u option (recommended only
for editing) Also see CAVEAT below.

Holding down the [file] button shows extra file options including a
history of previously opened files. The 'file menu' can be detached
with the tear line ---------.

B<iClive> is a client of B<iCserver>, like all running iC applications
and IO's. On startup B<iClive> will start B<iCserver -A iCbox>,
unless iCserver is already running. This will automatically autovivify
the correct B<iCbox> when an application is started with the B<Run>
button. An alternative command to autovivify may be entered with
the B<-A> option: eg B<-A iClift> or B<-A 'iCbox -H'> If B<iClive>
started B<iCserver>, it will also stop it when it is stopped. Stopping
B<iCserver> automaticaly stops all running applications and IO's.

When B<Live> mode is started, B<iClive> requests the symbol table of
the application. It returns a list of words from the symbol table on
which it wants live updates of the state of the nodes, named by each
word in the list. The application then provides updates to B<iClive>
when the state of any node from the list changes as soon as possible
after the change.

In B<Live> mode all words in the text which exactly match any token
in the list are marked with a colour depending on the current state
of the node.  Logical nodes are B<green/black> for B<false> and
B<yellow/red> for B<true>.  Logical active words in the list which
are preceded by ~ or ! or which are followed by ~ show the inverse
state of the node.  Arithmetic nodes are B<blue>, clocks B<brown>
and timers B<dark green>.  All coloured nodes are called 'active'
words, because they display the live state of these nodes in the
running application.  Clocks and timers as well as data nodes which
change for less than 50 ms flash briefly (50 ms) every time they fire.

For B<Live> mode to be effective, the displayed text must be either
the source of the running iC application or a text derived from that
source, such as the iC listing.  Whenever a new iC text or another
instance is selected, B<iClive> will automatically attach itself to
the selected application (provided it is running).  B<iClive> shows
the logical statements of the source and the colours will show what
the current state is.  It is easy to inspect such a live listing and
relate states with the logic of the application.

When the mouse cursor sits on an active word in B<Live> mode the
value of the node is displayed in a balloon window. This is useful for
displaying the current value of arithmetic nodes.

When the mouse cursor sits on an active word in B<Live> mode and the
focus is in the Search Entry window (click in it or type '/') and
the left Shift-Key is pressed the balloon will display the 'index'
of the variable in the Symbol Table. This is useful to check if an
Alias or an immC array member has the same 'index' and is thus the same
variable as a normal variable with a different name. The same 'index'
is used in VCD files for GTKWave.  Simlarly when the left Control-Key
is pressed the balloon will display the 'ftype' of the variable.

In B<Live> mode an active word in a comment followed by an equal sign
at the very end of the line will show the changing value of the word.

    eg.  // offset =
    will be displayed as
         // offset = 15
    this construct is usually commented with //

A powerful search facility to find groups of words or regular
expressions has been implemented on top of Text::Tk.  Activate the
search by keying '/' or pressing the [/] button briefly.  Enter or
paste a word into the Search Entry window and key RETURN or press the
[/] button again.  Searches may be for an exact match or for a full
Perl-type regular expression. The \bword\b feature to find only whole
words is particularly useful. Searches are normally case sensitive,
but a case-insensitive search may be selectd. Once a search has been
carried out, all the hits are highlighted. A first group of hits is
displayed in the Text window. The text is moved to display as many
hits as possible. When the user has analysed the first group of hits,
hitting RETURN will display the next group of hits in the text and
so on until the end of the text is reached. Another RETURN will start
by displaying the first group at the top again. Hitting SHIFT-RETURN
will reverse the direction of displaying the groups.

Double-clicking with mouse button 1 transfers the word under the
mouse to the Search Entry window and immediately starts a search for
that word. This is the quickest and best way to start a search. This
action masks the selection of the text under the mouse (Text Binding
[2]).  If necessary clear the prevous search by pressing ctrl-RETURN.
The search can be continued by clicking on the [/] button or pressing
RETURN.

Double-clicking with mouse button 1 with the cursor in the Search Entry
window or by pressing ctrl-RETURN will clear the search completely.

Holding down the search key [/] will show the different search options
for 'Exact match' or 'Regexp match' either case sensitive or not.
This is followed by a history of previous searches - most recent at
the end, which can be selected for a repeat search. This search menu
can be detached with the tear line ---------.

The position of the displayed text may be manipulated by the scroll
bar(s) or the usual up/down/prior/next/home/end keys.  A useful
feature is the use of the middle mouse button to fast scroll in all
4 directions through the text.

Tk::Text will open a dialog box when clicking the right mouse button
in the text window. The features provided are self explanatory. It
also has a search feature, which did not seem to be available when
I started. The really useful feature there is the search/replace
facility. Another useful feature is changing the wrap mode.

=head1 KEYBOARD BINDINGS

Tk automatically creates class bindings for texts that give them
the following default behavior.  In the descriptions below, 'word'
refers to a contiguous group of letters, digits, or '_' characters,
or any single character other than these. (from Tk::Text)

[1] Clicking mouse button 1 positions the insertion cursor just before
   the character underneath the mouse cursor, sets the input focus to
   this widget, and clears any selection in the widget.  Dragging with
   mouse button 1 strokes out a selection between the insertion cursor
   and the character under the mouse.

[2] Double-clicking with mouse button 1 selects the word under the
   mouse and positions the insertion cursor at the beginning of the
   word.  Dragging after a double click will stroke out a selection
   consisting of whole words.

[3] Triple-clicking with mouse button 1 selects the line under the
   mouse and positions the insertion cursor at the beginning of the
   line.  Dragging after a triple click will stroke out a selection
   consisting of whole lines.

[4] The ends of the selection can be adjusted by dragging with mouse
   button 1 while the Shift key is down;  this will adjust the end
   of the selection that was nearest to the mouse cursor when button
   1 was pressed.  If the button is double-clicked before dragging
   then the selection will be adjusted in units of whole words; if
   it is triple-clicked then the selection will be adjusted in units
   of whole lines.

[5] Clicking mouse button 1 with the Control key down will reposition
   the insertion cursor without affecting the selection.

[6] If any normal printing characters are typed, they are inserted
   at the point of the insertion cursor.

[7] The view in the widget can be adjusted by dragging with mouse
   button 2.  If mouse button 2 is clicked without moving the mouse,
   the selection is copied into the text at the position of the
   mouse cursor.  The Insert key also inserts the selection, but at
   the position of the insertion cursor.

[8] If the mouse is dragged out of the widget while button 1 is
   pressed, the entry will automatically scroll to make more text
   visible (if there is more text offscreen on the side where the
   mouse left the window).

[9] The Left and Right keys move the insertion cursor one character
   to the left or right;  they also clear any selection in
   the text.  If Left or Right is typed with the Shift key down,
   then the insertion cursor moves and the selection is extended
   to include the new character.  Control-Left and Control-Right
   move the insertion cursor by words, and Control-Shift-Left and
   Control-Shift-Right move the insertion cursor by words and also
   extend the selection.  Control-b and Control-f behave the same as
   Left and Right, respectively.  Meta-b and Meta-f behave the same
   as Control-Left and Control-Right, respectively.

[10]
   The Up and Down keys move the insertion cursor one line up or
   down and clear any selection in the text.  If Up or Right is
   typed with the Shift key down, then the insertion cursor moves
   and the selection is extended to include the new character.
   Control-Up and Control-Down move the insertion cursor by paragraphs
   (groups of lines separated by blank lines), and Control-Shift-Up
   and Control-Shift-Down move the insertion cursor by paragraphs
   and also extend the selection.  Control-p and Control-n behave
   the same as Up and Down, respectively.

[11]
   The Next and Prior keys move the insertion cursor forward or
   backwards by one screenful and clear any selection in the text.
   If the Shift key is held down while Next or Prior is typed,
   then the selection is extended to include the new character.
   Control-v moves the view down one screenful without moving the
   insertion cursor or adjusting the selection.

[12]
   Control-Next and Control-Prior scroll the view right or left by one
   page without moving the insertion cursor or affecting the selection.

[13]
   Home and Control-a move the insertion cursor to the beginning of
   its line and clear any selection in the widget.  Shift-Home moves
   the insertion cursor to the beginning of the line and also extends
   the selection to that point.

[14]
   End and Control-e move the insertion cursor to the end of the line
   and clear any selection in the widget.  Shift-End moves the cursor
   to the end of the line and extends the selection to that point.

[15]
   Control-Home and Meta-< move the insertion cursor to the
   beginning of the text and clear any selection in the widget.
   Control-Shift-Home moves the insertion cursor to the beginning of
   the text and also extends the selection to that point.

[16]
   Control-End and Meta-> move the insertion cursor to the end of
   the text and clear any selection in the widget.  Control-Shift-End
   moves the cursor to the end of the text and extends the selection
   to that point.

[17]
   The Select key and Control-Space set the selection anchor to
   the position of the insertion cursor.  They don't affect the
   current selection.  Shift-Select and Control-Shift-Space adjust
   the selection to the current position of the insertion cursor,
   selecting from the anchor to the insertion cursor if there was
   not any selection previously.

[18]
   Control-/ selects the entire contents of the widget.

[19]
   Control-\ clears any selection in the widget.

[20]
   The F16 key (labelled Copy on many Sun workstations) or Meta-w
   copies the selection in the widget to the clipboard, if there is
   a selection.

[21]
   The F20 key (labelled Cut on many Sun workstations) or Control-w
   copies the selection in the widget to the clipboard and deletes
   the selection.  If there is no selection in the widget then these
   keys have no effect.

[22]
   The F18 key (labelled Paste on many Sun workstations) or Control-y
   inserts the contents of the clipboard at the position of the
   insertion cursor.

[23]
   The Delete key deletes the selection, if there is one in the widget.
   If there is no selection, it deletes the character to the right
   of the insertion cursor.

[24]
   Backspace and Control-h delete the selection, if there is one in
   the widget.  If there is no selection, they delete the character
   to the left of the insertion cursor.

[25]
   Control-d deletes the character to the right of the insertion
   cursor.

[26]
   Meta-d deletes the word to the right of the insertion cursor.

[27]
   Control-k deletes from the insertion cursor to the end of its
   line; if the insertion cursor is already at the end of a line,
   then Control-k deletes the newline character.

[28]
   Control-o opens a new line by inserting a newline character in
   front of the insertion cursor without moving the insertion cursor.

[29]
   Meta-backspace and Meta-Delete delete the word to the left of the
   insertion cursor.

[30]
   Control-x deletes whatever is selected in the text widget.

[31]
   Control-t reverses the order of the two characters to the right
   of the insertion cursor.

[32]
   Control-z (and Control-underscore on UNIX when tk_strictMotif is
   true)  undoes  the last edit action if the -undo option is true.
   Does nothing otherwise.

[33]
   Control-Z (or Control-y on Windows) reapplies the last undone edit
   action if the -undo option is true. Does nothing otherwise.
   (see below)

CAVEAT: These two Undo actions, if iClive -u is called, were found
to be rather tricky.  Control-u as well as control-z undoes changes
and both re-apply undone changes with the other. I found it very
disturbing, that when you try to undo more than the last change, the
whole window is cleared (undoes the load !!). Theoretically the text
was in the state of the file originally loaded when this 'load undo'
was executed. Control-z (or contrl-u) will bring it back. A better
option is to do a File/Reload.  Control-Z does not seem to work!!

The following extra Bindings have been defined for iClive:

[iC1]
   Alt-n   provide a New empty file
   Alt-o   Open a file
   Alt-R   Reload the current file (usually modified externally)
   Alt-l   switch beteen iC-source and iC-Listing
   Alt-s   Save current file
   Alt-a   saveAs current file under a new name
   Alt-h   Help for iClive
   Alt-q   Quit iClive

   Alt-b   Build executable from current iC-file
   Alt-u   Unconditionally save and build
   Alt-c   build C-file only from current iC-file

   Alt-r   Run/stop the current executable
   Alt-e   switch between Edit/live mode

   Alt +   Dynamically increase font size
   Alt -   Dynamically decrease font size

If the widget is disabled, as it is in 'Live' mode, then its view can
still be adjusted and text can still be selected, but no insertion
cursor will be displayed and no text modifications will take place.
In 'Live' mode the focus is normally on the y-Scrollbar or on the
search-Entry window.  The following Bindings have been programmed for
'Live' mode.

[iC2]
   The Left and Right keys scroll the whole text left and right one
   character at a time.

[iC3]
   The Up and Down keys scroll the text up and down one line at a time.

[iC4]
   The Next and Prior keys scroll the text up and down one page at
   a time.

[iC5]
   The Home and End keys move the text to the beginning or end.

These scroll modes are also available in 'Edit' mode, by putting
the focus in the 'search-Entry' window by clicking in it. To
continue editing click in the text window again.

[iC6]
   The view in the widget can be adjusted by dragging with mouse
   button 3. (same in both modes)

[iC7]
   In 'Live' mode the following Accelerators work without
   the Alt-Key pressed:
    l   switch beteen iC-source and iC-Listing
    h   Help for iClive
    q   Quit iClive
    s   Stop the current executable (loses 'Live' mode)
    r   also stops executable       (Alt-r to 'Run' again)
    e   switch to 'Edit' mode       (Alt-e to 'Live' mode)
    /   clear search entry (vi)     (Alt-/ in entry window)
   All these accelerators (except s) also work with the
   Alt-Key pressed in both 'Edit' and 'Live' mode.

=head1 MODULE Time::HiRes

For measuring reaction times the Module Time::HiRes is used.  This
activates the -m option and flash display of short events.  Make sure
you have installed Time::HiRes (provided in this distribution)

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<immcc(1)>, L<iCbox(1)>, L<iCserver(1)>, L<iCmake(1)>, L<iCman(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2012  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
