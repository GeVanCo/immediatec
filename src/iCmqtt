#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2023-2024  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCmqtt; interface between openHAB MQTT and iCserver
#
########################################################################

########################################################################

use iCmsgM;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
			## added code from   https://metacpan.org/pod/Net::MQTT::Simple
use strict;
use warnings;

my @ArgNames;		# stores IO names and initialisers in argument list order
my @ChannelNames;	# stores IO names with instance for each registered channel
my @ChannelsQ;		# stores received value for all Q[XBWL]n outputs
my @ChannelsQX;		# stores computed bit value for all QXn.<0..7> outputs
my @ChannelsI;		# stores computed or selected value for all I[XBWL]n inputs
my $UnitRegistrations;	# stores the registration string
my @argv       = ();
my $server     = 0;
my $conn;

my $Ch = 0;
my $Bit;

my @args;
my @runArgs = ();
my $argsP = \@args;			# intially fill @args
my $Rflag = 0;
my $opt_Z = 0;		# 1 for debugging sub convertFlags()
my %commandLineFlags = (
    'F'   => 1,				# Value flags
    'I'   => 1,
    'Q'   => 1,
    's'   => 1,
    'p'   => 1,
    'N'   => 1,
    'i'   => 1,
    'm'   => 1,
    'n'   => 1,
    'S'   => 1,
    'A'   => 1,
    'T'   => 1,
    'G'   => 0,				# Bool flags
    'E'   => 0,
    'a'   => 0,
    'q'   => 0,
    'z'   => 0,	# dummy flag for iCserver calls -R iCmqtt -z (stops error message)
    't'   => 0,
    'J'   => 0,
    'O'   => 0,
    'M'   => 0,
    'h'   => 0,
    'f'   => 1,				# include file
    'R'   => 1,				# Run an app
);

my @masks =	(1, 2, 4, 8, 16, 32, 64, 128);
my @bitIndex =	(
    0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,	# 0x01 0x02 0x04 0x08
    4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	# 0x10
    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x40
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = untaint($0); $named =~ s#.*[/\\]##;
format STDERR =
Usage:
 @<<<<< [-GETaqtJOh] -F <floor> -I <x> -Q <y> <openHAB control>.items
	$named
        [ -s <iC host>][ -p <iC port>][ -N <name>][ -i <inst>]
        [ -m <MQTT host>][ -n <MQTT port>][ -f <file>]
        [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -F floor regexp used for selecting a floor in openHAB topics
             examples: 'gf_[sp]' 'ff_[sp]'     (no default)
             longer examples: 'home/gelijkvloers' 'home/verdiep'
    -I <x>   starting input IEC address IX<x>  (no default)
    -Q <y>   starting output IEC address QX<y> (no default)
    -G       generate auxiliary iC include files:
                 <floor>_OHaliasIEC.ih
                 <floor>_OHdeclare.ih
                 outputs -I <x> and -Q <y> for next floor
    -E       additionally generate iC extern file:
                 <floor>_OHextern.ih
    -T <z>   additionally generate iC test file:
                 <floor>_OHtest.ic with virtual I/O inputs IX<z>
    -s host  name of iCserver host        (default '127.0.0.1')
    -p port  service port of iCserver     (default '8778')
    -N name  iC registration name         (default <floor>_iCmqtt)
    -i inst  optional instance Id         (1 to 3 numeric digits)
    -m host  name of MQTT broker host     (default '127.0.0.1')
    -n port  service port of MQTT broker  (default '1883')
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients if iCserver
            is started by this @<<<<< call (default 'iCbox')
				$named
    -f file  read flags and additional parameters from this file
    -q       quiet - do not report clients connecting and disconnecting
       <openHAB control>.items file   from openHAB/configuration/items

	return "IX<next> QX<next>" to allow specifying non-clashing
	       IX<x> and QX<y> for iCmqtt on another processor. 

        DEBUG options
    -a       analyse <openHAB control>.items - without -F floor:
               shows Switch selections where actions are not defined
                           - with -F floor:
               checks Switch selections have different id's
    -t       trace debug messages
    -J       trace rcv messages in iCmsgM.pm
    -O       trace send messages in iCmsgM.pm
    -M       display elapsed time in seconds and microseconds
    -h       help, ouput this Usage text only

        AUXILIARY app   - start a Bernstein chain
    -R <app ...> run one app followed by -z and its arguments as a
                 separate process; -R ... must be last arguments,

        KEYBOARD inputs
        q    from keyboard stops iCserver and all apps

Copyright (C) 2023-2024  John E. Wulff        <immediateC@gmail.com>
							  '@'
$Id: iCmqtt 1.3 $
.

########################################################################
#	convert POSIX flags to individual flags - process -f -R
########################################################################

convertFlags(\@ARGV);
print "args    = '", join(" ", @args), "'\n" if $opt_Z;
print "runArgs = '", join(" ", @runArgs), "'\n" if $opt_Z;
@ARGV = @args;

my $nr = qr/-?[1-9]\d*|0(x[\da-fA-F]+|b[01]+|[0-7]*)/;	# precompiled regex for number in all representations
							# NOTE: oct() only handles lower case 0b, 0x
########################################################################
#	Handle all remaining -switch options and non-switch options
########################################################################

use vars qw($opt_F $opt_I $opt_Q $opt_G $opt_E $opt_T $opt_a);
use vars qw($opt_s $opt_p $opt_N $opt_m $opt_n $opt_S $opt_A $opt_i $opt_h);
use vars qw($opt_ $opt_t $opt_J $opt_O $opt_M $opt_q $opt_z);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    ''    => \$opt_,			# lone - (not used)
    '<>'  => sub { push(@argv, @_); },	# Transfer items argument to @argv
    'F=s' => \$opt_F,
    'I=i' => \$opt_I,
    'Q=i' => \$opt_Q,
    's=s' => \$opt_s,
    'p=s' => \$opt_p,
    'N=s' => \$opt_N,
    'i=i' => \$opt_i,
    'm=s' => \$opt_m,
    'n=s' => \$opt_n,
    'S=s' => \$opt_S,
    'A=s' => \$opt_A,
    'T=i' => \$opt_T,
    'G'   => \$opt_G,
    'E'   => \$opt_E,
    'a'   => \$opt_a,
    'q'   => \$opt_q,
    'z'   => \$opt_z,	# dummy flag for iCserver calls -R iCmqtt -z (stops error message)
    't'   => \$opt_t,
    'J'   => \$opt_J,
    'O'   => \$opt_O,
    'M'   => \$opt_M,
    'h'   => \$opt_h,
);
scalar @ARGV == 0 or die "*** ERROR: $named: '@ARGV' remaining after Getopt::Long GetOptions() ???\n";

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
print "argv    = '", join(" ", @argv), "'\n" if $opt_Z;

if ($opt_q) {
    $opt_q = 'q';			# quiet option
} else {
    $opt_q = '';			# define $opt_q
}
$opt_A = 'iCbox' unless $opt_A;
$opt_S = 'iCserver' unless defined $opt_S;

use Time::HiRes qw(usleep gettimeofday);
my ($t0, $t1, $sec, $usec);
if ($opt_M) {
    $t0 = [gettimeofday];	# start of program
}

my $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = "-$opt_i";
	print "instance = '$instance'\n" if $opt_t;
    } else {
	warn "$named: badly formed option -i $opt_i - ignored\n";
    }
}
if (not $opt_a and (not defined $opt_F or not defined $opt_I or not defined $opt_Q)) {
    print STDERR "*** ERROR $named: -F <floor>, -I <x> and -Q <y> must be defined\n";
    write STDERR; exit 1;
}

########################################################################
#
#	Process openHAB items file
#
########################################################################

my ($icVar, $ONadr, $ONbit, $OFFadr, $OFFbit, $onCnt, $offCnt, $stateCnt);
my ($Iflag, $IEC, $bit);
my $icON    = "";
my $icOFF    = "";
my $icQ    = "";
my %icVars = ();
my $state  = "B";		# Base state
my $floor  = $opt_F;
my $floorO = $floor;
$floorO    =~ s/\W/_/g;
my %IECs   = ();
my $Istart = $opt_I;
my $Qstart = $opt_Q;
my $Iadr   = $Istart - 1;
my $Qadr   = $Qstart - 1;
my $Ibit    = 7;
my $Qbit    = 7;
my %TopicChannels = ();
my %ChannelTopics = ();

open IN, $argv[0] or die "Cannot open input file $argv[0]: $!";
while (<IN>) {
    if ($state eq "B" and m/^\s*Switch\s+\w+\s+"(.*)"/) {
	$icVar = $1;
	$icVar =~ s/[^\w]/ /g;
	$icVar =~ s/\s+/_/g;
	$state = "S";		# Switch state
    } elsif ($state eq "S") {
	if (m/^\s*{\s*mqtt\s*=\s*"\s*$/) {
	    $onCnt = $offCnt = $stateCnt = 0;
	    $state = "M";
	} else {
	    $icVars{$icVar} = "ON/OFF action defined in homecontrol.rules";
	    $state = "B";
	}
    } elsif ($state eq "M") {
	if (m/^\s*>\[\w+:($floor(\/\w+)+):command:ON:/) {
	    if ($icVar ne $icON) {
		if (++$Ibit > 7) {
		    $Iadr++;
		    $Ibit = 0;
		}
		$ONadr = $Iadr;
		$ONbit = $Ibit;
		$icON = $icVar;
		push(@{ $IECs{"IX$ONadr"}[$ONbit] }, $icVar."_ON");	# iC variable
	    }
	    push(@{ $IECs{"IX$ONadr"}[$ONbit] }, "$1:ON");	# topic:ON
	    $onCnt++;
	} elsif (m/^\s*>\[\w+:($floor(\/\w+)+):command:OFF:/) {
	    if ($icVar ne $icOFF) {
		if (++$Ibit > 7) {
		    $Iadr++;
		    $Ibit = 0;
		}
		$OFFadr = $Iadr;
		$OFFbit = $Ibit;
		$icOFF = $icVar;
		push(@{ $IECs{"IX$OFFadr"}[$OFFbit] }, $icVar."_OFF");	# iC variable
	    }
	    push(@{ $IECs{"IX$OFFadr"}[$OFFbit] }, "$1:OFF");	# topic:OFF
	    $offCnt++;
	} elsif (m/^\s*<\[\w+:($floor(\/\w+)+):state:/) {
	    if ($icVar ne $icQ) {
		if (++$Qbit > 7) {
		    $Qbit = 0;
		    $Qadr++;
		}
		$icQ = $icVar;
		push(@{ $IECs{"QX$Qadr"}[$Qbit] }, $icVar);	# iC variable
	    }
	    push(@{ $IECs{"QX$Qadr"}[$Qbit] }, $1);		# topic
	    $stateCnt++;
	} elsif (m/^\s*}\s*$/) {
	    if ($onCnt != $offCnt and $offCnt != $stateCnt) {
		print "ERROR: $icVar: onCnt = $onCnt, offCnt = $offCnt stateCnt = $stateCnt\n";
	    }  elsif ($onCnt != 0) {
		$icVars{$icVar}++;
	    }
	    $state = "B";
	}
    }
}
close IN;

if ($opt_a) {
    foreach $icVar (sort keys %icVars) {
	printf "%34s: %s\n", $icVar, $icVars{$icVar};
    }
    exit 0;
}

if ($opt_G) {
    open OUT, ">$floorO"."_OHaliasIEC.ih" or die "Cannot open output file '$floorO"."_OHaliasIEC.ih': $!";
    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
    print OUT "// openHAB alias IEC assignments for \"$floor\"\n";
    print OUT "//   Must be included at the end of one .ic file only.\n";
    print OUT "//\n";
    print OUT "// IEC inputs\n";
    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
    $Iflag = 1;
  IEC1:
    foreach $IEC (sort keys %IECs) {
	for ($bit = 0; $bit < 8; $bit++) {
	    my $IECp = \@{ $IECs{$IEC}[$bit] };
	    if ($Iflag) {
		printf OUT "%-34s = %s;", $IECp->[0], "$IEC.$bit";
	    } else {
		printf OUT "%-7s= %-34s", "$IEC.$bit", $IECp->[0].";";
	    }
	    my $p = "\t";
	    for (my $i = 1; $i < scalar(@$IECp); $i++) {
		printf OUT "$p// %s\n", $IECp->[$i];
		$p = "\t\t\t\t\t\t";
	    }
	    if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
		print OUT "\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
		print OUT "// IEC outputs\n";
		print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
		$Iflag = 0;
		next IEC1;
	    } elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
		last;
	    }
	}
    }
    close OUT;
    print "$floorO"."_OHaliasIEC.ih generated with IX$Istart - IX$Iadr and QX$Qstart - QX$Qadr\n";

    open OUT, ">$floorO"."_OHdeclare.ih" or die "Cannot open output file '$floorO"."_OHdeclare.ih': $!";
    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
    print OUT "// openHAB declarations for \"$floor\"\n";
    print OUT "//   Copy lines declaring variables used or assigned in a .ic\n";
    print OUT "//   file just after the included extern declarations.\n";
    print OUT "//   Then use the variable names in bit expressions or assignments\n";
    print OUT "//   or as parameters in iC function block calls.\n";
    print OUT "//\n";
    print OUT "// iC input declarations\n";
    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
    $Iflag = 1;
  IEC2:
    foreach $IEC (sort keys %IECs) {
	for ($bit = 0; $bit < 8; $bit++) {
	    my $IECp = \@{ $IECs{$IEC}[$bit] };
	    printf OUT "imm bit %-34s", $IECp->[0].";";
	    my $p = "\t";
	    for (my $i = 1; $i < scalar(@$IECp); $i++) {
		printf OUT "$p// %s\n", $IECp->[$i];
		$p = "\t\t\t\t\t\t";
	    }
	    if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
		print OUT "\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
		print OUT "// iC output declarations\n";
		print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
		$Iflag = 0;
		next IEC2;
	    } elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
		last;
	    }
	}
    }
    close OUT;
    print "$floorO"."_OHdeclare.ih generated\n";

    if ($opt_E) {
	open OUT, ">$floorO"."_OHextern.ih" or die "Cannot open output file '$floorO"."_OHextern.ih': $!";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
	print OUT "// openHAB extern declarations for \"$floor\"\n";
	print OUT "//   Must be included at the beginning of each .ic file if more\n";
	print OUT "//   than one .ic file is linked\n";
	print OUT "//\n";
	print OUT "// iC extern input declarations\n";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
	$Iflag = 1;
      IEC3:
	foreach $IEC (sort keys %IECs) {
	    for ($bit = 0; $bit < 8; $bit++) {
		my $IECp = \@{ $IECs{$IEC}[$bit] };
		printf OUT "extern imm bit %-34s", $IECp->[0].";";
		my $p = "\t";
		for (my $i = 1; $i < scalar(@$IECp); $i++) {
		    printf OUT "$p// %s\n", $IECp->[$i];
		    $p = "\t\t\t\t\t\t";
		}
		if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
		    print OUT "\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
		    print OUT "// iC extern output declarations\n";
		    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
		    $Iflag = 0;
		    next IEC3;
		} elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
		    last;
		}
	    }
	}
	close OUT;
	print "$floorO"."_OHextern.ih generated\n";
    }

    if (defined $opt_T) {
	open OUT, ">$floorO"."_OHtest.ic" or die "Cannot open output file '$floorO"."_OHtest.ic': $!";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
	print OUT "// openHAB - iC test application for \"$floor\"\n";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
	print OUT "imm bit relay(bit sw, bit ohON, bit ohOFF) {\n";
	print OUT "    imm bit swR = RISE(sw);\n";
	print OUT "    this = JK(swR | ohON, swR | ohOFF);\n";
	print OUT "}\n\n";
	if ($opt_E) {
	    print OUT "%include \"$floorO"."_OHextern.ih\"\n";
	}
	print OUT "%include \"$floorO"."_OHdeclare.ih\"\n\n";
	my $Ia = $opt_T;
	foreach $IEC (sort keys %IECs) {
	    if ($IEC =~ m/^Q/) {
		for ($bit = 0; $bit < 8; $bit++) {
		    my $IECp = \@{ $IECs{$IEC}[$bit] };
		    printf OUT "%-34s = relay(%s, %s, %s);\n",
			$IECp->[0], "IX$Ia.".$bit,
			$IECp->[0]."_ON", $IECp->[0]."_OFF";
		    last if $bit == $Qbit and $IEC eq "QX$Qadr";
		}
		$Ia++;
	    }
	}
	print OUT "\n%include \"$floorO"."_OHaliasIEC.ih\"\n";
	close OUT;
	print "$floorO"."_OHtest.ic generated\n";
    }

    $Iadr++; $Qadr++;
    print " -I $Iadr -Q $Qadr # input and output IEC addresses for next -G run\n";
    exit 0;
}
print "$named running with IX$Istart - IX$Iadr and QX$Qstart - QX$Qadr registered.\n";

########################################################################
#
#	Connect to iCserver and register I/Os
#
#	Inhibit Nagle's algorithm
#
########################################################################

my $host = defined $opt_s ? $opt_s : '127.0.0.1';
my $port = defined $opt_p ? $opt_p : 8778;
my $name = untaint($opt_N ? "$opt_N$instance" : $floorO."_mqtt$instance");
$named = $name;			# use individual ID for warnings from now on

connect_to_server();

########################################################################
#
#  Additional code to connect to an MQTT broker
#
########################################################################

use Net::MQTT::Simple;

my $m_host = defined $opt_m ? $opt_m : 'localhost';
my $m_port = defined $opt_n ? $opt_n : 1883;

# Allow unencrypted connection with credentials
$ENV{MQTT_SIMPLE_ALLOW_INSECURE_LOGIN} = 1;

# Connect to broker
print "##### Net::MQTT::Simple->new(\"$m_host:$m_port\");\n" if $opt_t;
my $mqtt = Net::MQTT::Simple->new("$m_host:$m_port");

# Depending if authentication is required, login to the broker
my $floorS = $floor;
$floorS =~ s/\[(sp|ps)\]/s/;	# gf_[sp] ==> gf_s; ff[ps] ==> ff_s
$mqtt->subscribe("$floorS/#", \&mqttReceived);

############# send registration ############################

my $d;				# direction 'S' or 'R'
my $register = 1;		# tested in rcvd_msg_from_server() for registration reply
my $ri = 0;			# registration index used in rcvd_msg_from_server()
$UnitRegistrations = "N$name";	# initiate registration string

$Iflag = 1;
IEC4:
foreach $IEC (sort keys %IECs) {
    my $from = 0;
    if ($IEC =~ /^I/) {
	$d = 'S';
    } elsif ($IEC =~ /^Q/) {
	$d = 'R';
    } else {
	die "$named: invalid argument '$IEC' - internal error";
    }
    for ($bit = 0; $bit < 8; $bit++) {
	$from |= $masks[$bit];
	last if $bit == $Ibit and $IEC eq "IX$Iadr";
	if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
	    $Iflag = 0;
	    next IEC4;
	} elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
	    last;
	}
    }
    push @ArgNames, [ $IEC, $from ];		# argument order for handling ack
    if ($from < 255) {
	$IEC .= "($from)";
    }
    if ((length($UnitRegistrations) + length($IEC)) > 1396) {	# REPLY 1400 - (1+2+1) in tcpc.h
	print "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
	$conn->send_now($UnitRegistrations);		# unlikely to overflow - tested with length() < 139
	my ($tmsg, $terr) = $conn->rcv_now();		# receive registration acknowledgment
	print "$named: Reply: $tmsg\n" if $opt_t;
	rcvd_msg_from_server($conn, $tmsg, $terr);	# process registration acknowledgment
	$UnitRegistrations = "$d$IEC"	# start new $unitRegistrations without comma
    } else {
	$UnitRegistrations .= ",$d$IEC";	# direction 1 ',Z' 2 term 1
    }
    print "register: $d$IEC\n" if $opt_t;
}
$UnitRegistrations .= ",Z";			# terminate registration string
print "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
$conn->send_now($UnitRegistrations);
my ($tmsg, $terr) = $conn->rcv_now();		# receive final registration acknowledgment
print "$named: Reply: $tmsg\n" if $opt_t;
rcvd_msg_from_server($conn, $tmsg, $terr);	# process final registration acknowledgment

############# registration analysis ########################
$ri == scalar @ArgNames or
    die "$named: $ri: not enough registration replies from iCserver - system error";
$register = 0;
############# correct number of registration replies #######

my ($frame, $ch, $maxColumn, $mw, $pane);
my ($row, $column, $scroll) = (0, 0, 0);

########################################################################
#	Optionally run -R option
########################################################################
if (@runArgs) {
    splice(@runArgs, 1, 0, "-s", "$host") unless $host eq "localhost" or $host eq "127.0.0.1";
    splice(@runArgs, 1, 0, "-p", "$port") unless $port eq "8778";
    splice(@runArgs, 1, 0, "-z$opt_q",);
    print "at fork	runArgs: '", join(':', @runArgs), "'\n" if $opt_t;
    fork_and_exec(@runArgs);
}

########################################################################
#
#	Register an event handler callback for STDIN to recognise
#	q or ctrl+D from the keyboard to terminate the program
#	unless $opt_z (-z) which blocks STDIN if called in a chain.
#
#	Sit in an infinite loop dispatching incoming events.
#	if connected to iCserver
#
########################################################################
iCmsgM->set_event_handler(*STDIN, "read" => \&readStdin) unless $opt_z;
iCmsgM->event_loop($mqtt);

####### End of main program ############################################

########################################################################
#
#	This is the MQTT callback function, when a message arrives for
#	the subscribed topic
#
########################################################################

sub mqttReceived
{
    my ($topic, $message) = @_;
    print "Q< $topic $message\n" if $opt_t;
    my $topicP = \@{ $TopicChannels{"$topic:$message"} };
    if ($topicP) {
	my ($channel, $mask) = @$topicP;
##  print "--- $channel:$mask\n";
	send_input($channel, $mask);		# rise of the iC output pulse
	########################################################################
	#  Avoid using ualarm() because pulses for different topics cannot
	#  be high simultaneously and terminated correctly with SIG{ALRM}.
	#  usleep() makes pulses sequential with 50 ms resolution, which
	#  should be sufficient for manual events from openHAB.
	########################################################################
	usleep(100_000);				# sleep 100 ms
	send_input($channel, 0);			# fall of the iC output pulse
    } else {
	print STDERR "*** ERROR $named: received '$topic:$message' not ON or OFF\n";
    }
} # mqttReceived

########################################################################
#
#	Convert from Posix bundled flag interpretation to Go type flags.
#	Extract -f flag and open next argument as an include file
#	Extract first -R flag and save all further arguments in runArgs
#
#	Modify command line bundled flags to interpret -abc as -a -b -c,
#	which is the way flag.Parse must be presented with Bool flags.
#	flag.Parse interprets -abc as the flag named "abc".
#	Mofify Value flags to interpret -xVal as -x Val. Can also have
#	-abcx Val or -abcxVal, which are both converted to -a -b -c -x Val.
#	Value flags could be identified by the flag initialisers above,
#	but it is simpler to define a map of Value flag identifiers.
#	Command line flags starting with -- are not touched, which is the
#	Posix way of mixed flags starting with - or --.
#	https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#
#	The -f <include file> argument opens the include file, which is
#	trimmed of extraneous spaces and comments and produces another slice
#	of command line arguments. A recursive call of convertFlags() moves
#	these arguments into args and runargs, replacing the f<> argument.
#
#	The -R option starts a Bernstein chain. Each -R option in the chain
#	starts a new iC app. Apps in a Bernstein chain are started sequentially
#	to run their initialization code, at which point the app starts
#	the next iC app in the Bernstein chain with its -R option. The
#	current app keeps running in parallel with the app that started it.
#	Finally all iC apps in a Bernstein chain run in parallel after their
#	initialization codes have been run sequentially.
#	The first iC app in the Bernstein chain must have the -z option, which
#	suppresses stdin interrupts. This is necessary, because programs started
#	with exec.Command().run() close stdin, which causes EOF for stdin in
#	the iC app, which causes it to shut down. -z suppresses that.
#
#	Modifying command line options and interpreting -f is stopped after the
#	first -R option because any further options are interpreted by apps in the
#	Bernstein chain and may not be set correctly in the commandLineFlags map.
#
########################################################################

sub convertFlags {
    my ($argp) = @_;
    my ($ch);
    print "cF:	*argp = '", join(" ", @{$argp}), "'\n" if $opt_Z;
    my $Fflag = 0;
    foreach my $arg (@{$argp}) {
	if (length($arg) == 0) { next; }
	print "    \"$arg\"\n" if $opt_Z;
	my $Sflag = 1;
	my $s0 = substr $arg, 0, 1;
	my $s1 = substr $arg, 1, 1;
	if ($arg ne "-" && $s0 eq '-' && $s1 ne '-' && ($Rflag eq 0 || $s1 eq 'R')) {
	    $Sflag = 0;
	    my $i     = 0;
	    foreach my $sf (split(//, substr($arg, 1))) {
		print "	$sf	Sflag = $Sflag	Rflag = $Rflag	Fflag = $Fflag\n" if $opt_Z;
		unless (exists $commandLineFlags{$sf}) {
		    $arg = substr($arg, $i+1);	# not a flag value
		    $Sflag = 1;
		    last;
		}
		if ($sf eq "R" && $Rflag == 0) {
		    $Rflag = 1;			# first -R not appended to args or runArgs
		    $argsP = \@runArgs		# now fill arguments for -R option in runArgs
		} elsif ($sf eq "f" && $Rflag == 0) {
		    $Fflag = 1;
		} else {
		    push(@{$argsP}, "-$sf");
		}
		if ($commandLineFlags{$sf} == 1 && $i+2 < length($arg)) {
		    $arg = substr($arg, $i+2);	# value flag followed directly by value
		    $Sflag = 1;
		    last;
		}
		$i++;
	    }
	}
	print "		Sflag = $Sflag	Rflag = $Rflag	Fflag = $Fflag\n" if $opt_Z;
	if ($Sflag) {
	    if (not $Fflag) {
		push(@{$argsP}, $arg);		# append a value after a value flag
	    } else {
		my @incArgs;
		$Fflag = 0;
		open IN, $arg or die "can't open ID file $arg! $!";
		LINE:
		while (<IN>) {			# read next entry from include file into $_
		    chomp;
		    print "$arg:$.: '$_'\n" if $opt_Z;
		    s/(^\s+)|(\s*(#.*)?$)//g;	# strip leading space and trailing comment
		    s/\s*([=:,;.])\s*/$1/g;	# remove spaces around separators
		    if (length($_) > 0) {
			push(@incArgs, split(" ", $_));
		    }
		}
		close IN;
		if (@incArgs) {
		    print "cF:	incArgs = '", join(" ", @incArgs), "'\n" if $opt_Z;
		    convertFlags(\@incArgs)	# recursive call to add options in include file
		}
	    }
	}
    }
} # convertFlags

########################################################################
#
#	Quit program and stop iCserver, which stops all registered apps
#	unless 'Q' is pressed, which is useful for testing disconnect
#
########################################################################

sub quit_program {
    my (undef, $flag) = @_;
    print "$named: quit\n" if $opt_t;
    if ($conn) {
	if (not $flag) {
	    $conn->send_now("X$named");		# stop iCserver - (X), 'q' or disconnected by server
	} else {
	    $conn->send_now("");		# disconnect this app at iCserver only - 'Q'
	}
	$conn->disconnect();
    }
    $mw->destroy() if $mw;
    $mqtt->disconnect();
    exit(0);
} # quit_program

########################################################################
#
#	Convert a number string obtained with $nr to an integer value
#	Parameter 1:	dec, bin, oct or hex number string - dec may be signed
#	Parameter 2:	default value
#	Parameter 3:	name of argument being converted
#	retun numerical value or default value if parameter 1 undef or ''
#
########################################################################

sub convert_nr {
    my ($val, $default, $argv) = @_;
    return $default if not defined $val or $val eq '';
    if ($val =~ /^-\s*0/) {
	$val = 0;
	print "\n" if $opt_t;
	warn "$named: $argv: bin, oct or hex numbers may not be signed - ignore initialiser\n";
    } else {
	$val = oct($val) if $val =~ /^0/;	# handles 017 0xf 0b1111
    }
    $val = int($val);				# initialize to a number for correct AND/OR
    return $val;
} # convert_nr

########################################################################
#
#	Send input value
#
########################################################################

sub send_input {
    my ($ch, $val) = @_;
    printMicroSeconds();
    if ($val != $ChannelsI[$ch]) {
	$ChannelsI[$ch] = $val;		# always save latest value sent on this channel
	print "M: $named: $ch:$val	< $ChannelNames[$ch]\n" if $opt_t;
	printf "%s	> %2d:%d\n", $ChannelNames[$ch], $ch, $val if $opt_O;
	$conn->send_now("$ch:$val");		# send latest value
    }
} # send_input

########################################################################
#
#	Receive message from server - adjust outputs - ack registrations
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, $err) = @_;
    printMicroSeconds();
    if (defined $msg) {
        my $len = length $msg;
	if ($len == 0) {
	    print STDERR "iCmqtt '$named' disconnected by server\n" unless $opt_q;
	    quit_program();			# never returns
	}
	my ($msg1, $channel, $value, $old, $bitRef, $from, $regId, $bit);
	foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
	    if ($msg1 =~ /^(\d+):(-?\d+)$/) {
		$channel = $1;			## receive data as channel:value
		$value   = $2;			## decimal value with optional sign
		$old = $ChannelsQ[$channel];
		if (defined $old) {
		    if ($value != $old) {
			print "M: $named: $msg1	> $ChannelNames[$channel]\n" if $opt_t;
			printf "%s	< %2d:%d\n", $ChannelNames[$channel], $channel, $value if $opt_J;
			# stores computed bit value for all QXn.<0..7> outputs
			$bitRef = $ChannelsQX[$channel];
			if (defined $bitRef) {		# only defined for QXm digital
			    my ($diff, $mask);
			    goto WrongFormat if $value > 0xff;		# only 8 bit map allowed
			    $diff = $old ^ $value;	# $old initialized to a number for correct XOR
			    while ($diff) {		# age old algorithm from CSR days
				$mask = $diff & -$diff;	# rightmost set bit from diff
				$bit = ${$bitRef}[$bitIndex[$mask]] = ($value & $mask) ? 1 : 0;
				$diff &= ~$mask;	# modify viewable output - clear rightmost bit
				my $state = $bit ? "ON" : "OFF";
				# Publish MQTT message(s)
				my $ChannelTopicP = \@{ $ChannelTopics{$channel}[$bitIndex[$mask]] };
				for (my $i = 0; $i < scalar(@$ChannelTopicP); $i++) {
				    my $topic = $ChannelTopicP->[$i];
				    print "Q> $topic $state\n" if $opt_t;
				    $mqtt->publish($topic, $state);
				}
			    }
			}
			$ChannelsQ[$channel] = $value;	# ready for next message
		    }
		} else {
		    warn "$named: not registered for $msg1 from iCserver - not OK\n";
		}
	    } elsif ($register and $msg1 =~ /^(-?\d+)$/) {
		next if $1 eq '-0';		## null acknowledgment
		$channel = $1;			## receive channel of a registration acknowledgment
		($IEC, $from) = @{$ArgNames[$ri]};	# all argument values
		defined $IEC or
		    die "$named: too many registration acknowledgments from iCserver - system error";
		print "$named: $ri: registering '$IEC' on channel '$channel'\n" if $opt_t;
		$ri++;
		my $dir = '';
		if ($IEC =~ m/^Q([XBWL])/) {
		    if ($channel == 0) {	# /^I([XBWL])/ if $opt_r
			warn "$named: trying to register receiver '$IEC' at channel 0 - error\n";
			next;
		    }
		    $dir = 'R';
		    if ($channel < 0) {
			$channel = -$channel;
			print "$named: registering receiver '$IEC' on channel $channel twice - equivalence\n" if $opt_t;
		    } else {
			$ChannelsQ[$channel] = 0;	# initial value and Q definition
			## when this array element is defined, it is a Q[XBWL] receiver (or I[XBWL] if $opt_d or $opt_r)
			if ($1 eq 'X') {
			    @{$ChannelsQX[$channel]}[0..7] = (0,0,0,0,0,0,0,0);
			    for my $bit (0 .. 7) {
				my $IECp = \@{ $IECs{$IEC}[$bit] };
				for (my $i = 1; $i < scalar(@$IECp); $i++) {
				    my $topic = $IECp->[$i];
				    printf ">>> %s.%d '%s' %d:%02x\n", $IEC, $bit, $topic, $channel, $masks[$bit];
				    push(@{ $ChannelTopics{$channel}[$bit] }, $topic);		# topic
				}
			    }
			    ## when this array slice is defined, channel is a QXx.y
			    ## Q[BWL]n have this slice undefined for their channel
			}
		    }
		}
		elsif ($IEC =~ m/^I([XBWL])/) {
		    if ($channel == 0) {
			warn "$named: trying to register sender '$IEC' twice - not allowed\n";
			next;
		    }
		    $dir = 'S';
		    if ($1 eq 'X') {
			for my $bit (0 .. 7) {
			    my $IECp = \@{ $IECs{$IEC}[$bit] };
			    for (my $i = 1; $i < scalar(@$IECp); $i++) {
				my $topic = $IECp->[$i];
				printf "<<< %s.%d '%s' %d:%02x\n", $IEC, $bit, $topic, $channel, $masks[$bit];
				$TopicChannels{$topic} = [ $channel, $masks[$bit] ];
			    }
			}
			## when this array slice is defined, channel is a IXx.y
			## I[BWL]n have this slice undefined for their channel
		    }
		    ## initial value and I definition
		    $ChannelsI[$channel] = 0;
		    ## when this array element is defined, it is a I[XBWL] sender
		}
		if ($dir) {
		    $regId = "$dir$IEC";
		    $ChannelNames[$channel] = "$IEC";
		    print "register: $regId channel = $channel from = '$from'\n" if $opt_t;
		}
	    } else {
	      WrongFormat:
		warn "$named: WARNING: '$msg1' out of '$msg' from iCserver has wrong format - ignored";
	    }
	}
    } elsif (not $opt_q) {
	warn "$named: undefined messagefrom iCserver - ignored $err";
    }
} # rcvd_msg_from_server

########################################################################
#
#	Connect to iCserver
#	connection is maintained until iCmqtt shuts down or iCserver disconnects
#
#	Inhibit Nagle's algorithm
#
########################################################################

sub connect_to_server {
    my $i = 0;
    my @s;
    if ($server >= 0) {
	iCmsgM->inhibit_nagle(1, $opt_J, $opt_O);# Nagle's algorithm for real time response
	while (1) {
	    $conn = iCmsgM->connect($host, $port, \&rcvd_msg_from_server, 1); # return imme if connect fails
	    if ($conn) {
		print STDERR "$named connected to server at '$host:$port'\n" unless $opt_q;
		last;
	    }
	    if ($server == 0) {
		@s = split(" ", $opt_S);
		print "\@s = '@s'\n" if $opt_T;
		splice(@s, 1, 0, "-z$opt_q", "-k", "-A", "$opt_A");	# block STDIN for chained iCserver
		splice(@s, 1, 0, "-p", "$port") unless $port eq "8778";
		print "\@s = '@s'\n" if $opt_T;
		if ($host eq "localhost" or $host eq "127.0.0.1") {
		    fork_and_exec(@s);	# start iCserver
		    $server = 1;		# remember that this iC app started iCserver
		} else {
		    warn "$named: '@s' cannot be started here - start it on '$host' (ctrl-C to stop)\n";
		    $server = 2;		# waiting for start of iCserver on a remote host
		}
	    } elsif ($server > 0) {
		if ($server == 2 or $i++ < 4) {
		    print "$named: $i: wait 2 seconds for iCserver to start\n" if $opt_T;
		    select undef, undef, undef, 2;
		} else {
		    warn "$named: waited 8 seconds for '@s' to start - give up\n";
		    $server = -1;	# something wrong with iCserver
		    exit 3;
		}
	    }				# try to connect immediately
	}
    }
} # connect_to_server

########################################################################
#
#	Read from STDIN
#
########################################################################

sub readStdin {
    my $line = readline(STDIN);
    if (not defined $line or $line =~ m/^q/) {	# ctrl+D (EOF) or q
	if ($server == 1) {
	    $conn->send_now("X$named") if $conn;	# this iC app started iCserver - stop it
	} else {
	    print "$named: stopped from terminal\n";
	    exit 0;
	}
    } elsif ($line =~ m/^T/) {
	$conn->send_now("T") if $conn;			# show iCserver client tables
    } else {
	warn("*** WARNING: $named: not recognised: $line");
    }
} # readStdin

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    select undef, undef, undef, 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    print STDERR "\$ @_ &\n" unless $opt_q;
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    if ($opt_M) {
	my ($sec, $usec);
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "B%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "B%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
	$t0 = $t1;
    }
} # printMicroSeconds

########################################################################
#
#	Untaint a string for executing from a setuid program
#
########################################################################

sub untaint {
    my ($string) = @_;
    if ($string =~ m/^([-\@\w.\/\\]+)$/) {
	return $1;		# now untainted
    } else {
	die "Bad data in $string";
    }
} # untaint
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCmqtt - a bi-directional interface between openHAB MQTT and immediate C

=head1 SYNOPSIS

 iCmqtt [-GETaqtJOh] -F <floor> -I <x> -Q <y> <openHAB control>.items
        [ -s <iC host>][ -p <iC port>][ -N <name>][ -i <inst>]
        [ -m <MQTT host>][ -n <MQTT port>][ -f <file>]
        [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -F floor regexp used for selecting a floor in openHAB topics
             examples: 'gf_[sp]' 'ff_[sp]'     (no default)
             longer examples: 'home/gelijkvloers' 'home/verdiep'
    -I <x>   starting input IEC address IX<x>  (no default)
    -Q <y>   starting output IEC address QX<y> (no default)
    -G       generate auxiliary iC include files:
                 <floor>_OHaliasIEC.ih
                 <floor>_OHdeclare.ih
                 outputs -I <x> and -Q <y> for next floor
    -E       additionally generate iC extern file:
                 <floor>_OHextern.ih
    -T <z>   additionally generate iC test file:
                 <floor>_OHtest.ic with virtual I/O inputs IX<z>
    -s host  name of iCserver host        (default '127.0.0.1')
    -p port  service port of iCserver     (default '8778')
    -N name  iC registration name         (default <floor>_iCmqtt)
    -i inst  optional instance Id         (1 to 3 numeric digits)
    -m host  name of MQTT broker host     (default '127.0.0.1')
    -n port  service port of MQTT broker  (default '1883')
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients if iCserver
            is started by this iCmqtt call (default 'iCbox')
    -f file  read flags and additional parameters from this file
    -q       quiet - do not report clients connecting and disconnecting
       <openHAB control>.items file   from openHAB/configuration/items

        return "IX<next> QX<next>" to allow specifying non-clashing
               IX<x> and QX<y> for iCmqtt on another processor. 

        DEBUG options
    -a       analyse <openHAB control>.items - without -F floor:
               shows Switch selections where actions are not defined
                           - with -F floor:
               checks Switch selections have different id's
    -t       trace debug messages
    -J       trace rcv messages in iCmsgM.pm
    -O       trace send messages in iCmsgM.pm
    -M       display elapsed time in seconds and microseconds
    -h       help, ouput this Usage text only

        AUXILIARY app   - start a Bernstein chain
    -R <app ...> run one app followed by -z and its arguments as a
                 separate process; -R ... must be last arguments,

        KEYBOARD inputs
        q    from keyboard stops iCserver and all apps

=head1 DESCRIPTION

The program B<iCmqtt> is a bi-directional interface between an MQTT
broker and iCserver. It deals with openHAB topics and message content
available from a connected MQTT broker. B<iCmqtt> subsribes to openHAB
topics, which are ON and OFF commands. When a message for a subscribed
topic is received, iCmqtt sends a 100 ms pulse to iCserver for an
input IEC variable eg IX10.0.  When a 'state' variable is received
from iCserver from an IEC output variable eg QX10.0, B<iCmqtt>
publishes the openHAB topic and state.

As an extra service B<iCmqtt> -G generates the include files:
     <floor>_OHaliasIEC.ih and <floor>_OHdeclare.ih and optionally
     <floor>_OHextern.ih with the additional -E flag and a test app
     <floor>_OHtest.ic with virtual I/O inputs IX<z> with -T <z>
for every floor to provide descriptive iC variable alias names for
IX... and QX...

The translation between MQTT topic names and iEC-1131 I/O names is
extracted from 'openHAB/configurations/items/<control>.items'.
The following are two typical entries:

Switch Sw_Sitting_Area "Sitting area" <switchnew> (OD_Crossing, Lights)
    {mqtt="
    >[geertvc:home/ff/LightChange/Lt_Sitting_Area:command:ON:MAP(openclose.map)],
    >[geertvc:home/ff/LightChange/Lt_Sitting_Area:command:OFF:MAP(openclose.map)],
    <[geertvc:home/ff/LightChange/Lt_Sitting_Area:state:MAP(openclose.map)]"
    }

Switch Sw_Bedroom "Bedroom" <switchnew> (OD_Crossing, Lights)
    {mqtt="
    >[geertvc:home/ff/LightChange/Lt_Bedroom:command:ON:MAP(openclose.map)],
    >[geertvc:home/ff/LightChange/Lt_Bedroom:command:OFF:MAP(openclose.map)],
    <[geertvc:home/ff/LightChange/Lt_Bedroom:state:MAP(openclose.map)]"
    }

iCmqtt generates two files for each floor - example from the 'ff'
entries above:

    1. The actual alias assignments - home_ff_OHaliasIEC.ih,
    which is included last in the iC control program.
    The iC names are developed from the parenthesized text in the 'Switch' (first) line
    of each openHAB item.

    ff_RBD_SittingArea_ON  = IX10.0;    // home/ff/LightChange/Lt_Sitting_Area:command:ON
    ff_RBD_SittingArea_OFF = IX10.1;    // home/ff/LightChange/Lt_Sitting_Area:command:OFF
    QX10.0 = ff_RBD_SittingArea_state;  // home/ff/LightChange/Lt_Sitting_Area:state

    ff_RBD_Bedroom_ON      = IX10.2;    // home/ff/LightChange/Lt_Bedroom:command:ON
    ff_RBD_Bedroom_OFF     = IX10.3;    // home/ff/LightChange/Lt_Bedroom:command:OFF
    QX10.1 = ff_RBD_Bedroom_state;      // home/ff/LightChange/Lt_Bedroom:state

    IX<x> and QX<y> variable names are chosen by iCmqtt starting with the IX<x> and QX<y>
    command line parameters. Bit 0 - 7 are used for the first 8 entries. Then <x> or <y>
    is incremented. The final IX... and QX... generated is output after generation to
    allow selection of a second inon-clashing range of IX... and QX... for the other floor.

    2. The declarations of those variables - home_ff_OHdeclare.ih,
    which is included early in the iC control program.

    imm bit   ff_RBD_SittingArea_ON;    // home/ff/LightChange/Lt_Sitting_Area:command:ON
    imm bit   ff_RBD_SittingArea_OFF;   // home/ff/LightChange/Lt_Sitting_Area:command:OFF
    imm bit   ff_RBD_SittingArea_state; // home/ff/LightChange/Lt_Sitting_Area:state

    imm bit   ff_RBD_Bedroom_ON;        // home/ff/LightChange/Lt_Bedroom:command:ON
    imm bit   ff_RBD_Bedroom_OFF;       // home/ff/LightChange/Lt_Bedroom:command:OFF
    imm bit   ff_RBD_Bedroom_state;     // home/ff/LightChange/Lt_Bedroom:state

    All iC variables declared above must be used in the iC control programs
    if they are _ON or _OFF and input as IX...
    or assigned if they are _state variables output as QX....

    3. The topics between the first pair of colons in the openHab
    items file and the 'ON' and 'OFF' commands as well as the 'state'
    are used to subsribe and publish openHAB messages from and to MQTT.

=head1 SPECIFICATION

On startup of B<iCmqtt> the following actions are carried out:

  1) If command line parameter -G is given, the openHAB ini
     file 'openHAB/configurations/items/<control>.items' is used as
     described above to generate include files and optionally an iC
     test program to assist in placing the genrated iC variable names
     for connecting from and to openHAB via iCmqtt and the MQTT broker.

  2) When run without ithe -G command line flag he openHAB ini file
     'openHAB/configurations/items/<control>.items' is scanned again
     and MQTT topics` and iC IEC-1131 I/O names are  extracted.

     a) The <floor> topic prefix associated with the IX... variables
        followed by "/#" is sent as a 'subscribe' message to the MQTT
        broker.

     b) IEC-1131 I/O names starting with 'I' are iC inputs.

        i)   The IEC-1131 I/O base-name is registerd with iCserver as
             a 'sender, which returns a channel nunber.

        ii)  The I/O basename is used as a key in the Hash-file
             %IECs, containing an array for every bit to store
             the iC variable name in the SWitch line extended by
             either :ON or :OFF.

        iii) When MQTT sends a message ON or OFF for one of the
             subscribed topics a 100 ms pulse is sent to the matching
             IX... via the channel number and the bit obtained from
             %IECs.

        vi)  The alias assignment for IX... in <iCinclude>_ass.ih
             will pulse the apropriate descriptive iC variable in
             the iC control program for 100 ms.

     b) IEC-1131 I/O names starting with 'Q' are iC outputs.

        i)   The IEC-1131 I/O base-name is registerd with iCserver as
             a 'receiver, which returns a channel nunber.

        ii)  The I/O basename is used as a key in the Hash-file
             %IECs, containing an array for every bit to store
             the iC variable name in the SWitch line.

        iii) When iCserver sends a value 0 or 1 (LO or HI) on the
             channel and bit associated with the QX... variable, the
             topic obtained via %IECs is published with ON or OFF as
             the states message.

  3) iCserver is started unless it is running already.

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<immcc(1)>, L<iClive(1)>, L<iCserver(1)>, L<iCpiI2C(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2023  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
