#!/bin/bash
########################################################################
#
#	Copyright (C) 2000-2001  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	Mdiff - multiple diff with precise list and status output
#
########################################################################

usage()
{
  echo >&2
  echo 'Generate a full report of differences between a list of files  in the' >&2
  echo 'current directory and files with the same name in another directory.' >&2
  echo >&2
  echo 'Option -l allows the generation of lists of different or identical files in' >&2
  echo 'the two directories or a list of non-existing files in the second directory.' >&2
  echo 'These 3 lists are exclusive subsets of the complete set of selected files.' >&2
  echo >&2
  echo "Usage:	$name [+w] [-ietqlckILZh] [-x<regex>] [-d<dir>] [-C<command>|file ...] directory" >&2
  echo '	+w	whitespace (spaces, tabs, blank lines) are significant' >&2
  echo '		default: whitespace and blank lines are ignored' >&2
  echo '	-i	identical files output:	==== file ====' >&2
  echo '		default: ignore identical files in output' >&2
  echo '	-e	non-existing files put:	**** file does not exist' >&2
  echo '		default: ignore non-existing files in output' >&2
  echo '			 (unless only 1 file)' >&2
  echo '		if files differ output:	#### file ####' >&2
  echo '			 followed by the output of diff' >&2
  echo '	-l	list files which differ - no other output' >&2
  echo '	-li	list files which are identical' >&2
  echo '	-le	list files which are non-existing in directory' >&2
  echo '	-d<dir>	use directory <dir> instead of current directory' >&2
  echo '	-p	full path in file names for directory (default removed)' >&2
  echo '	-r	recursively Mdiff all directories in arg list except last' >&2
  echo '	-L	compare files and directories which are symbolic links' >&2
  echo '		default: ignore symbolic links (treated as non-existing)' >&2
  echo '	-t	text and date header at start of report' >&2
  echo '	-q	quiet operation - return status only' >&2
  echo '	-c	display diff output in context form' >&2
  echo '	-I	case insensitive and white space ignored' >&2
  echo '	-k	ignore lines containing the string $Id:' >&2
  echo '	-x <regex> ignore changes in lines that match regex' >&2
  echo '	-C <command> shell command to generate a list of files.' >&2
echo "	-Z	extra debugging output for $0 development" >&2
  echo '	-h	this help text' >&2
  echo '	--	output is piped to less' >&2
  echo '	-	all further arguments are treated as files' >&2
  echo "	if no files or command is specified, '$defaultfiles' is used" >&2
  echo '	return status 0 (true) if all files are identical' >&2
  echo '	return status n (false) number of files which differ' >&2
  echo 'Author:	John E. Wulff        <john@je-wulff.de>' >&2
  echo '$Id: Mdiff,v 1.30 2004/01/18 13:12:52 archiv Exp $' >&2
}

########################################################################
#
#	generate an optional header
#
########################################################################

header()
{
    if [ $headFlag = 0 ]; then
	if [ "$t" = 0 ]; then
	    if [ "$headCnt" = 0 ]; then
		date
	    else
		echo
	    fi
	    echo "Differences in $PWD/$1 and $PWD/$2"
	fi
	headFlag=1
	let headCnt+=1
    fi
}

########################################################################
#
#	all echo's to stdin are in processFiles which may be piped
#
########################################################################

processFiles()
{
    local t1="${1%/}/"
    local td="${t1#./*}"
    t1="${td%/}"
    shift
    local dir="${1%*/}"
    shift
    headFlag=0
    local status=0
    local f1
    local f2
test "$Z" = 1 && echo "td: '$td'"
test "$Z" = 1 && echo "t1: '$t1'"
test "$Z" = 1 && echo "dir: '$dir'"
test "$Z" = 1 && echo "processFiles \$*: '$*'"

    for f in $*; do
	local tdSf="$td$f"
	if [ -f $tdSf ]; then
	    if [ ! -L $tdSf ] || [ "$Link" != 0 ]; then
		local dirsSf="$dir/$f"
		if [ "$p" = 0 ]; then
		    dirsSf="$dir/${f##*/}"
		fi
		if [ -f $dirsSf ]; then
		    if [ $tdSf -ef $dirsSf ]; then
			if [ ! -L $tdSf ] && [ ! -L $dirsSf ]; then
			    f1=${f%/*}
			    if [ "$f" = "$f1" ]; then
				f1="."
			    fi
			    f2=${dirsSf%/*}
			    echo "$name: paths $td$f1 and $f2 are identical - ignored" >&2
			    status=-1
			    break
			fi
		    elif [ -L $dirsSf ] && [ "$Link" = 0 ]; then
			if [ "$e" != 0 ]; then
			    let status+=1
			    if [ "$q" = 0 ]; then
				header "$t1" "$dir"
				echo "********** $dirsSf is a symbolic link"
			    elif [ "$li" = 1 ]; then
				echo $tdSf
			    fi
			fi
		    elif diff -q $w $tdSf $dirsSf > /dev/null; then
			if [ "$q" = 0 ]; then
			    if [ "$i" != 0 ]; then
				header "$t1" "$dir"
				echo "========== $tdSf =========="
			    fi
			elif [ "$li" = 3 ]; then
			    echo $tdSf
			fi
		    else
			let status+=1
			if [ "$q" = 0 ]; then
			    header "$t1" "$dir"
			    echo
			    echo "########## $tdSf ##########"
			    if [ -z "$context" ]; then
				ls -lL $tdSf
				ls -lL $dirsSf
			    fi
			    diff $w $context $tdSf $dirsSf
			elif [ "$li" = 1 ] && [ "$e" = 0 ]; then
			    echo $tdSf
			fi
		    fi
		elif [ "$e" != 0 ]; then
		    let status+=1
		    if [ "$q" = 0 ]; then
			header "$t1" "$dir"
			echo "********** $dirsSf does not exist"
		    elif [ "$li" = 1 ]; then
			echo $tdSf
		    fi
		fi
	    fi
	fi
    done
    if [ "$status" != 0 ] && [ "$q" = 0 ]; then
	echo
	local files_differ="files differ"
	if [ "$status" = 1 ]; then
	    files_differ="file differs"
	fi
	if [ -z "$td" ]; then
	    echo "########## $status $files_differ ##########"
	else
	    echo "########## $status $files_differ in $td ##########"
	fi
    fi
    return $status
}

########################################################################
#
#	handle directories recursively
#
########################################################################

processDirectory()
{
    local this=$1
    shift
    local fileArgs=''
    local fileParams=''
    local fileCnt=0
    local directory=''
    local ff=''
    local status=0
    local f1
    local f2
    local d
    local dd

    while [ $# -gt 0 ]; do
	f1=${1#$this/}
	f2="${f1%/}"
test "$Z" = 1 && echo "this $this 1 '$1' f1 '$f1' f2 '$f2' command '$command'"
	if [ -d "$1" ]; then
	    directory=$f2	# last directory in args is other directory
	elif [ "$level" = 0 ]; then
	    if [ -f "$this/$f2" ]; then
		fileArgs="$fileArgs $f2"
	    fi
	    fileParams="$fileParams $1"
	    let fileCnt+=1
	else
	    fileParams="$fileParams $1"
	    ff="$1"
test "$Z" = 1 && echo "ff: '$ff'"
	fi
	shift
    done
test "$Z" = 1 && echo "ff1: $fileCnt: '$ff'"

    if [ $fileCnt = 0 ]; then
	if [ -z "$ff" ] || [ "$ff" = " " ]; then
	    if [ -n "$command" ]; then
		local tmp=${command#[a-zA-Z_]*}
test "$Z" = 1 && echo "$PWD: '$tmp' '$command'"
		if [ "$tmp" != "$command" ]; then
		    cd $this		# first character of command is a letter
		    if ff=`$command 2> /dev/null`; then
test "$Z" = 1 && echo "ct: '$ff'"
			cd -
		    else
			cd -
			ff="$this/$command"
test "$Z" = 1 && echo "ct failed: '$ff'"
		    fi
		else
		    ff="$this/$command"
test "$Z" = 1 && echo "tc: '$ff'"
		fi
	    else
		ff="$this/$defaultfiles"
test "$Z" = 1 && echo "td: '$ff'"
	    fi
	fi
    fi
test "$Z" = 1 && echo "ff2: $fileCnt: '$ff'"
test "$Z" = 1 && echo "$PWD: '$command' '$this':" $ff
    
    if [ -n "$ff" ]; then
	for f1 in $ff; do
	    f2=${f1#$this/}
	    if [ -f "$this/$f2" ]; then
		fileArgs="$fileArgs $f2"
		let fileCnt+=1
test "$Z" = 1 && echo "for ff: $fileCnt: $fileArgs"
	    fi
	done
    fi

    if [ "$level" = 0 ]; then
	if [ -z "$directory" ]; then
	    echo "$name: there must be at least one directory argument" >&2
	    usage
	    exit 253		# call provides directory at other levels
	fi
	if [ $fileCnt = 0 ] && [ $recursive = 0 ]; then
	    echo "$name: there are no files or directories to compare" >&2
	    exit 252		# can be empty at other levels
	fi
    fi

    if [ $fileCnt -gt 0 ]; then
	if [ $fileCnt = 1 ] && [ $q = 0 ] && [ $recursive = 0 ]; then
	    e=1;		# for single file argument, check if other file exists
	fi
test "$Z" = 1 && echo "call processFiles \$this: '$this' \$directory: '$directory' \$fileArgs: '$fileArgs'"
	processFiles $this $directory $fileArgs; let status+=$?
    fi
    if [ $recursive = 1 ]; then
	let level+=1
	for d in $this/*; do
	    if [ -d $d ]; then
		if [ "$Link" != 0 ] || [ ! -L $d ]; then
		    let dc+=1
		    dd=${d#$this/}
		    if [ -d $directory/$dd ]; then
			if [ "$Link" != 0 ] || [ ! -L $directory/$dd ]; then
test "$Z" = 1 && echo "processDirectory $this/$dd $fileParams $directory/$dd;"
			    processDirectory $this/$dd "$fileParams" $directory/$dd; let status+=$?
			elif [ "$e" != 0 ]; then
			    let status+=1
			    if [ "$q" = 0 ]; then
				echo "********** $directory/$dd/ is a symbolic link"
			    elif [ "$li" = 1 ]; then
				echo $directory/$dd/
			    fi
			fi
		    elif [ "$e" != 0 ]; then
			let status+=1
			local td="$this/$dd"
			local t1="${td%/}/"
			td="${t1#./*}"
			t1="${td%/}"
			if [ "$q" = 0 ]; then
			    headFlag=0
			    header "$t1" "$directory/$dd"
			    echo "********** $directory/$dd/ does not exist"
			elif [ "$li" = 1 ]; then
			    echo "$t1/"
			fi
		    fi
		fi
	    fi
	done
	let level-=1
    fi

    if [ "$level" = 0 ] && [ "$dc" != 0 ] && [ "$status" != 0 ] && [ "$q" = 0 ]; then
	echo
	files_differ="files differ"
	if [ "$status" = 1 ]; then
	    files_differ="file differs"
	fi
	directories="directories"
	if [ "$headCnt" = 1 ]; then
	    directories="directory"
	fi
	echo "########## $status $files_differ in $headCnt $directories ##########"
    fi
    return $status
}

########################################################################
#
#	main
#
########################################################################

name=${0##*/}
name=${name%.*}
i=0; e=0; t=1; p=0; q=0; li=0; w=-wB; pipe=0;
recursive=0; level=0; Link=0; headCnt=0;
context=''
defaultfiles='*.[achimlyv]*'
command=''
thisdir='.'
dc=0
status=0

while [ $# -gt 0 ]; do
    case $1 in
    -)	shift; break;;
    -*)	option=${1#?}
	while [ -n "$option" ]; do
	    case $option in
	    e*)	e=1;;
	    i*)	i=1; let "li|=2";;
	    l*)	t=1; q=1; let "li|=1";;
	    t*)	t=$q;;
	    p*)	p=1;;
	    q*)	t=1; q=1;;
	    c*) context="-c";;
	    k*)	w="$w -I \$Id:";;
	    I*)	w=-wBi;;
	    r*)	recursive=1;;
	    R*)	recursive=1;;
	    L*)	Link=1;;
Z*)	Z=1;;
	    d*)	option=${option#?}
		if [ -z "$option" ]; then
		    shift
		    option=$1
		fi
		thisdir="./$option"
		break;;
	    x*)	option=${option#?}
		if [ -z "$option" ]; then
		    shift
		    option=$1
		fi
		w="$w -I $option"
		break;;
	    C*)	option=${option#?}
		if [ -z "$option" ]; then
		    shift
		    option=$1
		fi
		command="$option"
		break;;
	    h*)	usage; exit 255;;
	    -*)	pipe=1;;
	    *)	x=${option#?}; option=${option%$x}
	    	echo "$name: unexpected option $option in $1" >&2
		usage; exit 254;;
	    esac
	    option=${option#?}
	done
	;;
    +w) w=;;
    *)	break;;
    esac
    shift
done
test "$Z" = 1 && echo "processDirectory $thisdir" "$@"

if [ "$pipe" = 0 ]; then
    processDirectory $thisdir "$@"
else
    processDirectory $thisdir "$@" | less
fi
