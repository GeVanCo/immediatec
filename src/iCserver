#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2017  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCserver; the TCP/IP server for iC clients - both apps and I/O's
#
#	The full specification is in the POD documentation at the end
#
#	For measuring reaction times the Module Time::HiRes is used.
#	Time::HiRes is also used to delay the Autovivify action.
#	Time::HiRes is activated by the -m and the -a options.
#	Make sure you have installed the Perl Module Time::HiRes
#
########################################################################

use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use strict;
use warnings;

my %Clients = ();	# indexed by $name - existence of registered N<name> client (duplicate clients)
my %Channels = ();	# indexed by $name - points to correct channel of I/O S<name> and R<name> (duplicate channels)
my %Equivalences = ();	# hashed by $base - points to equivalent names with same or different channel as base
my %EquivBase = ();	# hashed by $name - points to base name of equivalenced names (even own name if base)
my %ClientNames = ();	# hashed by $conn - points to client name for a connection
my @Sender = ();	# indexed by $channel ... stores send connection       conn                 for channel
my @SenderName = ();	# indexed by $channel ... stores send names            name
my @SenderValue = ();	# indexed by $channel ... stores send current values   value1
my @Receivers = ();	# indexed by $channel ... stores receiver connections [ conn1,  conn2  ... ] for primary channel
my %AltReceivers = ();	# hashed by $channel  ... stores secondary channel and receiver connections for an alternate channel
			# [ [ channel1, conn3, conn4 ... ],  [ channel2, conn5, conn6 ... ] ... ]
my @ReceiverNames = ();	# indexed by $channel ... stores receiver names [ name1, name2, name3, ... ] for primary channel
my %AltRecrNames = ();	# hashed by $channel  ... stores receiver names for an alternate channel
			# [ [ name3, name4 ... ],  [ name5, name6 ... ] ... ]
my %ReceiverData = ();	# hashed by $conn - built in pushReceiverData() - sent at end of rcvd_msg_from_client()
			# [ conn,ch1:val1,ch2:val2 ... ]
my $numberOfConnections = 0;
my $maxChannel = 0;
my $regFlag = 0;
my $ackString = '';
my $iniString = '';
my $ioName = '';
my $AutoDelay = 50_000;	# 50 ms for normal autovivify delay (4 ms is just sufficient to catch 2nd connection)
my %AutoVivify = ();
my $AutoDebug = '';
my %sortOrder = (	# determines in which order iCboxes ar autovivified
    IX => 0, QX => 5,
    IB => 1, QB => 6,
    IW => 2, QW => 7,
    IL => 3, QL => 8,
    IH => 4, QH => 9,
);
my @argv = ();

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
    @<<<<<<< [-adgrktIOmTqzh][ -s <host>][ -p <port>][ -f <file>][ -A <cmd>]
	$named
	     [ -G <dbg>][ [-e]<list of equivalences>][ <list of client calls>]
	     [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
	-s host	address of server - clients must specify the same address
		unless (default '0.0.0.0' which accepts any client host)
	-p port	service port of server for all clients  (default '8778')
	-e <equivalences> eg: IX0=IX0-1     (can be used more than once)
		or a comma separated list eg: IX0=IX0-1,QX0=QX0-1,IB1=IB1-1
	-f file	read options, equivalences and client calls from this file
	-q      quiet - do not report clients connecting and disconnecting
	-a      autovivify I/O clients 'iCbox' for missing I/O's (any number
		of iCbox's can be autovivified with -a as apps register)
	-d      autovivify I/O client 'iCbox -d' for missing I/O's, which is
		useful to monitor real I/O (only one 'iCbox -d' can be auto-
		vivified to avoid recursive calls for missing senders to the
		display only 'iCbox -d')
	-A cmd  use <cmd> to autovivify I/O clients (eg -A 'iCbox -Q2 -C19')
	-g      autovivify debugger 'iClive' when an iC app registers
	-G dbg  autovivify debugger <dbg>
	-r      reset registered receivers when sender disconnects - ie reset
		outputs of an app when it shuts down (default no change)
	-k      kill previous client when a new client with the same name
		registers (default: do not accept the new client)
	-z      block keyboard input
	    DEBUG options
	-t	trace messages for debugging
	-I      trace rcv messages in Msg.pm
	-O      trace send messages in Msg.pm
	-m	display elapsed time in seconds and microseconds
	-T      extra static debug messages
	-h	help, ouput this Usage text only
	    OLD STYLE CALLS
	<equivalences> - deprecated - use -e <equivalences> instead
		eg: IX8=IX8-0=IX8-1,IX9=IX9-0=IX9-1
	<client calls> - deprecated - use -R <app ...> instead
		eg: 'iCbox X0-X3 X10' sort
		if a client call has arguments, the call must be quoted
	    AUXILIARY app   - start a Bernstein chain
	-R <app ...> run one app followed by -z and its arguments as a
		     separate process; -R ... must be last arguments,
		     which do not need to be quoted.
		eg: -R iCbox X0-X3 X10 -R sort
	    KEYBOARD inputs
	    T   output table of all registered client I/Os and channels
	    q   from keyboard: stops @<<<<<<< and all apps
				$named
Copyright (C) 2000-2017  John E. Wulff		<immediateC@gmail.com>
							  '@'
$Id: iCserver 1.54 $
.

########################################################################
#	Handle -f option - count leading options up to -f
#	splice out -f and shift its file_name_argument into @runArgs
#	including a final -R ... option, which will be extracted later
########################################################################

my ($argIndex, $blank, $file, @runArgs);
$argIndex = $blank = 0;
@runArgs = ();
# print "0 \@ARGV = '@ARGV'\n";
foreach (@ARGV) {
    if (s/^-f(.*)$/$1/) {
	$blank = 1 if $_ eq "";		# -f <file>
	$file = "";			# or -f<file>
	last;
    } elsif (s/^(-[^espAGRf]+)f(.*)$/$1/) {
	$file = $2;			# -abcf <file>
	$blank = -1 if $file ne "";	# or -abcf<file>
	$argIndex++;
	last;
    }
    $argIndex++;
}
# no warnings;
# print "1 \@ARGV = '@ARGV'	\$argIndex = $argIndex	\$file = '$file' $#ARGV\n";
# use warnings;
@runArgs = splice(@ARGV, $argIndex, 1 + $blank);
if (defined $file) {
    shift(@runArgs) if $blank > 0;
    unshift(@runArgs, $file) if $file ne "";
}
# print "2 \@ARGV = '@ARGV'	\@runArgs = '@runArgs'\n";
$file = shift(@runArgs) ;
# print "3 \@ARGV = '@ARGV'	\$file = '$file'\n";

########################################################################
#	Read optional INI file
#	Quoted entries are retained as single tokens
#	Comments in the INI file are started with #
########################################################################

if ($file) {
    my $state = "P";		# P outside of comments and quotes
    my @lookfors = ('"',  "'", " ", "\t");	# quotes and white space
    my ($lookfor, $atom, $pos, %atoms, @newArgs, $arg);
    open INI, $file or die "can't open INI file $file! $!";
    while (<INI>) {		# read next entry from INI file into $_
# print "4 $file: $_";
	chomp;			# $_
	s/\s*#.*$//;		# strip trailing # comment
	s/\s*([=:,;.])\s*/$1/g;	# remove spaces around separators
	########################################################################
	#   Mark spaces in quoted strings with ASCII RS (\036) to make them a
	#   single token for @newArgs = split(" ", $_); # use trusty state machine
	########################################################################
	%atoms = ();
	@newArgs = ();
	foreach $lookfor (@lookfors) {
	    for ($pos = $[;
		($pos = index($_, $lookfor, $pos)) >= $[;
		$pos += length $lookfor) {
		$atoms{ $pos } = $lookfor;	# key is position of atom found
	    }
	}
	########################################################################
	#   This algorithm ensures that the next relevant atom is checked
	#   in the state machine and not one much later in the line
	########################################################################
	foreach $pos (sort { $a <=> $b } keys %atoms) {
	    $atom = $atoms{ $pos };	# process atoms in sequence
	    if ($state eq "S") {	# double quoted string
		if ($atom eq '"' and
		    ($pos <  1 or  substr($_, $pos-1, 1) ne "\\" or
		    ($pos >= 2 and substr($_, $pos-2, 1) eq "\\"))) {
		    $state = "P";	# end of double quoted string
		}
	    } elsif ($state eq "H") {	# single quoted string
		if ($atom eq "'" and
		    ($pos <  1 or  substr($_, $pos-1, 1) ne "\\" or
		    ($pos >= 2 and substr($_, $pos-2, 1) eq "\\"))) {
		    $state = "P";	# end of single quoted string
		}
	    } elsif ($atom eq '"') {	# $state eq "P"
		$state = "S";		# start of double quoted string
	    } elsif ($atom eq "'") {
		$state = "H";		# start of single quoted string
	    }
	    if (($atom eq " " or $atom eq "\t") and		# white space
		($state eq "S" or $state eq "H")) {		# in quoted string
		substr($_, $pos, length($atom)) = "\036";	# replace ASCII RS
	    }
	}
	@newArgs = split(" ", $_);
	foreach $arg (@newArgs) {
	    $arg =~ s/\036+/ /g;	# replace space for ASCII RS after split()
	}
	push(@ARGV, @newArgs);		# concatenate new Args to existing ARGV
    }
    close INI;
}
# print "5 ARGV: ", join(':', @ARGV), ":\n";

########################################################################
#	Handle -R option - count leading options up to -R
#	splice -R to end - move app and remaining arguments to @runArgs
########################################################################

my ($app);
$argIndex = $blank = 0;
@runArgs = ();
# print "6 \@ARGV = '@ARGV'\n";
foreach (@ARGV) {
    if (s/^-R(.*)$/$1/) {
	$blank = 1 if $_ eq "";		# -R <app> <args ...>
	$app = "";			# or -R<app> <args ...>
	last;
    } elsif (s/^(-[^espAGR]+)R(.*)$/$1/) {
	$app = $2;			# -abcR<app> <args ...> or -abcR<app> <args ...>
	$argIndex++;
	last;
    }
    $argIndex++;
}
# no warnings;
# print "7 \@ARGV = '@ARGV'	\$argIndex = $argIndex	\$app = '$app' $#ARGV\n";
# use warnings;
@runArgs = splice @ARGV, $argIndex;
if (defined $app) {
    shift(@runArgs) if $blank;
    unshift(@runArgs, $app) if $app ne "";
}				# append a -z$opt_q later
# print "8 \@ARGV = '@ARGV'	\@runArgs = '@runArgs'\n"; exit;

########################################################################
#	Handle all remaining -switch options and non-switch options
########################################################################

use vars qw($opt_z $opt_a $opt_d @opt_e $opt_g $opt_k $opt_r $opt_t $opt_I $opt_O);
use vars qw($opt_m $opt_T $opt_q $opt_s $opt_p $opt_A $opt_G $opt_h);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    'z'   => \$opt_z,			# -z blocks STDIN
    '<>'  => sub { push(@argv, @_); },	# Transfer file argument to @argv
    'a'   => \$opt_a,
    'd'   => \$opt_d,
    'g'   => \$opt_g,
    'k'   => \$opt_k,
    'r'   => \$opt_r,
    't'   => \$opt_t,
    'I'   => \$opt_I,
    'O'   => \$opt_O,
    'm'   => \$opt_m,
    'T'   => \$opt_T,
    'q'   => \$opt_q,
    'e=s' => \@opt_e,
    's=s' => \$opt_s,
    'p=s' => \$opt_p,
    'A=s' => \$opt_A,
    'G=s' => \$opt_G,
    'h'   => \$opt_h,
);
scalar @ARGV == 0 or die "*** ERROR: $named: '@ARGV' remaining after Getopt::Long Getoptions() ???\n";

$| = 1 if $opt_t or $opt_m;	# otherwise STDOUT is not flushed if piped

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

if (defined $opt_A) {
    $opt_a = 1;
    $opt_A =~ s/iCbox/iCbox -d/ if $opt_d;
} elsif (defined $opt_d) {
    $opt_a = 1;
    $opt_A = 'iCbox -d';
} else {
    $opt_A = 'iCbox';
}
if (defined $opt_G) {
    $opt_g = 1;
} else {
    $opt_G = 'iClive';
}
if (@opt_e) {
    print "Equivalences '@opt_e' from -e\n" if $opt_T;
    allocate_equivalences(join(",", @opt_e));
}

my ($t0, $t1);
if ($opt_a or $opt_m) {
    use Time::HiRes qw(ualarm gettimeofday);
    $t0 = [gettimeofday] if $opt_m;	# start time of program
}

$SIG{PIPE} = \&catch_zap;		# signal 13
$SIG{ALRM} = \&autoVivify;		# signal 14 - Timer signal from ualarm()
if ($opt_t or $opt_I or $opt_O) {
    $| = 1;			# autoflush stdout
}
$SIG{INT}  = \&shutdown_server;	# signal 2	(ctrl-C interrupt from keyboard)
if ($opt_t) {
    $SIG{HUP}  = \&catch_zap;	# signal 1
    $SIG{USR1} = \&catch_zap;	# signal 10	(stop -10 iCserver)
    $SIG{USR2} = \&catch_zap;	# signal 12	(stop -12 iCserver)
} else {
    $SIG{USR1} = 'IGNORE';	# signal 10	(stop -10 iCserver)
    $SIG{USR2} = 'IGNORE';	# signal 12	(stop -12 iCserver)
}

########################################################################
#
#	Server
#
#	Inhibit Nagle's algorithm
#
########################################################################

my $host = defined $opt_s ? $opt_s : '0.0.0.0';
my $port = defined $opt_p ? $opt_p : 8778;

Msg->inhibit_nagle(1, $opt_I, $opt_O);	# inhibit Nagle's algorithm for real time response
Msg->new_server($host, $port, \&login_proc);
print STDERR "$named created. Waiting for events\n" unless $opt_q;

########################################################################
#
#	Analyse equivalences and client call parameters
#
#	Equivalences consist of two or more identifiers separated by an
#	equal sign (=).
#
#	Individual equivalences must be written without spaces in the
#	command line. In the optional INI file which can be read with
#	the -f option, white spaces may be used in equivalence lines.
#
#	Client calls consist of an identifier optionally followed by a
#	space separated list of parameters. Unless the client call is
#	a single identifier it must be quoted in the usual shell manner
#	both in the command line and the optional INI file.
#
#	Allocate equivalences and start clients named in argument list
#
#	Start each client call as a separate process after splicing in
#	optional global switches -p <port> -t -m
#
########################################################################

my ($argv);

if (scalar @argv > 1) {
    $AutoDelay = 2_000_000;		# 2 seconds for autovivify delay with more than 1 process
}
while ($argv = shift @argv) {
    if ($argv =~ /^[IQ][XBWLH]\d+(-\d{1,3})?/) {
	print "Equivalences '$argv' from command line\n" if $opt_T;
	allocate_equivalences($argv);
	$AutoDelay = 2_000_000;		# 2 seconds for autovivify delay with equivalences
    } else {
	$argv =~ s/['"]//g;		# for this mode call and args are quoted
	fork_and_exec($argv);		# old style start of client call (deprecated - use -R)
    }					# particularly if starting more than 1 process
}

########################################################################
#	Optionally run -R option
########################################################################
if (@runArgs) {
    $AutoDelay = 2_000_000;		# 2 seconds for autovivify delay with more than 1 process
    splice @runArgs, 1, 0, "-z" unless defined $opt_z;	# spliced in at fork_and_exec() if defined -z
    fork_and_exec(join " ", @runArgs);	# new style -R start of Bernstein chain
}

########################################################################
#
#	Register an event handler callback for STDIN to recognise
#	q or ctrl+D from the keyboard to terminate the program
#	unless $opt_z (-z) which blocks STDIN if called in a chain.
#
#	Sit in an infinite loop dispatching incoming events.
#	if connected to iCserver
#
########################################################################
Msg->set_event_handler(*STDIN, "read" => \&readStdin) unless $opt_z;
Msg->event_loop();

####### End of main program ############################################

########################################################################
#
#	Read from STDIN
#
########################################################################

sub readStdin {
    my $line = readline(STDIN);
    if (not defined $line or $line =~ m/^q/) {	# ctrl+D (EOF) or q
	shutdown_server("stopped from terminal");
    } elsif ($line =~ m/^T/) {
	print_tables();
    }				# ignore other inputs
} # readStdin

########################################################################
#
#	Fork and exec another process
#
########################################################################

sub fork_and_exec {
    my ($argv) = @_;
    my ($pid);
    FORK: {
	select undef, undef, undef, 1 if defined $pid;	# delay if previous fork
	return if ($pid = fork);
	if (defined $pid) {	# $pid is zero if defined
	    ## dispatch child process
	    my @call = split " ", $argv;
	    my $n = 1;
	    if ($call[0] eq "perl") {	# only needed for WIN32
		 1 while $call[$n++] =~ /^-/;
	    }				# end of code for WIN32
	    splice @call, $n, 0, "-p", $opt_p if defined $opt_p;
	    splice @call, $n, 0, "-t" if defined $opt_t;
	    splice @call, $n, 0, "-m" if defined $opt_m;
	    splice @call, $n, 0, "-z" if defined $opt_z;
	    splice @call, $n, 0, "-q" if defined $opt_q;
	    print STDERR "\$ @call &\n" unless $opt_q;
	    exec @call;
	    die "$named: returned from exec $call[0] ???: $!\n";
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "$named: can't fork ???: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Catch ctrl-C interrupt, 'q' or ctrl-D (EOF) from keyboard
#	or 'X' from parent to disconnect all clients and then shut down
#
########################################################################

sub shutdown_server {
    my $signame = shift;
    my ($name, $con);
    if ($signame =~ /^INT/) {
	$signame = "Interrupt from keyboard";
    }
    print STDERR "\n$signame - stop $named\n" unless $opt_q;
    foreach $name (keys %Clients) {
	print STDERR "Shut down $name\n" unless $opt_q;
	$con = $Clients{$name};
	$con->send_now("");		# send null message to shut down client
    }
    exit 0;
} # shutdown_server

########################################################################
#
#	Catch and report stray signals
#
########################################################################

sub catch_zap {
    my $signame = shift;
    if ($signame =~ /^USR1/) {
	print_tables();
    } else {
	die "$named: Caught SIG$signame: $!";
    }
} # catch_zap

########################################################################
#
#	Login procedure
#
########################################################################

sub login_proc {
    my ($conn, $host, $port) = @_;
    print STDERR "Connection $host:$port at $named\n" unless $opt_q;
    if (%AutoVivify) {
	$AutoDelay = 2_000_000;		# a new connection has come in before previous Autovivify
    }
    return \&rcvd_msg_from_client;
} # login_proc

########################################################################
#
#	Disconnect a client
#
#	undef $Sender[$channel] for all channels at this $conn
#	splice out all @{$Receivers[$channel]} entries with this $conn
#	splice out all @{$ReceiverNames[$channel]} entries with this $conn
#	as well as similar elements in %AltReceivers and %AltRecrNames
#
########################################################################

sub disconnect {
    my ($conn, $sender) = @_;
    my ($channel, $con, $rflag, $aref, $nref, $ch, $i, $j, $in);
    my ($name, $base, $primCh, $secCh);
    $sender = $ClientNames{$conn} unless defined $sender;
    if (defined $sender) {
	print "$sender: client no. $numberOfConnections unregistering now\n" if $opt_t;
	%ReceiverData = ();		# clear all keys and entries
	for ($channel = 0; $channel <= $maxChannel; $channel++) {
	    $rflag = 0;
	    if (defined ($con = $Sender[$channel]) and $con eq $conn) {
		$Sender[$channel] = undef;	# no need to splice out only array entry
		if ($opt_r and $SenderValue[$channel] != 0) {
		    $rflag = 1;
		    $SenderValue[$channel] = 0;			# reset sender
		}
		print "$sender: S $SenderName[$channel]	$channel undef\n" if $opt_t;
	    }
	    if ($rflag) {
		# scan once before slicing out any array elements
		foreach $con (@{$Receivers[$channel]}) {
		    if ($con ne $conn) {
			pushReceiverData($con, "$channel:0");	# reset receiver
		    }
		}
		if (exists $AltReceivers{$channel}) {
		    foreach $aref (@{$AltReceivers{$channel}}) {
			$ch = $aref->[0];				# alternate channel
			foreach $con (@{$aref}[1 .. $#{$aref}]) {
			    pushReceiverData($con, "$ch:0");	# reset message to alternate channel
			}
		    }
		}
	    }
	    ############################################################
	    ## Do not use foreach when splicing out entries
	    ############################################################
	    if ($Receivers[$channel]) {
		for ($i = 0; $i < @{$Receivers[$channel]}; $i++) {
		    $con = $Receivers[$channel][$i];
		    if ($con eq $conn) {
			$nref = $ReceiverNames[$channel];
			$name = $nref->[$i];
			$EquivBase{$name}->[2] = 0 if $EquivBase{$name};	# clear secondary channel to flag no registration
			print "$sender: R $name	$channel spliced out\n" if $opt_t;
			splice @{$Receivers[$channel]}, $i, 1;	# splice out connection
			splice @{$nref}, $i, 1;			# splice out name
			############################################################
			## Checked that there are no multiple Receiver entries
			## with the same $conn when registering. Nevertheless scan
			## to the end to keep $i correct for @AltReceivers
			############################################################
			$i--;			# adjust index of next entry and name to be spliced out
		    }
		}
	    }
	    if (exists $AltReceivers{$channel}) {
		for ($j = 0; $j < @{$AltReceivers{$channel}}; $j++) {
		    $aref = $AltReceivers{$channel}[$j];
		    $secCh = $aref->[0];
		    for ($i = 1; $i < @{$aref}; $i++) {
			$con = $aref->[$i];
			if ($con eq $conn) {
			    $nref = $AltRecrNames{$channel}->[$j];
			    $name = $nref->[$i - 1];
			    $EquivBase{$name}->[2] = 0 if $EquivBase{$name};	# clear secondary channel to flag no registration
			    print "$sender: R $name	$secCh spliced out\n" if $opt_t;
			    splice @{$aref}, $i, 1;	# skip extra channel entry
			    splice @{$nref}, $i - 1, 1;	# splice out name whose index starts at 0
			    $i--;		# adjust index of next entry and name to be spliced out
			}
		    }
		    if (@{$aref} <= 1) {	# group has no connections left, only alternate channel
			print "AltReceivers{$channel} group $j spliced out \[$#{$aref}\] '@{$aref}'\n";
			splice @{$AltReceivers{$channel}}, $j, 1;	# whole group disconnected
			splice @{$AltRecrNames{$channel}}, $j, 1;	# whole group disconnected
			$j--;			# adjust index of next group to be spliced out
		    }
		}
		if (@{$AltReceivers{$channel}} == 0) {
		    delete $AltReceivers{$channel};	# delete whole alternate channel set
		    delete $AltRecrNames{$channel};
		}
	    }
	}
	delete $ClientNames{$conn};
	delete $Clients{$sender};
	print "Disconnected '$sender'\n" unless $opt_q;
	$numberOfConnections--;
	if ($numberOfConnections <= 0) {
	    ############################################################
	    ## This was last connection - clear all arrays and hashes
	    ## this prevents channel numbers getting higher and higher
	    ############################################################
	    %Clients = ();
	    %Channels = ();
	    %ClientNames = ();
	    @Sender = ();
	    @SenderName = ();
	    @SenderValue = ();
	    @Receivers = ();
	    %AltReceivers = ();
	    @ReceiverNames = ();
	    %AltRecrNames = ();
	    $maxChannel = 0;
	    ############################################################
	    ## Re-constitute channels of equivalence arguments.
	    ## All secondary channels in %EquivBase have been set to 0
	    ## so use %Equivalences to get secondary channels instead.
	    ############################################################
	    foreach $base (sort keys %Equivalences) {
		foreach $aref (@{$Equivalences{$base}}) {
		    if (($secCh = $aref->[0]) > 0) {
			$nref = $aref->[1];
			foreach $in (sort keys %$nref) {
			    $name = $nref->{$in};
			    allocate_channel($name, $secCh);	# allocate channel for equivalence IEC
			}
		    }
		}
	    }
	    print "$named: last client has unregistered\n" if $opt_t;
	}
    } else {
	warnD("the connection $conn is not currently registered - system error");
    }
    $conn->disconnect();
} # disconnect

########################################################################
#
#	Warning sent to Debug (iClive) registered on channel 0
#
########################################################################

sub warnD {
    my ($warnMsg) = @_;
    my ($name, $channel, $aref, $rconn);
    warn $warnMsg;		# normal terminal warning
    chomp $warnMsg;
    if ($aref = $Receivers[0]) {	# channel 0 for error messages
	foreach $rconn (@$aref) {
	    print "$named: sent warning => $ClientNames{$rconn}\n" if $opt_t;
	    $rconn->send_now("0:1;$warnMsg");
	}
    }
} # warnD

############################################################
#
#	Allocate a channel to a name
#
#	This gives each Sender and Receiver pair an index called
#	$channel in the arrays @Sender, @Receivers and %AltReceivers.
#	Each data transmission starts with this channel number.
#	Some differing names may use the same channel (equivalences).
#
############################################################

sub allocate_channel {
    my ($name, $channel) = @_;
    my $ch;
    if (defined ($ch = $Channels{$name})) {
	warnD("$named: attempting to allocate channel $channel for $name:$ch twice - ignore\n") if defined $channel;
	$channel = $ch;
    } else {
	$channel = ++$maxChannel unless defined $channel;
	$Channels{$name} = $channel;
    }
    print "$named: allocate_channel $name, $channel\n" if $opt_t;
    return $channel;
} # allocate_channel

############################################################
#
# Allocate equivalences in $arg either as a single equivalence or as a
# space or comma separated list of simple equivalences IX0=IX0-1=IX0-2
# or group-equivalences IX0=IX2=IX4, which belong to one instance of
# an app characterized by having the same connection (this precludes
# them from being simple equivalences on the same channel).
#
# %Equivalences		# Auxiliary structure only used to build %EquivBase
# hashed by $base - points to equivalent names with same or different channel as base IX0
# equivalence group (usually only has one sub-group with the channel of the base name)
# {
#  IX0 => [ [ ch0, { IX0, IX0-1, IX0-2 ... } ],	# channel same as base channel
#           [ ch1, { IX1, IX1-1, IX1-2 ... } ],	# members of another group with a different channel
#           [ ch2, { IX2, IX2-1, IX2-2 ... } ] ... ],
#  IX5 => [ [ ch3, { IX5, IX5-1, IX5-2 ... } ] ... ],
#  ... => ...
# }
#
# %EquivBase		# Used during registration and autovivification
# hashed by $name - points to base name of equivalenced names (even own name if base)
# [primaryBase, primaryChannel, secondaryChannel, \$Equivalences{}->[] ]
# {           [0]  [1]  [2]  [3]
#  IX0   => [ IX0, ch0, ch0, \$Equivalences{IX0}->[0] ],
#  IX0-1 => [ IX0, ch0, ch0, \$Equivalences{IX0}->[0] ],
#  IX0-2 => [ IX0, ch0, ch0, \$Equivalences{IX0}->[0] ],
#  IX1   => [ IX0, ch0, ch1, \$Equivalences{IX0}->[1] ],
#  IX1-1 => [ IX0, ch0, ch1, \$Equivalences{IX0}->[1] ],
#  IX1-2 => [ IX0, ch0, ch1, \$Equivalences{IX0}->[1] ],
#  IX2   => [ IX0, ch0, ch2, \$Equivalences{IX0}->[2] ],
#  IX2-1 => [ IX0, ch0, ch2, \$Equivalences{IX0}->[2] ],
#  IX2-2 => [ IX0, ch0, ch2, \$Equivalences{IX0}->[2] ],
#  IX5   => [ IX5, ch3, ch3, \$Equivalences{IX5}->[0] ],
#  IX5-1 => [ IX5, ch3, ch3, \$Equivalences{IX5}->[0] ],
#  IX5-2 => [ IX5, ch3, ch3, \$Equivalences{IX5}->[0] ],
#  ...   => ...
# }
#
# If no name in an equivalence is found in %EquivBase start a new
# equivalence set and group hashed by either the only output name in
# the set or the first input name in the set as primary base.
#   else use group in %Equivalences pointed to by $EquivBase->[3].
# Only one pre-equivalenced name may occurr in a group, but each
# group of a set may have one pre-equivalenced name.
# Do not assign a secondary channel until registration.
#
# Or if a name in an equivalence group has already been registered it will
# have a secondary channel. Each equivalence set may only have one pre-
# registered input name, which will replace the primary base name of the set,
# even if a different name has already been allocated in previous equivalences.
# This ensures that the wrong input name is not autovivified on that channel
# leaving the pre-registered input element as a zombie with no receivers.
# (The alternative autovivfied input element actually does act correctly on
# the pre-registered input on the secondary channel originally allocated).
#
# Else if simple equivalence add new name to current sub-group -
# Else start a new sub-group.
#
# During registration a check is made that all names in a sub-group have
# different connections.
#
############################################################

sub allocate_equivalences {
no warnings;
    my ($arg) = @_;
    my ($equiv, $group, $nn, $nm, $in, $ref, $ref1, $firstName, $name, $channel, $iecRef, @equivSet);
    my ($base, $firstBase, $primBase, $primCh, $secCh, $refEq, $iq, $xbwlh, $outName, $dupFlag, $ch);
    foreach $equiv (split /[, ]+/, $arg) {
	next unless ($equiv);			# ignore leading spaces or commas
	print "Equivalence '$equiv'\n" unless $opt_q;
	undef $channel;
	$name = '';
	@equivSet = ();
	$dupFlag = 0;
	$outName = $xbwlh = $ref = $firstBase = $base = undef;
	$primCh = $secCh = $ch = 0;
	########################################################################
	## The following are all part of a set of equivalence groups belonging to
	## one base IEC name. Scan once to see of this set extends a previous set
	## by checking in %EquivBase.
	########################################################################
	foreach $nn (split /=/, $equiv) {
	    if ($nn !~ /^([IQ])([XBWLH])\d+((-\d{1,3})?)$/) {
		print STDERR "Warning $named: '$nn' in '$equiv' is not an IEC name - will probably not work!\n";
	    } else {
		$iq = $1;
		if ($iq eq "Q") {
		    if ($outName) {
			if ($outName ne $nn) {
			    print STDERR "Warning $named: '$nn' in '$equiv' is 2nd output IEC name after $outName - will probably not work!\n";
			}
		    } else {
			$outName = $nn;
		    }
		}
		if (defined $xbwlh) {
		    if ($xbwlh ne $2) {
			print STDERR "Warning $named: '$nn' in '$equiv' is not the same IEC type - will probably not work!\n";
		    } else {
			$xbwlh = $2;
		    }
		}
		$in = defined $3 ? $3 : '';		# instance (may be null string)
		if (exists $EquivBase{$nn}) {
		    ($base, $primCh, $secCh, $ref) = @{$EquivBase{$nn}};
		} else {
		    $ch = $Channels{$nn};
		    print "%%% N nn = '$nn' base = '$base' primCh = '$primCh' secCh = '$secCh' ch = '$ch'\n" if $opt_T;
		    if (not $base or $iq eq "Q" or $ch) {
			if ($ch and $primCh) {
			    ########################################################################
			    ## Encountered a pre-registered input, whose channel has been allocated
			    ##  1) ignore 2nd and further pre-registered inputs per equivalence
			    ##  2) move the equivalence set from the previous base to this input name
			    ##  3) re-assign the new name and channel as base and primary channel in %EquivBase
			    ##  4) rebase %AltReceivers entries already registered to new primary
			    ##     channel before any more registrations take place
			    ##  5) rebase @Receivers entries already registered as secondary channel
			    ##     entries in %AltReceivers because channels have already been acked
			    ##  6) delete Autovivify entry for primary input already registered
			    ########################################################################
			    if ($dupFlag) {				# 1)
				print STDERR "Warning $named: cannot have more than 1 pre-registered input '$nn' on ch '$ch' in '$equiv' - ignore\n";
				next;
			    }
			    $dupFlag = 1;
			    $Equivalences{$nn} = $Equivalences{$base};	# 2) move equivalence set to new base
			    print "    nn = '$nn' delete \$Equivalences{$base}\n" if $opt_T;
			    delete $Equivalences{$base};		#    delete old base entry
			    foreach $name (sort keys %EquivBase) {	# 3)
				if ($EquivBase{$name}->[1] == $primCh) {	# find old primary channel
				    $EquivBase{$name}->[0] = $nn;		# re-assign base
				    $EquivBase{$name}->[1] = $ch;		# re-assign primary channel
				}
			    }
			    if (exists $AltReceivers{$primCh}) {	# 4)
				$AltReceivers{$ch} = $AltReceivers{$primCh};
				delete $AltReceivers{$primCh};		# TODO make sure $AltReceivers{$ch} is empty
				$AltRecrNames{$ch} = $AltRecrNames{$primCh};
				delete $AltRecrNames{$primCh};
			    }
			    if (@{$Receivers[$primCh]}) {		# 5)
				unshift @{$AltReceivers{$ch}}, [ $primCh, @{$Receivers[$primCh]} ]; 
				@{$Receivers[$primCh]} = ();
				unshift @{$AltRecrNames{$ch}}, [ @{$ReceiverNames[$primCh]} ]; 
				@{$ReceiverNames[$primCh]} = ();
			    }
			    print "remove Autovivify entry '$AutoVivify{$base}'\n" if $opt_T;
			    delete $AutoVivify{$base};			# 6)
			} else {
			    $ch = 0;			# no primary channel (or no channel)
			}
			$base = $nn;
			unshift @equivSet, [$nn, $in];	# output or first input name in equivalence set
		    } else {
			push @equivSet, [$nn, $in];
		    }
		}
	    }
	}
	########################################################################
	## Now a base IEC name has been determined distribute equivalences
	## in %Equivalences - also update %EquivBase.
	########################################################################
	print "base = $base\n" if $opt_T;
	foreach $ref (@equivSet) {
	    ($nn, $in) = @{$ref};
	    print "    nn = '$nn' in = '$in' primCh = '$primCh' ch = '$ch'\n" if $opt_T;
	    if ($ch) {
		$primCh = $secCh = $ch;
	    } else {
		foreach $refEq (@{$Equivalences{$base}}) {	# try all entries
		    if ($refEq) {
			$secCh = $refEq->[0];
			$ref1 = $refEq->[1];
			unless (exists $ref1->{$in}) {
			    $ref1->{$in} = $nn;			# extend equivalence group with different instances
			    allocate_channel($nn, $secCh);	# allocate same channel for next IEC instance
			    $EquivBase{$nn} = [$base, $primCh, 0, $refEq ];
			    print "ext \$secCh = $secCh \$nn = $nn\n" if $opt_T;
			    goto EquivStored;
			}
		    }
		}
		$secCh = allocate_channel($nn);		# allocate new channel for first IEC name in group
	    }
	    undef $ref1;
	    $ref1->{$in} = $nn;				# new equivalence with instance used in previous group
	    $primCh = $secCh unless $primCh;
	    print "new \$secCh = $secCh \$nn = $nn\n" if $opt_T;
	    $refEq = [ $secCh, $ref1 ];			# secondary channel for equivalence group and first IEC
	    if ($ch) {
		unshift @{$Equivalences{$base}}, $refEq;	# new equivalence group for pre-registered input
		$ch = 0;
	    } else {
		push @{$Equivalences{$base}}, $refEq;	# new equivalence group on a different channel
	    }
	    # [primaryBase, primaryChannel, secondaryChannel, \$Equivalences{}->[] ]
	    $EquivBase{$nn} = [ $base, $primCh, 0, $refEq ];
	  EquivStored: ;
	}
    }
use warnings;
} # allocate_equivalences

############################################################
#
#	Auxiliary routine for print_tables()
#
############################################################

sub print_tail {
    my ($start, $aref, $nref) = @_;
    my ($i, $rcon, $rName, @rCons);
    $i = 0;
    @rCons = ();
    foreach $rcon (@{$aref}[$start .. $#{$aref}]) {
	if ($rcon) {
	    unless (defined ($rName = $ClientNames{$rcon})) {
		$rName = "<undef>";
	    }
	    push @rCons, $rName, $nref->[$i];
	}
	$i++;
    }
    $rName = @rCons ? join "\t", @rCons : "<no receivers>";
    print "$rName\n";
} # print_tail

############################################################
#
#	Print tables of ClientNames and registered Senders and Receivers
#	Also print table of equivalences if any are defined
#
############################################################

sub print_tables {
    my ($con, $channel, $nm, $nn, $others, $i, $aref, $nref, $refEq, $ref1, $in);
    my ($base, $primCh, $secCh);
    print "$named: Table of ClientNames and registered Senders and Receivers\n";
    foreach $con (sort { $ClientNames{$a} cmp $ClientNames{$b} } keys %ClientNames) {
	print "$ClientNames{$con}\n";
    }
    if (%Equivalences and $opt_T) {
	print "\n\%Equivalences = {\n";
	foreach $base (sort keys %Equivalences) {
	    printf "%-6s => [\n", $base;
	    foreach $refEq (@{$Equivalences{$base}}) {
		$secCh = $refEq->[0];
		$ref1 = $refEq->[1];
		print "    [ $secCh, {";
		foreach $in (sort keys %$ref1) {
		    print " '$in' => $ref1->{$in},";
		}
		print " } ],\n";
	    }
	    print "],\n";
	}
	print "}\n";
    }
    if (%EquivBase) {
	print "\nEquivBase			Channels\n";
	print "name	base	primCh	secCh	ch\n";
	foreach $nn (sort keys %EquivBase) {
	    ($base, $primCh, $secCh) = @{$EquivBase{$nn}};
	    print "$nn	$base	$primCh	$secCh	$Channels{$nn}\n";
	}
    }
    print "\nch  Sender          name            value       Receiver[0] name[0]	Receiver[1] name[1]	...\n";
    for ($channel = 0; $channel <= $maxChannel; $channel++) {
	my ($chName, $name, $value) = ();
	$aref = $Receivers[$channel];
	if (defined ($con = $Sender[$channel]) or (defined $aref and @{$aref})) {
	    if (not defined $con or
		not defined ($chName = $ClientNames{$con})) {
		$chName = "<no sender>";
	    }
	    unless (defined ($name = $SenderName[$channel])) {
		$name = "";
	    }
	    unless (defined ($value = $SenderValue[$channel])) {
		$value = "";
	    }
	    printf "%-3d %-15s %-15s %-11s ", $channel, $chName, $name, $value;
	    $nref = $ReceiverNames[$channel];
	    print_tail 0, $aref, $nref;
	}
	if (exists $AltReceivers{$channel}) {
	    $i = 0;
	    foreach $aref (@{$AltReceivers{$channel}}) {
		printf "    %-43d ", $aref->[0];	# secondary channel
		$nref = $AltRecrNames{$channel}->[$i];
		print_tail 1, $aref, $nref;
		$i++;
	    }
	}
    }
} # print_tables

########################################################################
#
#	Push connection and messages
#
########################################################################

sub pushReceiverData {
    my ($rconn, $msg1) = @_;
    unless (defined $ReceiverData{$rconn}) {
	## this is the first message for this receiver
	push @{$ReceiverData{$rconn}}, $rconn;	# save real connection
    }
    push @{$ReceiverData{$rconn}}, $msg1;	# collect messages for sending
} # pushReceiverData

########################################################################
#
#	Execute Autovivify actions after a delay with ualarm($AutoDelay)
#
########################################################################

sub autoVivify {
    my ($autovivify, $key, @iCbox_params);
    if (%AutoVivify) {
	foreach $key (sort {
	    my ($ha, $na, $za, $hb, $nb, $zb);
	    $a =~ /([A-Z]+)(\d+)(.*)/; $ha = $sortOrder{$1}; $na = $2; $za = $3;
	    $ha = $1 if not defined $ha;
	    $b =~ /([A-Z]+)(\d+)(.*)/; $hb = $sortOrder{$1}; $nb = $2; $zb = $3;
	    $hb = $1 if not defined $hb;
	    ############################################################
	    ## sort order is instance then names in the following order
	    ## IX IB IW IL IH QX QB QW QL QH .. finally number
	    ##  0  1  2  3  4  5  6  7  8  9 .. correct for alpha cmp
	    ## print "$a $ha $na $za	$b $hb $nb $zb\n" if $opt_T;
	    ############################################################
	    $za cmp $zb || $ha cmp $hb || $na <=> $nb;
	} keys %AutoVivify) {				# same key could have been entered more than once
	    push @iCbox_params, $AutoVivify{$key};
	}
	$autovivify = join " ", @iCbox_params;
	$autovivify = "$opt_A -n$ioName $autovivify";
	print "AUTOVIVIFY: '$autovivify'\n" if $opt_t;
	fork_and_exec($autovivify);			# run iCbox or app specified in $opt_A
	%AutoVivify = ();
	$opt_a = undef if $opt_A =~ m/\s-\w*d\w*\b/;	# stop recursive exec of iCbox -d
    }							# other iCbox switches are ignored
    if ($AutoDebug) {
	print "AUTODEBUG: '$AutoDebug'\n" if $opt_t;
	fork_and_exec($AutoDebug);			# run iClive or app specified in $opt_G
	$AutoDebug = '';
    }
} # autoVivify

########################################################################
#
#	Receive message from client
#
#	connection $conn identifies the sender
#	message $msg has the following characteristics:
#	. undefined		ignore
#	. zero length		client has signalled shutdown
#	. comma separated list	break up into individual items $msg1
#	each item $msg1 has the following charecteristics:
#	. matches /^[NnSsRrZ]/	registration item
#	. matches /\d+:\d+/	split into $channel and $value, send
#				value to all receivers for the channel
#	. matches /^[XT]/	special actions
#	. else eror
#
########################################################################

sub rcvd_msg_from_client {
    my ($conn, $msg, $err) = @_;
    my ($sec, $usec);
    my ($con, $msg1, $aref, $direction, $name, $bits, $channel, $ch, $sender, $rconn, $ini, $nn);
    my ($base, $primCh, $secCh);
    if ($opt_m) {
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "S%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "S%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
    } elsif ($opt_t) {
	print "S: ";
    }
    if (defined $msg) {
	my $len = length $msg;
no warnings;
	$sender = $ClientNames{$conn};
	print "($len)$msg< '$sender'\n" if $opt_T;
use warnings;
	if ($len == 0) {
	    ############################################################
	    ## Client $conn has signalled shutdown - disconnect client
	    ## clear all entries for $conn in @Sender and @Receivers
	    ############################################################
	    disconnect($conn);
	}
	else {
	    foreach $msg1 (split /,/, $msg) {	# break up multiple messages
		if ($msg1 =~ /^(\d+):(.*)$/s) {	# data message, which may include new lines
		    ## $1 is channel : $2 is value
		    $channel = $1;
		    $con = $Sender[$channel];
		    warnD("Error $named: data '$msg1' during registration - app spec error") if $regFlag;
		    if (not defined $con or $con eq $conn) {	# TODO check this does not happen if equiv Q/I on same connection
			$SenderValue[$channel] = $2;	# latest value in case lost connection
			undef $rconn;
			############################################################
			## Central function of iCserver done at maximum speed.
			## Transmit message from a sender for a particular channel
			## to each receiver on that channel - most common case.
			############################################################
			if ($aref = $Receivers[$channel]) {
			    foreach $rconn (@{$aref}) {
				pushReceiverData($rconn, $msg1);	#  message to sender channel
			    }
			}
			############################################################
			## Transmit message to each receiver on equivalenced alternate
			## channels - this is very rare and only happens if several
			## inputs on the same instance of an app are equivalenced.
			## Only one statement is added to the execution of the common case.
			## %AltReceivers hashed by $channel ... receive connections on alternate channel
			## [ [ channel1, conn3, conn4 ... ],  [ channel2, conn5, conn6 ... ] ... ]
			## NOTE: $Receivers[$channel] may be empty and $AltReceivers[$channel]
			## may have an entry for the case where an output from a connection is
			## equivalenced with an input of the same connection.
			############################################################
			if (exists $AltReceivers{$channel}) {
			    foreach $aref (@{$AltReceivers{$channel}}) {
				$channel = $aref->[0];			# alternate channel
				foreach $rconn (@{$aref}[1 .. $#{$aref}]) {
				    pushReceiverData($rconn, "$channel:$2"); # message to alternate channel
				}
			    }
			}
			if ($opt_t and not $rconn) {
			    print "$ClientNames{$conn} $msg1 => dummy\n";	# not registered
			}
		    } else {
			print STDERR "conn = $conn, channel [0] = $Sender[$channel]\n";
			warnD("$ClientNames{$Sender[$channel]} $msg1 received on wrong connection $ClientNames{$conn}\n");
		    }
		}
		elsif ($msg1 =~ /^N(.+)/) {	# name part of registration
		    $name = $1;
		    $con = $Clients{$name};
		    if ($con) {
			############################################################
			## a client with the same name was previously registered
			############################################################
			unless ($opt_k) {
			    ############################################################
			    ## kill the new client and report error
			    ############################################################
			    warnD("trying to register client '$name' twice - aborted\n");
			    $conn->disconnect();	# new client was not registered yet
			    last;			# killed new client process
			}
			############################################################
			## -k option: unregister and disconnect previous instance
			## proceed with new registration
			############################################################
			warnD("kill previous client '$name' - restarted\n");
			disconnect($con, $name);	# kills old client process
			if ($channel = $Channels{"D$name"}) {
			    $iniString = "$channel:1";	# get S.T. from new client
			}
		    }
		    $Clients{$name} = $conn;		# client by this name exists now
		    $ClientNames{$conn} = $name;	# name may change for iClive connections
		    if ($name =~ /^-/) {
			my $i = 0;
			foreach $con (@{$Receivers[0]}) {
			    if ($con eq $conn) {
				$ReceiverNames[0][$i] = $name;	# name has changed in old warning registration
				goto ALREADY_REGISTRERD;
			    }
			    $i++;			# index of next entry to be spliced out
			}
			push @{$Receivers[0]}, $conn;	# new warning registration
			push @{$ReceiverNames[0]}, $name;
		    }
		    ALREADY_REGISTRERD:
		    $numberOfConnections++;
		    $regFlag = 1;			# registration string has started
		    print STDERR "$name: client no. $numberOfConnections registering now\n" unless $opt_q;
		    print_tables()if $opt_T;
		}
		elsif ($msg1 =~ /^([SR])([\\\/\w]+(-\d*)?)(\((\d+)\))?/) {
		    ############################################################
		    # regex is permissive allowing any number of instance digits
		    # clients have to stay in specification 1 to 3 digits
		    # if not, server still functions correctly
		    ############################################################
		    $direction  = $1;
		    $name = $2;
		    $bits = $5;
		    $channel = allocate_channel($name);
		    if (exists $EquivBase{$name}) {
			($base, $primCh, $secCh) = @{$EquivBase{$name}};
			if (not $secCh) {
			    $EquivBase{$name}->[2] = $channel;	# assign secondary channel now to flag registration
			} elsif ($secCh != $channel) {
			    warnD("$name: equivalenced channel $secCh not allocated channel $channel ???\n");
			    disconnect($conn);
			    $ackString = '';
			    last;
			}			# $secCh === $channel
		    } else {
			($base, $primCh, $secCh) = ($name, $channel, 0);
		    }
		    my $ack = $channel;		# used to build acknowledge string
		    if ($opt_T) {
			$secCh = 0 unless defined $secCh;
			print "*** register $direction $name base = $base primCh = $primCh secCh = $secCh channel = $channel ack = $ack\n";
		    }
		    if ($direction eq 'S') {
			if ($primCh != $channel) {
			    ############################################################
			    ## A client is trying to register a sender on a channel for
			    ## an alternate equivalence group
			    ############################################################
			    if ($EquivBase{$base}->[2] and 0) {	# secondary channel of base name already registered
				$ack = -$channel;
				warnD("$ClientNames{$conn}: trying to register S $name for alternative channel $primCh/$channel - aborted\n");
				disconnect($conn);
				$ackString = '';
				last;
			    }
			    ############################################################
			    ## Locate secondary group in %Equivalences and move it
			    ## to the primary position - adjust %EquivBase
			    ############################################################
			    my $i = 0;
			    foreach $aref (@{$Equivalences{$base}}) {
				if ($aref->[0] == $channel) {
				    goto Found;
				}
				$i++;
			    }
			    goto NotFound;
			  Found:
			    my @temp = splice @{$Equivalences{$base}}, $i, 1;
			    unshift @{$Equivalences{$base}}, @temp;
			    $Equivalences{$name} = $Equivalences{$base};	# move equivalence set to new base
			    print "S delete \$Equivalences{$base}\n" if $opt_T;
			    delete $Equivalences{$base};			# delete old base entry
			    foreach $nn (sort keys %EquivBase) {
				if ($EquivBase{$nn}->[1] == $primCh) {		# find old primary channel
				    $EquivBase{$nn}->[0] = $name;		# re-assign base
				    $EquivBase{$nn}->[1] = $channel;		# re-assign primary channel
				}
			    }
			  NotFound: ;
			}
			if ($Sender[$channel]) {
			    ############################################################
			    ## A client is trying to register a sender twice on the same
			    ## channel
			    ############################################################
			    $ack = -$channel;
			    warnD("$ClientNames{$conn}: trying to register S $name for channel $channel twice - aborted\n");
			    # has registered name and may already have registered some receivers
			    disconnect($conn);
			    $ackString = '';
			    last;
			}
			############################################################
			## Register a new Sender
			## sends all registered receivers on the channel a 0 value
			## (this also works for iClive - NOP)
			############################################################
			$Sender[$channel] = $conn;
			$SenderName[$channel] = $name;
			$SenderValue[$channel] = 0;		# default initial value
			undef $rconn;
			foreach $rconn (@{$Receivers[$channel]}) {
			    pushReceiverData($rconn, "$channel:0");	# reset receiver
			}
			if (exists $AltReceivers{$channel}) {
			    foreach $aref (@{$AltReceivers{$channel}}) {
				$ch = $aref->[0];			# alternate channel
				foreach $rconn (@{$aref}[1 .. $#{$aref}]) {
				    pushReceiverData($rconn, "$ch:0");	# reset message to alternate channel
				}
			    }
			}
			unless ($rconn) {
			    if ($opt_a and
				$name =~ /^Q[XBWL]\d+/) {	# not even first for senders
				my $iCbox_param = $bits ? "$name,$bits" : $name;
				$AutoVivify{$name} = $iCbox_param;
				$ioName = "$ClientNames{$conn}-IO";
				print "Autovivify sender '$iCbox_param'\n" if $opt_T;
			    }
			    if ($opt_g and			# C_channel only as trigger
				$name =~ /^C([\\\/\w]+)(-(\d*))?$/ and
				not $AutoDebug) {		# only 1 per application
				if (defined $3) {
				    $AutoDebug = "$opt_G -i$3 $1.ic";
				} else {
				    $AutoDebug = "$opt_G $1.ic";
				}
				print "AutoDebug: '$AutoDebug' for sender '$name'\n" if $opt_T;
			    }
			}
no warnings;
			print "$ClientNames{$conn}: $direction $name	ack = $ack\n" if $opt_t;
use warnings;
		    } elsif ($direction eq 'R') {
			############################################################
			## ignore duplicate Receiver entries for this $conn
			## TODO remove - this is no longer likely to happen with alternate groups
			############################################################
			if ($primCh == $channel) {
			    foreach $rconn (@{$Receivers[$channel]}) {
				if ($rconn eq $conn) {
				    # happens if receiver equivalences in the same client
				    $ack = -$channel;		# not an error in iCbox
				    warnD("Register R $name for channel $channel at '$ClientNames{$conn}' twice\n");
				}
			    }
			} elsif (exists $AltReceivers{$primCh}) {
			    foreach $aref (@{$AltReceivers{$channel}}) {
				$ch = $aref->[0];		# alternate channel
				foreach $rconn (@{$aref}[1 .. $#{$aref}]) {
				    if ($rconn eq $conn) {
					# happens if receiver equivalences in the same client
					$ack = -$ch;		# not an error in iCbox
					warnD("Register R $name for channel $primCh/$ch at '$ClientNames{$conn}' twice\n");
				    }
				}
			    }
			}
			if ($ack > 0) {
			    if ($primCh == $channel) {
				push @{$Receivers[$channel]}, $conn;	# simple R registration
				push @{$ReceiverNames[$channel]}, $name;
			    } else {
				my $i = 0;
				my $nref;
				if (exists $AltReceivers{$primCh}) {
				    foreach $aref (@{$AltReceivers{$primCh}}) {
					$secCh = $aref->[0];
					if ($secCh == $channel) {
					    push @{$aref}, $conn;	# extend alternate R registration group
					    $nref = $AltRecrNames{$primCh}->[$i];
					    push @{$nref}, $name;	# extend alternate R names
					    goto AltStored;
					}
					$i++;
				    }
				}
				$aref = [ $channel, $conn ];		# new alternate R registration
				push @{$AltReceivers{$primCh}}, $aref;	# in group on a different channel
				$aref = [ $name ];			# new alternate R name
				push @{$AltRecrNames{$primCh}}, $aref;
			      AltStored: ;
			    }
			    if ($Sender[$primCh]) {		# is sender registered on primary channel ?
				$ini = $SenderValue[$primCh];	# yes - current value
				if ($ini) {
				    ############################################################
				    ## sender is registered and has either initial value 0 or other
				    ## current value - send new receiver value different to 0
				    ## if sender is already registered
				    ############################################################
				    $ini = "$channel:$ini";	# message to all secondary channels
				    if ($iniString) {
					$iniString = join ',', $iniString, $ini;
				    } else {
					$iniString = $ini;
				    }
				}
			    }
			    elsif ($opt_a and			# no, sender not registered on primary channel
				$base =~ /^I[XBWL]\d+/) {	# from $EquivBase{$name} or own $name
				my $iCbox_param = $bits ? "$base,$bits" : $base;
				$AutoVivify{$base} = $iCbox_param;
				$ioName = "$ClientNames{$conn}-IO";
				print "Autovivify receiver '$iCbox_param'\n" if $opt_T;
			    }
			}
no warnings;
			print "$ClientNames{$conn}: $direction $name	ack = $ack	ini = '$ini'\n" if $opt_t;
use warnings;
		    }
		    if ($ackString ne '') {
			$ackString = join ',', $ackString, $ack;
		    } else {
			$ackString = $ack;
		    }
		}
		elsif ($msg1 eq 'Z') {
		    if ($ackString eq '') {
			$ackString = '-0';	# send a null acknowledgment
		    }
		    $regFlag = 0;		# registration string has terminated
		}
		elsif ($msg1 =~ /^n(.+)/) {
		    $name = $1;
		    $con = $Clients{$name};
		    unless ($con) {
			############################################################
			## no client with this name was previously registered
			############################################################
			warnD("$name: no client with n $name was previously registered\n");
		    }
		    print "$name: client no. $numberOfConnections unregistering now\n" if $opt_t;
		    delete $ClientNames{$conn};
		    delete $Clients{$name};
		    $numberOfConnections--;
		}
		elsif ($msg1 =~ /^([sr])(.+)/) {
		    $direction  = $1;
		    $name = $2;
		    unless (defined ($channel = $Channels{$name})) {
			warnD("$ClientNames{$conn}: trying to unregister $name not previously registered - aborted\n");
		    }
		    if ($direction eq 's') {
			unless ($Sender[$channel]) {
			    warnD("$ClientNames{$conn}: trying to unregister s $name not registered as sender - aborted\n");
			}
			############################################################
			## Unregister a previously registered Sender
			############################################################
			if (defined ($con = $Sender[$channel]) and $con eq $conn) {
			    $Sender[$channel] = undef;	# no need to splice out only array entry
			    print "$sender: s $SenderName[$channel]	$channel undef\n" if $opt_t;
			} else {
			    warnD("$ClientNames{$conn}: trying to unregister s $name not registered as sender - aborted\n");
			}
			## leave name
			$SenderValue[$channel] = 0;	# reset initial value
		    } elsif ($direction eq 'r') {
			############################################################
			## check that there are no Receiver entries with this $conn
			############################################################
			my $i = 0;
			foreach $rconn (@{$Receivers[$channel]}) {
			    if ($rconn eq $conn) {
				print "$sender: R $ReceiverNames[$channel][$i]	$channel spliced out\n" if $opt_t;
				splice @{$Receivers[$channel]}, $i, 1;
				splice @{$ReceiverNames[$channel]}, $i, 1;
				############################################################
				## checked that there are no multiple Receiver entries
				## with the same $conn when registering
				## only used for iClive which only registers one receiver
				## but use full algorithm just in case of future clients
				############################################################
				last;
			    } else {
				$i++;		# index of next entry to be spliced out
			    }
			}
		    }
		}
		elsif ($msg1 =~ /^E(.*)$/) {	# Equivalance message from an app
		    print "Equivalences '$1' from app\n" if $opt_T;
		    allocate_equivalences($1);
		    $AutoDelay = 2_000_000;	# 2 seconds for autovivify delay with equivalences
		}
		elsif ($msg1 =~ /^X(.*)$/) {	# termination by named parent
		    $name = $1 ? "'$1'" : "parent";
		    shutdown_server("Stop from $name");
		    exit 0;			# shutdown_server() never returns - just in case
		}
		elsif ($msg1 eq 'T') {
		    print_tables();
		}
		elsif ($msg1 ne '') {		# ignore empty message before leading comma ",SIX123,..."
		    warn "$named: strange msg1 '$msg1' in received msg '$msg'\n";
		}
	    }
	    $sender = $ClientNames{$conn};
	    if ($ackString ne '') {
		print "ACK: $ackString => $sender\n" if $opt_t;
		$conn->send_now($ackString);	# registration acknowledgment
		$ackString = '';
		unless ($regFlag) {		# defer ini and autoVivify until registration terminated
		    if ($iniString) {
			## must be independent xmission, because different rcv call in client
			print "INI: $iniString => $sender\n" if $opt_t;
			$conn->send_now($iniString);# registration initialisation
			$iniString = '';
		    }
		    if (%AutoVivify or $AutoDebug) {
			ualarm($AutoDelay);		# defer the action to allow more registrations
		    }
		}
	    }
	}
	############################################################
	## Scan destination connections for which data was collected
	############################################################
	foreach my $c (keys %ReceiverData) {	# only the unique string key for connection
	    $aref = $ReceiverData{$c};
	    $rconn  = shift @$aref;		# the real connection object
	    if (defined $rconn) {
		$msg1 = join ',', @$aref;	# one or more channel:value pairs
		print "$sender $msg1 => $ClientNames{$c}\n" if $opt_t or $opt_I or $opt_O;
		$rconn->send_now("$msg1");	# send channel:value pairs to destination
	    } else {
		warnD("no message to send to connection '$c' ???\n");
	    }
	}
	%ReceiverData = ();		# clear all keys and entries for next receive
    }
    if ($opt_m) {
	$t0 = [gettimeofday];
    }
} # rcvd_msg_from_client
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCserver - the central server for iC clients

=head1 SYNOPSIS

 iCserver [-adgrktIOmTqzh][ -s <host>][ -p <port>][ -f <file>][ -A <cmd>]
          [ -G <dbg>][ [-e]<list of equivalences>][ <list of client calls>]
          [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -s host address of server - clients must specify the same address
            unless (default '0.0.0.0' which accepts any client host)
    -p port service port of server for all clients  (default '8778')
    -e <equivalences> eg: IX0=IX0-1     (can be used more than once)
            or a comma separated list eg: IX0=IX0-1,QX0=QX0-1,IB1=IB1-1
    -f file read options, equivalences and client calls from this file
    -q      quiet - do not report clients connecting and disconnecting
    -a      autovivify I/O clients 'iCbox' for missing I/O's (any number
            of iCbox's can be autovivified with -a as apps register)
    -d      autovivify I/O client 'iCbox -d' for missing I/O's, which is
            useful to monitor real I/O (only one 'iCbox -d' can be auto-
            vivified to avoid recursive calls for missing senders to the
            display only 'iCbox -d')
    -A cmd  use <cmd> to autovivify I/O clients (eg -A 'iCbox -Q2 -C19')
    -g      autovivify debugger 'iClive' when an iC app registers
    -G dbg  autovivify debugger <dbg>
    -r      reset registered receivers when sender disconnects - ie reset
            outputs of an app when it shuts down (default no change)
    -k      kill previous client when a new client with the same name
            registers (default: do not accept the new client)
    -z      block keyboard input
        DEBUG options
    -t      trace messages for debugging
    -I      trace rcv messages in Msg.pm
    -O      trace send messages in Msg.pm
    -m      display elapsed time in seconds and microseconds
    -T      extra static debug messages
    -h      help, ouput this Usage text only
        OLD STYLE CALLS
    <equivalences> - deprecated - use -e <equivalences> instead
            eg: IX8=IX8-0=IX8-1,IX9=IX9-0=IX9-1
    <client calls> - deprecated - use -R <app ...> instead
            eg: 'iCbox X0-X3 X10' sort
            if a client call has arguments, the call must be quoted
        AUXILIARY app   - start a Bernstein chain
    -R <app ...> run one app followed by -z and its arguments as a
                 separate process; -R ... must be last arguments,
                 which do not need to be quoted.
             eg: -R iCbox X0-X3 X10 -R sort
        KEYBOARD inputs
        T   output table of all registered client I/Os and channels
        q   from keyboard: stops iCserver and all apps

=head1 DESCRIPTION

iCserver acts as a router for a number of iC clients in a network, who
send data to each other. Each client connects via TCP/IP to iCserver on
a specified port (8778 default at the moment).  Only one iCserver on one
port may run in a network.  It is possible to run several iCservers on
different ports.  Clients can connect either via 'localhost' (default
for iC clients) when they run on the same processor as iCserver or via
the host address of the processor iCserver is running on.  On connection
each client registers itself with iCserver.

Clients for iCserver are iC control applications, I/O clients such
as iCbox or similar real I/O clients and debugging programs such as
iClive. These clients either send or receive data values from and
to named I/O locations or debugging information.  As far as iCserver
is concerned I/O locations could have any name, but the iC language
calls for I/O names or addresses according to the IEC-1131 standard.
Data values can be 8 bit bytes (eg: IB1 QB9), 16 bit words (IW2 QW10),
32 bit long words (IL4 QL12) or 64 bit huge words (IH8 QH16), although
thes have not been implemented in any client so far.  Bit values
like IX0.0 IX0.1 QX8.2 QX8.3 are always transmitted as bytes - in
this case via IX0 and QX8, which are the names used for registration.
Whenever any bit in the byte changes, the whole byte is transmitted.
Each client registers the I/O names it requires on connection
to iCserver. Each unique name is stored in a Hash in iCserver,
whose value is a channel number, which is used for all actual data
transfers. The Hash is only required for registration. Each channel
allows the naming of one Sender for data on the channel (or I/O name)
and one or more Receivers for the data. A detailed description follows
in the Specification below.

Additional functionality in iCserver.

 a) equivalence - or interconnection of different I/O addresses in
    iCserver. This option puts two or more entries in the Hash and
    assigns them a common channel number. Send or receive entries
    associated with the channel are undefined at this stage. Then
    when registration of one of the equivalence names occurs,
    the common channel number is used. With this option different
    IEC-1131 addresses can be assigned to the same channel, thereby
    making them equivalent or interconnecting them.

    This functionality is required when the output of one iC control
    application is to be the input for another iC control application
    (often a different instance of the same application).  Several
    equivalences may be specified. The order of the equivalence is not
    relevant (it is not an assignment). For correct autovivification
    outputs should be named first though.

    Example 1:
        iCserver -e QX7-0=IX7-1,QX7-1=IX7-0

    This connects QX7 of instance 0 with IX7 of instance 1 via a common
    channel and QX7 of instance 1 with IX7 of instance 0 via another
    channel. Equivalencing an output and an input of the same instance
    is possible but rather useless and much slower than using internal
    variables (it may be useful for testing).

    Equivalencing is also required if one external I/O source must be
    connected to the input of more than one iC control application.

    Example 2:
        iCserver -e IX8=IX8-0=IX8-1,IX9=IX9-0=IX9-1

    This sets up common inputs IX8 and IX9 to two instances of the same
    controller. Naming the other inputs with the same base IEC-1131
    address is not necessary but highly advisable for transparency in
    the documentation. The first address is used for autovivifying an
    iCbox if it does not exist already. Autovivification does not take
    place for a channel, until a receiver has been registered for that
    channel and all other registrations have taken place.

    Equivalencing two or more output addresses (Q...) will lead to
    an error, if both output addresses register as senders in an iC
    control application - this would lead to two or more senders on the
    same channel. When the second or later output sender registers,
    the error will be reported. A similar error will be reported
    if a second external input device in an equivalence chain is
    registered as a second sender. This would happen if both IX8 and
    IX8-0 were started as iCboxes after the equivalence statement in
    Example 2 above. In rare cases two outputs may be legitametely
    equivalenced if an iC application uses a certain output name and
    a real output with a different name must be used to accept that
    output. This practice is highly deprecated, because transparency
    in the documentation is lost.

    Formally equivalences consist of two or more IEC base identifiers
    followed by an optional 1 to 3 digit instance specifier separated
    by an equal sign '='. Several equivalences may be specified in a
    comma ',' separated list or several equivalence parameters may be
    used.

    It is not allowed to equivalence IEC identifiers of different
    types, since the consequences are not what is expected.

    Equivalances can also be defined later by an iC app for input IEC
    variables in that app before the variables are registered.

 b) Autovivification
    -a option - automatic startup of one or more iCbox
    When a control application registers its I/O's, 'iCserver -a' starts up
    a matching 'iCbox' for all complementary I/O's, which have not already
    been registered. With the -a option, clients must be started in a
    particular order:

    i)  iCserver -a   # always first anyway.

    ii) any manually started I/O's with real I/O or specific ranges etc
        or because of equivalances (optional).

    iii)iC control application(s), which causes iCserver to autovivify
        any missing I/O's as iCboxes with appropriate ranges for each app.

    Alternatively starting an iC
    -d option - automatic startup of one iCbox -d
    When a control application registers its I/O's, 'iCserver -d' starts up
    a matching 'iCbox -d' for all complementary I/O's for monitoring.
    Outputs are the same but inputs will only display their value and
    cannot be changed. With the -d option, clients must be started in a
    different order:

    i)  iCserver -d   # always first anyway.

    ii) one control application, which causes iCserver to autovivify all
        I/O's (which are all missing their complementary senders and
        receivers at this stage) as an 'iCbox -d' with appropriate ranges.

    iii)any manually started I/O's with real I/O or virtual I/O. Care must
        be taken to ensure that all missing inputs for the app are present,
        since no further missing I/O's are autovivified. Missing outputs
        are optional.

    -A <cmd> - automatic startup of one or more <cmd>
               usually <cmd> is iCbox with extra options eg -A 'iCbox -C19'
    Startup and calling order is the same as for the -a option unless the
    -d option is also used - in which case the -d option applies.

    Note: with the -a -d and -A option care is taken to only autovivify
    the first member of an equivalence list, which is the sender of that
    list if it is an output or will become the sender if it is an input.

 c) -g       - automatically start iClive xxx.ic when SCxxx registers.
    -G <dbg> - automatically start <dbg> xxx.ic when SCxxx registers.
               usually <dbg> is iClive with options eg -G 'iClive -t'

 d) -r option - reset registered receivers when sender disconnects
    ie reset outputs of an app when it shuts down (default no change)

 e) -k option - if a sender registers with the same name as one already
    registered, kill the previously registerd sender, rather than
    reporting an error. This allows a recompiled version of an iC
    application to be started, while an old version is still running -
    the old one will quitly be killed. This should not be done in a
    production system.

    Note: when a control application exits (disconnects from iCserver)
    the I/O's are not disconnected. They can be re-used by a restarted
    similar control application. If the restarted control application
    uses different I/O's a new iCbox is autovivified for any extra
    I/Os. This situation could be confusing and it would be better to
    start again by stopping iCserver with ctrl-C. When iCserver exits,
    all connected clients are disconnected and closed.

 f) -R <aux_app>[ <aux_app_argument> ...] # must be last arguments
    Start a Bernstein chain of iC application which are each initialised
    and then started in parallel - in this case with iCserver.
    Example 3:
        iCserver -R iCbox X0-X3 X10 -R sort

 g) client calls (deprecated) - a list of calls with their parameters
    allow iCserver to start a number of clients as separate processes
    like a shell.  These are usually all the control application(s)
    and I/O client(s) to make up a complete control system. By
    providing this functionality in iCserver, all the information for
    starting a control system is grouped in one place.

    Client calls consist of a program path optionally followed by a
    space separated list of parameters.  Calls with parameters must
    be quoted on the command line and the optional INI file to make
    them a single parameter for iCserver.

    Example 4:
        iCserver 'iCbox -n sorter-IO IX0 QX0 QX1' sorter

    This starts iCserver and two clients - iCbox and the control
    application 'sorter'. Since correct initialisation of the client
    processes started in parallel is not well controlled leading to
    bad Autivivication, Bernstein chaining with the -R option is a
    better choice.

 h) -f <option_file> - execute a file with iCserver options at startup.
    For very large equivalence tables a file defining equivalences and
    possibly other iCserver switches and options can be used.

        iCserver -f <option_file>

    Format of the option_file:
        <equivalence_line>
        <equivalence_line>
        ...
        <other_options>

    Example same as Example 1, 2 and 4 above with extra options:
      QX7-0 = IX7-1 QX7-1 = IX7-0 # equivalences joining 2 instances
      IX8 = IX8-0 = IX8-1         # input equivalences
      IX9 = IX9-0 = IX9-1
      'iCbox -n sorter-IO IX0 QX0 QX1' # quoted client call
      sorter                      # plain client call
      -ak                         # extra switches for iCserver

    Individual equivalences and client calls must be written without
    spaces in the command line unless client calls are quoted.
    In the INI file white spaces before and after the = may be
    used in equivalences

    Comments in the INI file are started with #

=head1 SPECIFICATION

 1) On connection to iCserver each client register by supplying the
    following registration information:

    a)  The name of the client device.

        <name_op><client_name>[-<instance>]

        <name_op>
        N signifies, that the named client registers with iCserver.
        n signifies, that the named client unregisters from iCserver.

        <client_name>
        The client_name must be unique. For iC applications the control
        program register with the name it is called with. The iClive
        debug program registers with the name of the iC application
        it is connected to preceded by a '-'. The leading - is used
        by iClive to detect live registrations, which may register
        and unregister with different names, to monitor different
        iC applications.

        -<instance>
        An optional instance number allows the registrations of several
        instances of the same control application. Its use is explained
        in detail in section 7.

    b)  Registration codes: the type of data the client is sending or
        receiving and the physical address in IEC-1131 format:

        <send_receive_op><address_code>[-<instance>][(<bit_map>)]

        <send_receive_op>
        S signifies, that the client sends data to iCserver.
        R signifies, that the client receives data from iCserver.
        s sender unregisters from iCserver (used by iClive only)
        r receiver unregisters from iCserver (used by iClive only)

        <address_code>

        The <address_code> is made up either of an IEC-1131 base
        name used in iC programs to identify (address) a particular
        input or output or by a special address for communicating
        with debugging and monitoring clients consisting of an
        <address_code> starting with C,D or M are used. These are
        followed by the name of the debugging or monitoring client.

        -<instance>
        An optional instance number for a particulat input or output.

        (<bit_map>)
        An optional bit map, which defines the bits implemented for
        a digital input or output. The default value is 255, which
        implements bits 0 to 7.

    c)  Termination code for the registration string consisting of
        the single letter 'Z'. This allows the registration string
        to be longer than the TCP/IP transmission size of 1400 bytes
        (also maximum buffer size) - it will be sent in more than one
        transmission if it is too long.

    In summary: the registration string consists of a comma seperated
    list beginning with 'Nname' followed by one or more individual
    sender and receiver registration codes starting with 'S' or 'R'
    and terminated with a single 'Z'. The whole is sent in one or
    more transmissions. iCserver acknowledges each transmission by
    sending a comma separated list of channel numbers used for each
    sender or receiver for each partial registration string. These
    acknowledge strings are always shorter than the registration
    strings - hence there is no danger of buffer overflow.

        IEC-1131 base names are as follows:

            <io_op><size_op><address>

            <io_op>
            I data is input to an iC control client.
            Q data is output from an iC control client.

                        - the following are for debugging clients only
            C debug data is output from an iC control client to iClive
            D debug data is input to an iC control client from iClive
            M signifies a monitor device (none implemented so far).
                        - more details for C, D and M in section 6.

            <size_op>
            X signifies 8 bits of single bit data.
                    bit addresses are not used in the registration or
                    transmission of X senders and receivers. 8 bits are
                    always transmitted as 1 byte and the clients insert
                    or extract modified bits as necessary.
            B signifies 8 bits or 1 byte of numerical data.
            W signifies 16 bits or 2 bytes of numerical data.
            L signifies 32 bits or 4 bytes of numerical data.
            H signifies 64 bits (not implemented on 32 bit processors)

            <address>

            This number is the numerical IEC-1131 address. Unlike
            previous implementations, each data type has its own
            address space, which is independent of the others. Also
            the numbering of W (16 bit) addresses is continuous 0, 1,
            2, 3 and not 0, 2, 4, 6 as in previous implemetations. The
            same applies to L (32 bit) addresses.

        NOTE: the syntax of correct IEC-1131 base names is only checked
        by iCserver for equivalence declarations. All other IEC_1131
        base names are received from clients where they should have
        been checked.

        Examples:
        SIX0    8 single bits IX0.0 to IX0.7 sent from an external source
        RIX0    8 single bits IX0.0 to IX0.7 received by an iC controller
        SQX9(7) 3 single bits IX9.0 to IX9.2 sent from an iC controller
        RQX9(7) 3 single bits IX9.0 to IX9.2 received by an external sink

        SIB10   single byte IB10 sent from an external source
        RIB10   single byte IB10 received by an iC controller
        SQB15   single byte QB15 sent from an iC controller
        RQB15   single byte QB15 received by an external sink

        SIW10   single word IW10 sent from an external source
        RIW10   single word IW10 received by an iC controller
        SQW15   single word QW15 sent from an iC controller
        RQW15   single word QW15 received by an external sink

        SIL10   single long IL10 sent from an external source
        RIL10   single long IL10 received by an iC controller
        SQL15   single long QL15 sent from an iC controller
        RQL15   single long QL15 received by an external sink

 2) As indicated under <address> above, each data type QX, QB, QW, QL
    and QH as well as IX, IB, IW, IL and IH define their own
    address space in iC control applications. This differs from the
    implementations 1.1 to 1.105, which defined a joint address space
    for inputs and a separate but joint address space for outputs where
    16 bit words had to have an even byte address and 32 bit long
    addresses had to be divisble by four. Also the control software
    had to check that different types of data did not overlap and that
    a maxinum address was not exceeded.  This will not be necessary
    with this new specification. Using the overlap for obscure control
    purposes was never implemented fully (sending worked, receiving
    did not). Its use is deemed to be too obscure to be maintained,
    and the new specification should be much easier to handle.

    In the new specification <address> simply indexes sparse arrays
    of bytes, words, longs (or 64 bit huge integers on a 64 bit
    machine). They are allocated by name to a channel number in
    iCserver and only the channel numbers are used by the clients after
    registration.

    Nevertheless it may be advisable to maintain the currently
    implemented checks on maximum I/O address and checks on word
    and long boundaries as well as overlaps between bit, byte, word
    and long fields as a compile option. This may be useful for real
    I/O implementations in which the input and output fields are two
    contiguous byte fields. Since this code is currently in place,
    it is easier to change it to an option, than to discard it now
    and to re-implement it later.

 3) One client device has one two way TCP/IP connection to iCserver,
    but it can register for any number of send and/or receive addresses.
    For example the simple iCbox registers as X0 by default, supplying
    8 bits of input data and sinking 8 bits of output data. It will
    register itself as SIX0,RQX0. SIX0 is the source of the signals
    IX0.0 to IX0.7 and RQX0 is the sink of QX0.0 to QX0.7.  An iC
    control application handling those two signal groups will register
    itself as RIX0,SQX0.  RIX0 for receiving IX0.0 to IX0.7 and SQX0
    for sending QX0.0 to QX0.7.

    This scheme makes I/O devices and controllers identical as far as
    iCserver data handling is concerned. and opens the possibility,
    that one iC control application can communicate data to another via
    the iCserver network. This is a definite requirement when multiple
    iC applications are involved in an overall project. A more obscure
    use would be sending data from an external input directly to an
    external output. More realistic would be using an iCbox output to
    monitor the data going to another client doing real output.

    A shorter Registration code was used previously but registration
    happens only once at startup and so a more comprehensive
    registration code is preferable. The new specification allows
    fast interpretation - S and R are separated first. It is also
    readable for debugging.

 4) To allow monitoring and to allow several iC control applications to
    react to input from a single source, iCserver supports the receive
    registration of the same address from several clients. iCserver
    will then send the same data to each of those clients, when it
    is received from its source by iCserver for distribution.

 5) On the other hand, only one client may register as the sender for
    a particular address. If iCserver did not catch this as an error,
    serious malfunction would occur, if several clients were to
    send data, which would then be overwritten inconsistently at the
    destination sinks.

 6) Communication with debugging devices (iClive) is regulated with two
    alternative <io_op>s; 'C' for controller and 'D' for debugger.
    There can be several instances of iClive running together, but
    only one for each control application. They are addressed by the
    program name, not an IEC-1131 address. A control application named
    'sorter' would connect with iClive as follows:

        iC program                 iClive
         Nsorter,                 N-sorter,
         SCsorter,     ====>      RCsorter,
         RDsorter     <====       SDsorter

    Each unit registers for both send and receive, since the data
    handling for send and receive are handled in separate sections of
    iCserver and a live display needs both. This means that no special
    treatment of live display registration and data parsing is needed.

    As an alternative to a live display, a plot program (iCplot) could
    be connected. Since both could not be connected simultaneously
    if they were controlled by the 'D' identification an alternative
    for such a client programs is 'M' for monitor. Since live display
    requires a lot of support from a running application, which should
    not have to be duplicated for a monitor, yet other alternatives
    may be required. One is to integrate the 'plot' function into
    iClive. For specification purposes, all the alternatives are
    covered.

 7) Allow every application to be started by specifying an optional
    <instance> parameter (see 1), which is appended to all registration
    codes or addresses. The same instance number is also appended
    to the addresses of I/O clients communicating with a particular
    controller instance. Such a set of a controller and I/O clients
    with a common instance number are a set, which communicate with
    each other. The instance parameter is passed to each client with
    the calling parameter -i<instance>.

    Example without instance number:
        sorter     # (using IX0, QX0, QX1) will register with:
            Nsorter,SCsorter,RDsorter,RIX0,SQX0,SQX1,Z
        iCbox      IX0 QX0 QX1           # will register with:
            NIX0,SIX0,RQX0,RQX1,Z
        iClive     sorter                # will register with:
            N-sorter,RCsorter,SDsorter,Z

    Example of a first instance:
        sorter -i0 # (using IX0, QX0, QX1) will register with:
            Nsorter-0,SCsorter-0,RDsorter-0,RIX0-0,SQX0-0,SQX1-0,Z
        iCbox  -i0 IX0 QX0 QX1           # will register with:
            NIX0-0,SIX0-0,RQX0-0,RQX1-0,Z
        iClive -i0 sorter                # will register with:
            N-sorter-0,RCsorter-0,SDsorter-0,Z

    Example of a second instance:
        sorter -i1 # (using IX0, QX0, QX1) will register with:
            Nsorter-1,SCsorter-1,RDsorter-1,RIX0-1,SQX0-1,SQX1-1,Z
        iCbox  -i1 IX0 QX0 QX1           # will register with:
            NIX0-1,SIX0-1,RQX0-1,RQX1-1,Z
        iClive -i1 sorter                # will register with:
            N-sorter-1,RCsorter-1,SDsorter-1,Z

    Although mixed registrations, in which clients of the same name
    are used with and without instance numbers as shown above will work
    correctly, this will cause confusion in the project documentation
    and iCserver will issue a warning if it occurs.

 8) Registration of clients from the view of iCserver

    a)  A client connects to iCserver via TCP/IP, which accepts and
        issues a $conn object.

    b)  The client sends a Message with all its registration codes in
        a comma sperated list to iCserver (see specification).

    c)  In iCserver the registration code <address_code>[-<instance]
        is used as a key in a hash table, which associates a unique
        channel number with the key.  The key identifies either an
        IEC-1131 I/O or a debug address. It is the identification or
        name of a communication send/receive pair and is unique. The
        associated channel number is an index in an array which
        holds run-time details for the communication pair or
        channel. <send_receive_op> selects the correct entries in
        that array.

        iCserver maps each code against the Hash %clientNames,
        which returns the correct channel number if it has already
        been allocated. All further data transfers in iCserver and
        the clients use the channel number to identify a particular
        send/recive pair.

    d)  iCserver acknowledges registration of a client by sending a
        comma separated list of channel numbers in the same order as
        the registration codes. If a particular registration code
        cannot be registered correctly, the comma separated list
        contains a negative error number for that entry.

 9) Registration from the view of clients

    a)  When a client starts it tries to connect to iCserver. If it
        fails it will start 'iCserver -a' and try to connect again a
        number of times, which should succeed. Once connected it sends
        its registration string.

    b)  iCserver responds by sending the acknowledge string of channel
        numbers. When the client receives this positive acknowledgement,
        which will be the first message received, it pairs off the
        registration codes and the channel numbers received in the
        acknowledgement. The details depend on the client application.

        For the first example in section 7, the following tables will
        be set up in the different clients:

         client  direction  code    channel
        sorter
                     S     Csorter     1
                     R     Dsorter     2
                     R     IX0         3
                     S     QX0         4
                     S     QX1         5
        iCbox
                     S     IX0         3
                     R     QX0         4
                     R     QX1         5
        iClive
                     R     Csorter     1
                     S     Dsorter     2

 10)When registration is complete, iCserver can determine, that each
    channel has one and only one sender and at least one receiver. If a
    project is run only as a simulation, a missing sender or receiver
    may not matter and only a warning is issued. If a project drives
    real I/Os an error must be reported by iCserver. The option flag
    -w turns such error messages into warning messages only.

 11)Formats of data messages between iCserver and clients follow a
    uniform pattern:

    <channel_number>:<data_value> in a comma separated list for a number
    of simultaneous values on different channels to the same client.

    <channel_number> is always a simple decimal string identifying the
    unique channel allocated by iCserver.

    <data_value> is a decimal value with a - sign for negative values
    in case of the numeric types X, B, W, L (or H). iClive uses a more
    complex data format consisting of a semi-colon separated list of
    data pairs (see specification of iClive).

    Examples:
        4:1,5:2         # set QX0.0 and QX1.1 in the example above
        2:4;2 128;5 48  # a type 4 live data telegram for iClive

 12)Unregistering a client.

    A client is able to unregister itself, without disrupting a
    running process, particularly if it is only a secondary receiver.
    This will happen when a client closes a TCP/IP connection. When a
    client is disconnected, keep the Hash entries for the channel
    numbers in case it connects again.

For measuring reaction times the Module Time::HiRes is used.
This activates the -m option and flash display of short events.
Make sure you have installed Time::HiRes (provided in this distribution)

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

Error and warning messages for transmissions to missing clients have
not been implemented yet (-w option).

Mixed instance warning not yet implemented.

The Specification supplements the Description of iCserver and may be
useful in understanding its workings.

=head1 SEE ALSO

L<immcc(1)>, L<iCbox(1)>, L<iClive(1)>

=head1 COPYRIGHT

Copyright (C) 2000-2017  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
