#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2014  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCtherm
#	output temperature in 1/10th degrees Centigrade or Fahrenheit
#	using one or more DS18B20 1-Wire Digital Thermometers connected
#	to a Raspberry Pi
#	either as a client of the immediate C network
#	or directly to a terminal or file
#
#	Module Time::HiRes is used for repeat timing.
#
########################################################################

use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use Time::HiRes qw(alarm gettimeofday sleep);
use strict;
use warnings;

my @ArgNames;		# stores IO names and initialisers in argument list order
my @ChannelNames;	# stores IO names with instance for each registered channel
my @ChannelsIq;		# stores previous value for all IWx inputs
my %IONames;		# stores channel for each IO name (aux use in initial pass)
my $UnitRegistrations;	# stores the registration string
my @thermometers;	# stores thermometer ID, pointer to rolling mean and channel
my %thermometerIDs;	# used in argument analysis
my %thermometerCHs;	# addresses for storing channel in registration
my @Atx100;		# rolling mean for each thermometer, initially undef
my @Apx100;		# previous output value for each thermometer
my ($iec, $tid, $n_thermometers, $thermometerRef, $argNameRef, $ix);

########################################################################
#
#	Initialization
#
########################################################################

my $named = untaint($0); $named =~ s#.*[/\\]##;
format STDERR =
Usage:
    @<<<<<< [-wdlCFmtRSTxh][ -s <host>][ -p <port>][ -n <name>][ -i <inst>]
	$named
      [ -o <out>][ -r <time>][ -f <file>][ <IEC>[-<IEC>|:<tid>][-<inst>]] ...]
    DIRECT OUTPUT OPTIONS (default no iC output unless IEC's are specified)
	-w	write temperatures to terminal
	-o out	write temperatures to file <out>
	-d	write date and time with output
    COMMON OPTIONS
	-C	output temparature in 1/10th degrees Centigrade (default)
	-F	output temparature in 1/10th degrees Fahrenheit
	-r time	measurement repetition <time> in seconds (default 60 sec)
	-f file read additional parameters from this <file>
    iC OUTPUT OPTIONS
	IEC	IW0 IW1 IW2 ...  (default IEC is IW0 etc unless -w -o -d)
	    A range of IEC's can be specified with -; eg IW0-IW3
	    alternatively
	IEC:tid	individual IECs may be followed by the thermometer
	    identification or part of it; eg IW0:28-0000062e8239 or IW0:239
	    (default: thermometers connected in ascending numerical order).
	IEC-inst Each IEC can be followed by -<inst>, where <inst> consists
		of up to 3 numeric digits (usually 1 digit).
		Such an appended instance code takes precedence over the
		general instance specified with the -i <inst> (see below).
	-s host	host name of iCserver    (default 'localhost')
	-p port	service port of iCserver (default '8778')
	-n name	registration name (default first full IEC)
	-i inst instance ID for this @<<<<<< (1 to 3 numeric digits)
				    $named
    DEBUG OPTIONS
	-l	list connected thermometer identifications
	-m	display elapsed time in seconds and microseconds
	-t	trace debug messages
	-R      trace rcv messages in Msg.pm
	-S      trace send messages in Msg.pm
	-T	extra static debug messages
	-x	exit after analyzing input parameters
	-h	help, ouput this Usage text only
Copyright (C) 2014  John E. Wulff		<immediateC@gmail.com>
							  '@'
$Id: iCtherm,v 1.2 2014/11/29 06:31:53 jw Exp $
.

use vars qw($opt_w $opt_d $opt_o $opt_l $opt_C $opt_F $opt_m $opt_t $opt_R $opt_S $opt_T);
use vars qw($opt_s $opt_p $opt_n $opt_i $opt_r $opt_f $opt_x $opt_h);
use Getopt::Std;
getopts('wdo:lCFmtRSTxs:p:n:i:r:f:h');	# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    $t0 = [gettimeofday];	# start of program
}

$opt_F = undef	if $opt_C;	# Centigrade has precedence

if ($opt_o) {
    open STDOUT, ">$opt_o" or die "*** ERROR: $named: can't redirect stdout to '$opt_o': $!";
    $opt_w = 1;			# -o implies -w
}
if ($opt_d) {
    $opt_w = 1;			# -d implies -w
}

my $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = "-$opt_i";
	print STDERR "instance = '$instance'\n" if $opt_t;
    } else {
	warn "*** WARNING: $named: badly formed option -i $opt_i - ignored\n";
    }
}

########################################################################
#
#	Detect and initialise DS18B20 digital thermometers
#
########################################################################

my $therm = `/bin/bash -c 'sudo modprobe w1-gpio; sudo modprobe w1-therm; for f in \$(ls /sys/bus/w1/devices/); do if [[ "\$f" =~ "28-" ]]; then echo \$f; fi; done'`;
chomp $therm;
$therm or die "*** ERROR: $named: no DS18B20 digital thermometers detected - cannot measure tenperatues";
print STDERR "therm = '$therm'\n" if $opt_t;
$ix = 0;
foreach $tid ( split ' ', $therm ) {
    my $Rtx100 = \$Atx100[$ix];			# pointer to current average temperature
    $Apx100[$ix] = -27310;			# impossible temperature * 100 value
    my $Rpx100 = \$Apx100[$ix++];		# pointer to previous output temperature
    push @thermometers, [ $tid, 0, $Rtx100, $Rpx100 ];	# thermometer order for outputting temperature
}
$n_thermometers = scalar @thermometers;

$opt_r = 60	unless $opt_r;	# default measurement repetition time
$opt_r = $n_thermometers if $opt_r < $n_thermometers;	# give each thermometer 1 second to measure
print STDERR "Measurement repetition time = $opt_r seconds\n" if $opt_t;

print STDERR "The following $n_thermometers DS18B20 digital thermometers were detected:\n" if $opt_l;
foreach $thermometerRef (@thermometers) {
    ($tid, undef, undef, undef) = @$thermometerRef;
    $thermometerIDs{$tid} = "";			# no IEC ID assigned yet
    $thermometerCHs{$tid} = \$$thermometerRef[1];	# address for storing channel in registration
    print STDERR "	$tid\n" if $opt_l;
}

########################################################################
#
#	Analyse IEC parameters
#
#	IW3 IW7	generates only inputs IW3 and IW7
#
########################################################################

########################################################################
#	Scan for extra IEC parameters in $opt_f file
########################################################################

if ($opt_f) {
    open IN, $opt_f or die "can't open option file $opt_f! $!";
    LINE:
    while (<IN>) {		# read next entry from option file into $_
	chomp;			# $_ is an option line
	print STDERR "$opt_f:$.: '$_'\n" if $opt_t;
	my ($lead, $pos, $tail);
	$pos = 0;
	while (
	    /
		( .*? )				# $1 $lead - NOTE minimal matching
		( IW\d+ )			# $2 IEC-1131 range start ID
		(
		    (
			\s*(-)\s*		# $5 "-"
			( IW\d+ )		# $6 IEC-1131 optional range end ID
		    )
		|				#        or alternatively
		    (
			\s*(:)\s*		# $8 ":"
			( (28-)?[\da-fA-F]+ )	# $9 optional thermometer id or part of it
		    )
		)?				#        either is optional but not both
		(
		    \s*(-)\s*			# $12 "-"
		    ( \d{1,3} )			# $13 optional 1 to 3 digit instance
		)?
	    /xg
	) {
	    $lead = $1;
no warnings;
	    $iec = "$2$5$6$8$9$12$13";		# leave out spaces
use warnings;
	    $pos = pos;
	    print STDERR "$opt_f:$.: pos = '$pos' lead = '$lead' id = '$iec'\n" if $opt_t;
	    if ($lead =~ /^\s*(#.*)?$/) {
		next LINE if $1;	# skip next unless perl comment
	    } else {
		warn "*** WARNING: $named: file $opt_f:$.: '$_' contains badly formed IEC parameter '$lead'\n";
	    }
	    push(@ARGV, $iec);		# put next IEC on end of @ARGV
	}
	$tail = substr $_, $pos;
	print STDERR "$opt_f:$.: pos = '$pos' tail = '$tail'\n" if $opt_t;
	unless ($tail =~ /^\s*(#.*)?$/) {
	    warn "*** WARNING: $named: file $opt_f:$.: '$_' contains badly formed IEC parameter '$tail'\n";
	}
    }
    close IN;
}

########################################################################
#	Generate default IEC IDs if none supplied
########################################################################

unless ($opt_w or @ARGV) {
    for ($ix = 0; $ix < $n_thermometers; $ix++) {
	push(@ARGV, "IW$ix");		# default parameters IW0 etc unless -w
    }
}

########################################################################
#	First scan of IEC arguments - check if thermometer is available
########################################################################

my ($argv);
while ($argv = shift @ARGV) {
    my ($n, $sn, $en, $ti, $si, $key, $iec1);
    if ($argv =~
	    /^
		IW( \d+ )			# $1 $sn IEC-1131 ID
		(
		    ( -IW( \d+ ) )		# $4 $en IEC-1131 ID range end
		|				#        or alternatively
		    ( :( (28-)?[\da-fA-F]+ ) )	# $6 $ti thermometer id or part of it
		)*?				#        either is optional but not both
		( -\d{1,3} )?			# $8 $si optional 1 to 3 digit instance
	    $/x
    ) {
	$sn = $1;				# IEC addr start of range
	$en = defined $4 ? $4 : $1;		# IEC addr end of range (same as start if not defined)
	$ti = defined $6 ? $6 : '';		# optional thermometer id or part of it
	$si = defined $8 ? $8 : $instance;	# optional instance id else use '' or -i <instance>
	if ($en < $sn) {
	    goto ARG_WARN;			# must be equal or increasing range
	}
	Arg:
	foreach $n ($sn .. $en) {
	    $iec = "IW$n$si";			# generate individual IEC ID with optional instance
	    if (defined $IONames{$iec}) {
		warn "*** WARNING: $named: $iec used twice - ignore second occurence\n";
		next;
	    }
	    $tid = '';
	    print STDERR "*** iec = $iec, ti = '$ti';" if $opt_t;
	    if ($ti) {
		foreach $key (%thermometerIDs) {
		    if ($key =~ m/$ti/) {
			print STDERR " key = $key, tid = '$tid';" if $opt_t;
			if (($iec1 = $thermometerIDs{$key})) {
			    print STDERR "\n" if $opt_t;
			    warn "*** WARNING: $named: $iec:$ti already outputs on $iec1:$IONames{$iec1} - ignore $iec\n";
			    next Arg;
			} else {
			    $tid = $key;	# full thermometer id
			    last;
			}
		    }
		}
		unless ($tid) {
		    print STDERR "\n" if $opt_t;
		    warn "*** WARNING: $named: thermometer $ti not available - ignore $iec:$ti\n";
		    next;
		}
		$thermometerIDs{$tid} = $iec;	# assign this IEC ID to a thermometer id if known
	    }
	    print STDERR "\n" if $opt_t;
	    $IONames{$iec} = $tid;		# mark valid IEC ID (thermometer known or unknown)
	    push @ArgNames, [ $iec, $tid ];	# IEC parameter order for outputting temperature
	}
    } else {
	ARG_WARN: warn "*** WARNING: $named: $argv: badly formed IEC parameter - ignored\n";
    }
}

my $len_ArgNames = scalar @ArgNames;

if ($len_ArgNames > $n_thermometers) {
    die "The number of input arguments $len_ArgNames is greater than the number of thermometers $n_thermometers - cannot execute\n";
}
if (not $opt_w and $len_ArgNames < $n_thermometers) {
    warn "*** WARNING: $named: the number of input arguments $len_ArgNames is less than the number of thermometers $n_thermometers - ignore extra thermometers\n";
}

$len_ArgNames or $opt_w or die "*** ERROR: $named: no valid IEC arguments - nothing to do!!\n";

########################################################################
#	Assign remaining thermometers to IDs not assigned above
#
#	If $opt_w there may also be some IEC arguments to output
#	Else there is an IEC argument for each thermometer
########################################################################

foreach $argNameRef (@ArgNames) {
    ($iec, $tid) = @$argNameRef;
    unless ($tid) {
	foreach $tid (sort keys %thermometerIDs) {
	    unless ($thermometerIDs{$tid}) {
		$thermometerIDs{$tid} = $iec;	# assign this IEC ID to a thermometer ID
		$IONames{$iec} = $tid;		# mark valid IEC ID with now known thermometer
		$$argNameRef[ 1 ] = $tid;	# supply thermometer ID for registration
		goto THERMOMETER_FOUND;		# unassigned thermometer found
	    }
	}
	die "The number of IEC input arguments $len_ArgNames is greater than the number of thermometers $n_thermometers - cannot execute\n";
    }
  THERMOMETER_FOUND:
    print STDERR " $tid:$iec\n" if $opt_t;
}

unless ($opt_w) {
    foreach $tid (sort keys %thermometerIDs) {
	unless ($thermometerIDs{$tid}) {
	    warn "*** WARNING: $named: ignore extra thermometer $tid\n";
	}
    }
}

if ($opt_t) {
    print STDERR "Thermometer:	IEC ID\n";
    foreach $argNameRef (@ArgNames) {
	print STDERR "$$argNameRef[1]:$$argNameRef[0]\n";
    }
}

exit if $opt_x;			# deliberate exit with -x option

my $conn;
my $register = 0;		# tested in rcvd_msg_from_server() for registration reply
my $ri = 0;			# registration index used in rcvd_msg_from_server()
my $thermometerCount = 0;	# number of thermometers to output to iCserver

if ($len_ArgNames) {
    ########################################################################
    #
    #	Connect to server and register I/Os
    #
    #	Inhibit Nagle's algorithm
    #
    ########################################################################

    my $host = defined $opt_s ? $opt_s : 'localhost';
    my $port = defined $opt_p ? $opt_p : 8778;
    my $name = untaint($opt_n ? "$opt_n$instance" : $ArgNames[0][0]);	# : $ArgNames [first entry] [$iec]
    $named = $name;			# use individual ID for warnings from now on
    $register = 1;

    Msg->inhibit_nagle(1, $opt_R, $opt_S);	# inhibit Nagle's algorithm for real time response
    $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
    die "Client '$named' could not connect to $host:$port\n" unless $conn;

    ############# send registration ############################

    my ($direction);
    $UnitRegistrations = "N$name";	# initiate registration string

    foreach $argNameRef (@ArgNames) {
	($iec, $tid) = @$argNameRef;
	$direction = '';
	if ($iec =~ /^IW/) {
	    $direction = 'S';
	} else {
	    die "*** ERROR: $named: invalid argument '$iec' - internal error";
	}
	if ((length($UnitRegistrations) + length($iec)) > 1396) {	# REPLY 1400 - (1+2+1) in tcpc.h
	    print STDERR "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
	    $conn->send_now($UnitRegistrations);
	    my ($tmsg, $terr) = $conn->rcv_now();
	    print STDERR "$named: Reply: $tmsg\n" if $opt_t;
	    rcvd_msg_from_server($conn, $tmsg, $terr);	# receive registration acknowledgment
	    $UnitRegistrations = '';
	}
	$UnitRegistrations .= ",$direction$iec";	# direction 1 ',Z' 2 term 1
	print STDERR "register: $direction$iec	thermometer = $tid\n" if $opt_t;
    }
    $UnitRegistrations .= ",Z";		# terminate registration string
    print STDERR "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
    $conn->send_now($UnitRegistrations);
    my ($tmsg, $terr) = $conn->rcv_now();
    print STDERR "$named: Reply: $tmsg\n" if $opt_t;
    rcvd_msg_from_server($conn, $tmsg, $terr);	# receive final registration acknowledgment

    ############# registration analysis ########################
    $ri == scalar @ArgNames or
	die "*** ERROR: $named: $ri: not enough registration replies from iCserver - system error";
    $thermometerCount != 0 or
	die "*** ERROR: $named: no valid registrations - cannot output to iCserver\n";
    $register = 0;
    ############# correct number of registration replies #######
}
if ($opt_t) {
    my $c;
    print STDERR "Report result of registration\n";
    foreach $thermometerRef (@thermometers) {
	($tid, $c, undef, undef) = @$thermometerRef;
	print STDERR "ti = $tid; channel = $c\n";
    }
}

########################################################################
#
#	Start the temperature measurement loop
#
########################################################################

$SIG{ALRM} = \&measureTemperatures;	# signal 14 - Timer signal from alarm()
printf(STDERR "%s\tstart temperature measurements\n", scalar localtime);
alarm(1, $opt_r);			# first measurement in 1 second

if ($conn) {
########################################################################
#
#	Sit in an infinite loop dispatching incoming events.
#	if connected to iCserver
#
########################################################################
Msg->event_loop();	# NOTE: there should be no events for this app
} else {
########################################################################
#
#	Waste time waiting for SIG ALRM if -w -d or -o and no iC output
#	with Linux this sleep() also wakes up for each SIG ALRM
#
########################################################################
    sleep(1000000) while 1;
}

####### End of main program ############################################

########################################################################
#
#	Send input value to iCserver
#
########################################################################

sub send_input {
    my ($ch, $val) = @_;
    if ($val != $ChannelsIq[$ch]) {
	$ChannelsIq[$ch] = $val;		# always save latest value sent on this channel
	printMicroSeconds();
	print STDERR "$named: $ch:$val	> $ChannelNames[$ch]\n" if $opt_t;
	printf STDERR "%s	%2d:%d	>\n", $ChannelNames[$ch], $ch, $val if $opt_S;
	$conn->send_now("$ch:$val");		# send latest value
    } else {
	warning("hysteresis not working correctly for channel $ch\n");
    }
} # send_input

########################################################################
#
#	Receive ack registration message from server
#
#	NOTE: this app never receives any data values to output
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, undef) = @_;
    printMicroSeconds();
    if (defined $msg) {
        my $len = length $msg;
	print STDERR "($len)$msg<\n" if $opt_T;
	if ($len == 0) {
	    $conn->disconnect();
	    print STDERR "$named: disconnected by server\n";
	    exit;
	}
	my ($msg1, $channel, $iec);
	foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
	    if ($register and $msg1 =~ /^(-?\d+)$/) {
		next if $1 eq '-0';		## null acknowledgment
		$channel = $1;			## receive channel of a registration acknowledgment
		($iec, $tid) = @{$ArgNames[$ri]};	# all argument values
		defined $iec or
		    die "*** ERROR: $named: too many registration acknowledgments from iCserver - system error";
		print STDERR "$named: $ri: registering '$iec' on channel '$channel'\n" if $opt_t;
		$ri++;
		my $dir = '';
		if ($iec =~ /IW/) {
		    if ($channel == 0) {
			warn "*** WARNING: $named: trying to register sender '$iec' twice - not allowed\n";
			next;
		    }
		    $dir = 'S';
		    $thermometerCount++;
		    $ChannelsIq[$channel] = -2731;	# impossible initial temperature value
		    ${$thermometerCHs{$tid}} = $channel;	# store channel in @thermometers
		} else {
		    goto WrongFormat;
		}
		if ($dir) {
		    $ChannelNames[$channel] = "$iec";
		    print STDERR "register: $dir$iec channel = $channel thermometer = '$tid'\n" if $opt_t;
		}
	    } else {
	      WrongFormat:
		warn "*** WARNING: $named: WARNING: '$msg1' out of '$msg' from iCserver has wrong format - ignored";
	    }
	}
    }
} # rcvd_msg_from_server

########################################################################
#
#	Make a set of temperature measurements
#
#	A temperature value from a DS18B20 thermometer is obtained
#	by executing the following from the correct directory:
#	    cat /sys/bus/w1/devices/28-0000062e8239/w1_slave
#	A string like the following is returned and split into @temp:
#	    98 01 4b 46 7f ff 08 10 22 : crc=22 YES
#	    98 01 4b 46 7f ff 08 10 22 t=25500
#	The measurement is good if YES is returned (NO on crc error).
#	The first 2 values are the measurement (least significant first)
#	interpreted as hex values in 1/16th degrees Centigrade.
#	    0x0198 ==> 408; 408/16 ==> 25.5 °C
#	The converted value is also reported in the last token, but it
#	is not quite accurate (misses a final digit 5 for odd 16ths).
#
#	It seems appropriate to do a moving average with a factor of
#	6.25 (16 * 6.25 ==> 100).
#	Multiply the initial value by 6.25 ==> value in 1/100th degrees C.
#	For each new value multply old value by 1 - 1/6.25 (0.84); add
#	new value (* 6.25/6.25) ==> moving average in 1/100th degrees C.
#
#	The extra smoothing takes care of a slight jitter observed in the
#	measurements and gives a good result accurate to 2 decimal places.
#
#	iC output is degrees Centigrade or Fahrenheit (rounded to 1/10
#	degree) * 10 transmitted to iCserver as a 16 bit signed integer
#
#	-w -o <out> -d
#	default output is in in degrees Centigrade rounded to 1/10 degree C.
#	-F output is degrees Fahrenhet rounded to 1/10 degree F. This is
#	1/18 degree C, which is close to the measurement accuracy of 1/16.
#
#	Repeat for each thermometer.
#
########################################################################

sub measureTemperatures {
    my ($tid, $channel, $Rtx100, $Rpx100, @temp, $tx16, $tx100, $tx10);
    print STDERR "measureTemperatures\n" if $opt_T;
    READING:
    foreach $thermometerRef (@thermometers) {
	($tid, $channel, $Rtx100, $Rpx100) = @$thermometerRef;
	while (1) {
	    @temp = split ' ', `/bin/bash -c 'f="/sys/bus/w1/devices/$tid/w1_slave"; if [ -f \$f ]; then cat \$f; fi'`;
	    if (scalar @temp != 22) {
		print STDERR "*** WARNING: $tid:", join(' ', @temp), ": Faulty measurement ???\n";
		next READING;
	    }
	    print STDERR "$tid:", join(' ', @temp), "\n" if $opt_T;
	    last if $temp[11] eq "YES"
	}
	$tx16 = oct("0x$temp[1]$temp[0]");
	if (defined $$Rtx100) {
	    $$Rtx100 *= 0.84;
	    $$Rtx100 += $tx16;			# moving average
	} else {
	    $$Rtx100 = $tx16 * 6.25;		# initial value degrees Centigrade * 100
	}
	$tx100 = $opt_F ? $$Rtx100 * 1.8 + 3200 : $$Rtx100;
	printf(STDERR "%s	%3d	%3.6f °%s\n", scalar localtime, $tx16, $tx100/100, $opt_F ? "F" : "C") if $opt_t;
	if ($tx100 >= $$Rpx100 + 6 || $tx100 < $$Rpx100 - 6) {	# hysteresis +- .01 <== (6-5)/100
	    $tx10 = int(($tx100 + 5) / 10);	# round to degrees (C or F) * 10
	    $$Rpx100 = $tx10 * 10;		# previous output value for comparison
	    if ($channel) {
		send_input($channel, $tx10);	# send temperature value to iCserver
	    }
	    if ($opt_w) {
		if ($opt_d) {
		    printf("%s\t", scalar localtime); # standard date and time string
		}
		if ($n_thermometers > 1) {
		    printf("%s\t", $tid);	# thermometer id
		}
		printf("%3.1f °%s\n", $tx10/10, $opt_F ? "F" : "C");	# print temperature
	    }
	}
    }
} # measureTemperatures

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    if ($opt_m) {
	my ($sec, $usec);
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf STDERR "T%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf STDERR "T%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
	$t0 = $t1;
    } elsif ($opt_t) {
	print STDERR "T: ";
    }
} # printMicroSeconds

########################################################################
#
#	Untaint a string for executing from a setuid program
#
########################################################################

sub untaint {
    my ($string) = @_;
    if ($string =~ m/^([-\@\w.\/\\]+)$/) {
	return $1;		# now untainted
    } else {
	die "Bad data in $string";
    }
} # untaint
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCtherm - an iC or standalone program supplying temperature values

=head1 SYNOPSIS

 iCtherm [-wdlCFmtRSTxh][ -s <host>][ -p <port>][ -n <name>][ -i <inst>]
      [ -o <out>][ -r <time>][ -f <file>][ <IEC>[-<IEC>|:<tid>][-<inst>]] ...]
    DIRECT OUTPUT OPTIONS (default no iC output unless IEC's are specified)
	-w	write temperatures to terminal
	-o out	write temperatures to file <out>
	-d	write date and time with output
    COMMON OPTIONS
	-C	output temparature in 1/10th degrees Centigrade (default)
	-F	output temparature in 1/10th degrees Fahrenheit
	-r time	measurement repetition <time> in seconds (default 60 sec)
	-f file read additional parameters from this <file>
    iC OUTPUT OPTIONS
	IEC	IW0 IW1 IW2 ...  (default IEC is IW0 etc unless -w -o -d)
	    A range of IEC's can be specified with -; eg IW0-IW3
	    alternatively
	IEC:tid	individual IECs may be followed by the thermometer
	    identification or part of it; eg IW0:28-0000062e8239 or IW0:239
	    (default: thermometers connected in ascending numerical order).
	IEC-inst Each IEC can be followed by -<inst>, where <inst> consists
		of up to 3 numeric digits (usually 1 digit).
		Such an appended instance code takes precedence over the
		general instance specified with the -i <inst> (see below).
	-s host	host name of iCserver    (default 'localhost')
	-p port	service port of iCserver (default '8778')
	-n name	registration name (default first full IEC)
	-i inst instance ID for this iCtherm (1 to 3 numeric digits)
    DEBUG OPTIONS
	-l	list connected thermometer identifications
	-m	display elapsed time in seconds and microseconds
	-t	trace debug messages
	-R      trace rcv messages in Msg.pm
	-S      trace send messages in Msg.pm
	-T	extra static debug messages
	-x	exit after analyzing input parameters
	-h	help, ouput this Usage text only

=head1 DESCRIPTION

The B<iCtherm> program measures temperature using one or more
B<DS18B20> 1-Wire digital thermometers connected to GPIO4 of a
Raspberry Pi.

The DS18B20 digital thermometer provides 9-bit to 12-bit Centigrade
temperature measurements and has an alarm function with nonvolatile
user-programmable upper and lower trigger points.  It has an operating
temperature range of -55°C to +125°C and is accurate to ±0.5°C
over the range of -10°C to +85°C.

Each DS18B20 has a unique 64-bit serial code, which allows multiple
DS18B20s to function on the same 1-Wire bus. Thus, it is simple to
use one processor to control many DS18B20s distributed over a
large area. Applications that can benefit from this feature include
HVAC environmental controls, temperature monitoring systems inside
buildings, equipment, or machinery, and process monitoring and
control systems.

B<iCtherm> uses 12-bits for maximum resolution and currently does
not use the alarm function. The program has been designed to be an
I/O client for an iC network supplying temperature values either in
degrees Centigrade or Fahrenheit in 1/10 degree steps. Each thermometer
supplies a 16 bit word value in the range -550 to +1250 on an IEC-1131
input IWx associated with a thermometer in the call.  These values are
to be interpreted in the range of -55.0°C to +125.0°C.  (Fahrenheit
values have a range of -670 to +2570 for the same temperatures -67.0°F
to +257.0°F).

Temperature values can also be printed directly to standard output or
to a file with the -w or -o options. With the -d option each temperature
output also has a date and time stamp. If no IEC ID parameters are
given, the program acts as a standalone temperature recorder.

Temperature readings are made at regular intervals - the default is
60 seconds. This can be altered in 1 second steps with the -r option.
These readings, which are in 1/16th°C  for 12 bit resolution are
smoothed with a moving average of 6.25. This gives values in 0.01°C
smoothed over approx 5 minutes. For output this value is rounded to
the nearest 0.1°C (or converted to Fahrenheit and rounded to the
nearest 0.1°F).  Output to the iC network (or to printed output) only
occurs when a value changes by at least 0.1° with a hysteresis of
±0.01°. In practice this means output only occurs every 15 minutes
or so - often longer if the temperature is stable.

 IEC parameters for the iC network

 IEC     IW0 IW1 IW2 ...  (default IEC is IW0 etc unless -w -o -d)
         A range of IEC's can be specified -  eg IW0-IW3
	 alternatively
 IEC:tid individual IECs may be followed by the thermometer
         identification or part of it; eg IW0:28-0000062e8239 or IW0:239
         (default: thermometers connected in ascending numerical order).

The identification strings of connected thermometers are listed with
the -l option.

=head1 ELECTRICAL CONNECTIONS

B<DS18B20> 1-Wire digital thermometers are connected to the Raspberry
PI by connecting the the red wire (Vcc) to 3.3 volts, the green wire
(Gnd) to 0 volts and the yellow wire (DQ0 to GPIO4 (pin 7). A 4.7
kohm pull up resistor must also be connected from GPIO4 to Vcc. The
program was tested with 10 DS18B20 thermometers. All 3 wires are each
connected in parallel.

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<iCbox(1)>, L<immcc(1)>, L<iClive(1)>, L<iCserver(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2014  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
