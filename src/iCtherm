#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2014  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCtherm
#	output temperature in 1/10th degrees Centigrade or Fahrenheit
#	using one or more DS18B20 1-Wire Digital Thermometers connected
#	to a Raspberry Pi
#	either as a client of the immediate C network
#	or directly to a terminal or file
#
#	Module Time::HiRes is used for repeat timing.
#
########################################################################

use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use Time::HiRes qw(alarm gettimeofday sleep);
use Fcntl qw(:flock);	# import LOCK_* constants
use strict;
use warnings;

sub termQuit ($);

my @ArgNames;		# stores IO names and initialisers in argument list order
my @ChannelNames;	# stores IO names with instance for each registered channel
my @ChannelsIq;		# stores previous value for all IWx inputs
my %IONames;		# stores channel for each IO name (aux use in initial pass)
my @plain_opt_I;		# stores -I ids without :tid
my $UnitRegistrations;	# stores the registration string
my @thermometers;	# stores thermometer ID, pointer to rolling mean and channel
my %thermometerIDs;	# used in argument analysis
my %thermometerCHs;	# addresses for storing channel in registration
my @Atx100;		# rolling mean for each thermometer, initially undef
my @Apx100;		# previous output value for each thermometer
my @argv = ();
my ($iec, $tid, $id, $n_thermometers, $thermometerRef, $argNameRef, $ix);
%IONames = ();

########################################################################
#
#	Initialization
#
########################################################################

my $named = untaint($0); $named =~ s#.*[/\\]##;
format STDERR =
Usage:
 @<<<<<< [-wdlCFmtTxqzh][ -s <host>][ -p <port>][ -n <name>][ -i <inst>]
    $named
         [ -o <out>][ -r <time>][ -W <GPIO>][ -I <id[:tid]> ...][ -d <i>]
         [ <IEC>[-<IEC>|:<tid>][-<inst>] ...]
         [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    DIRECT OUTPUT OPTIONS (default no iC output unless IEC's are specified)
        -w      write temperatures to terminal
        -o<out> write temperatures to file <out>
        -d      write date and time with output
        -I <id> write id before new temperature eg 'inside' or 'outside'
            alternatively
        -I <id:tid> individual ids may be preceded by the thermometer id or
                part of it; eg -I inside:28-0000062e8239 or -I inside:239
                (default: thermometer ids in ascending numerical order).
                Note: any -I <id...> option implies -w
    COMMON OPTIONS
        -C      output temparature in 1/10th degrees Centigrade (default)
        -F      output temparature in 1/10th degrees Fahrenheit
        -r time measurement repetition <time> in seconds (default 60 sec)
        -W GPIO number used by the w1-gpio kernel module (default 4)
    iC OUTPUT OPTIONS
        IEC     IW0 IW1 IW2 ... (default IEC is IW0 etc unless -w -o -d -l)
                A range of IEC's can be specified with -; eg IW0-IW3
            alternatively
        IEC:tid	individual IECs may be followed by the thermometer id or
                part of it; eg IW0:28-0000062e8239 or IW0:239
                (default: thermometers connected in ascending numerical order).
        IEC-inst Each IEC can be followed by -<inst>, where <inst> consists
                of up to 3 numeric digits (usually 1 digit).
                Such an appended instance code takes precedence over the
                general instance specified with the -i <inst> (see below).
        -S server +options+equivalences  (default 'iCserver -ak')
        -s host host name of iCserver    (default 'localhost')
        -p port service port of iCserver (default '8778')
        -n name registration name        (default first full IEC)
        -i inst instance ID for this iCtherm (1 to 3 numeric digits)
				    $named
    DEBUG OPTIONS
        -l      list connected thermometer identifications
        -m      display elapsed time in seconds and microseconds
        -t      trace debug messages
	-d <i>  trace 1=send 2=rcv 3=both messages in Msg.pm
        -T      extra static debug messages
        -x      exit after analyzing input parameters
	-q      quiet - do not report clients connecting and disconnecting
	-z      block keyboard input
        -h      help, ouput this Usage text only
    AUXILIARY app
        -R <app ...> run auxiliary app followed by -z and its arguments
                     as a separate process; -R ... must be last arguments.
Copyright (C) 2014  John E. Wulff              <immediateC@gmail.com>
							'@'
$Id: iCtherm,v 1.4 2015/11/06 10:43:33 jw Exp $
.

########################################################################
#	Handle -R option - count leading options up to -R
#	splice -R to end - move app and remaining arguments to @runArgs
########################################################################

my ($argIndex, $blank, $app, @runArgs);
$argIndex = $blank = 0;
@runArgs = ();
# print "0 \@ARGV = '@ARGV'\n";
foreach (@ARGV) {
    if (s/^-R(.*)$/$1/) {
	$blank = 1 if $_ eq "";		# -R
	$app = "";			# or -Rapp
	last;
    } elsif (s/^(-[^odISspnirWR]+)R(.*)$/$1/) {
	$app = $2;			# -abcR or -abcRapp
	$argIndex++;
	last;
    }
    $argIndex++;
}
# no warnings;
# print "1 \@ARGV = '@ARGV'	\$argIndex = $argIndex	\$app = '$app' $#ARGV\n";
# use warnings;
@runArgs = splice @ARGV, $argIndex;
if (defined $app) {
    shift(@runArgs) if $blank;
    unshift(@runArgs, $app) if $app ne "";
}				# append a -z$opt_q later to block STDIN
# print "2 \@ARGV = '@ARGV'	\@runArgs = '@runArgs'\n"; exit;

########################################################################
#	Handle all remaining -switch options and non-switch options
########################################################################

use vars qw($opt_ $opt_w $opt_o $opt_d @opt_I $opt_l $opt_C $opt_F $opt_m $opt_t $opt_T);
use vars qw($opt_q $opt_z $opt_S $opt_s $opt_p $opt_n $opt_i $opt_r $opt_W $opt_x $opt_X $opt_h);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    ''    => \$opt_,			# lone - blocks STDIN
    '<>'  => sub { push(@argv, @_); },	# Transfer file argument to @argv
    'w'   => \$opt_w,
    'o=s' => \$opt_o,
    'd:i' => \$opt_d,		# -d # output date -d1 # trace send -d2 # trace recv
    'I=s' => \@opt_I,		# -I option may occurr more than once
    'l'   => \$opt_l,
    'C'   => \$opt_C,
    'F'   => \$opt_F,
    'm'   => \$opt_m,
    't'   => \$opt_t,
    'T'   => \$opt_T,
    'q'   => \$opt_q,
    'z'   => \$opt_z,
    'S=s' => \$opt_S,
    's=s' => \$opt_s,
    'p=s' => \$opt_p,
    'n=s' => \$opt_n,
    'i=i' => \$opt_i,
    'r=i' => \$opt_r,
    'W=i' => \$opt_W,
    'x'   => \$opt_x,
    'X'   => \$opt_X,
    'h'   => \$opt_h,
);
scalar @ARGV == 0 or die "*** ERROR: $named: '@ARGV' remaining after Getopt::Long Getoptions() ???\n";
print "\@argv = '@argv'	\@runArgs = '@runArgs'\n" if $opt_T;

########################################################################

exit(-1) if $opt_X;		# $named -X called in forked process if first exec fails

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    $t0 = [gettimeofday];	# start of program
}

if ($opt_q) {
    $opt_q = 'q';		# quiet option
} else {
    $opt_q = '';		# define $opt_q
}

$opt_F = undef	if $opt_C;	# Centigrade has precedence

if ($opt_o) {
    open STDOUT, ">$opt_o" or die "*** ERROR: $named: can't redirect stdout to '$opt_o': $!";
    $opt_w = 1;			# -o implies -w
}
if ((defined $opt_d and $opt_d == 0) or @opt_I) {
    $opt_w = 1;			# -d or any -I <id...> implies -w
}
if (defined $opt_W) {
    $opt_W < 32 or die "*** ERROR: $named: GPIO $opt_W is not valid for the kernel module w1-gpio - cannot execute\n";
} else {
    $opt_W = 4;			# default is GPIO 4 for kernel module w1-gpio
}
$opt_S = "iCserver -ak" unless defined $opt_S;

my $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = "-$opt_i";
	print STDERR "instance = '$instance'\n" if $opt_t;
    } else {
	warn "*** WARNING: $named: badly formed option -i $opt_i - ignored\n";
    }
}
$SIG{INT}  = \&termQuit;	# signal 2	(ctrl-C interrupt from keyboard)

########################################################################
#
#	Check the lock file ~/.iC/gpios.used to see if GPIO 4
#	or strictly GPIO $opt_W is free and has never been used for
#	direct I/O with 'sysfs' by iCpiFace or iC apps supporting
#	direct I/O or with 'pigpio' by iCpiPWM. These apps set bit 64
#	in $used if they have used GPIO4 ($opt_W).
#
#	If it has, 'modprobe w1-gpio' will fail with a kernel Oops.
#       To avoid this, check character 64 in $usedString, which is
#	equivalent to checking bit 64 in $used.
#
#	None of the apps dealing with GPIOs can force bit 64 of $used
#	to 0 because of the danger of a kernel Oops. If you have rebooted,
#	which frees GPIO 4 ($opt_W) in the module w1-gpio again,
#	delete the lock file by either running iCtherm -F immediately
#				or 'rm ~/.iC/gpios.used'
#	to allow iCtherm to run again.
#
#	Also set bit 4 ($opt_W) in $used and write the $used back to
#	~/.iC/gpios.used to prevent other apps using GPIO 4 ($opt_W) while
#	iCtherm is running. On termination reverse this action.
#
########################################################################

my ($home, $usedFile, $used, $usedString, $usedMask);
my $OopsFlag = 0;

if (($home = $ENV{HOME}) ne '' and
    (-d "$home/.iC" or mkdir "$home/.iC")) {
    $usedFile = "$home/.iC/gpios.used";
    if (-f $usedFile) {
	open USED, "+< $usedFile"				or die "can't open $usedFile: $!";	# open exixting
	$used = undef;
    } else {
	open USED, "+> $usedFile"				or die "can't create $usedFile: $!";	# create new
	$used = pack("b128", "0" x 128);
    }
    flock(USED, LOCK_EX)					or die "can't lock $usedFile: $!";
    unless ($used) {
	sysread(USED, $used, 16)				or die "can't read $usedFile: $!";
    }
    $usedString = unpack("b128", $used);				print STDERR "usedString = $usedString\n" if $opt_T;
    if (($usedString & ("0" x 64 . "1")) eq ("0" x 64 . "1")) {	# test Oops bit 64 in $usedString
	my $key;						# iCtherm permanently blocked
	print STDERR
	    "Another app has used GPIO $opt_W for direct I/O with 'sysfs' or 'pigpio'.\n".
	    "This would cause an Oops in module w1-gpio required by $named";
	if ($opt_l and $opt_F and not $opt_w) {
	    print STDERR
		".\n".
		"Have you rebooted? ";
	    ;
	    if (($key = getc()) eq 'y' or $key eq 'Y') {
		$usedString &= "1" x 64 . "0";			# reset Oops bit 64 in $usedString
		print STDERR
		    "The locking file has been reset - you can call iCtherm normally if a thermometer\n".
		    "has been recognised correctly.\n";
	    } else {
		$OopsFlag = 1;					# cannot continue without rebooting
	    }
	} else {
	    print STDERR " - cannot execute.\n";
	    $OopsFlag = 1;					# cannot continue
	}
    }
    $usedMask = "0" x $opt_W . "1" . "0" x (63 - $opt_W);	print STDERR "usedMask   = $usedMask\n"   if $opt_T;
    $usedString |= $usedMask;					print STDERR "usedString = $usedString\n" if $opt_T;
    $used = pack("b128", $usedString);
    seek(USED, 0, 0)						or die "can't seek to start of $usedFile: $!";
    syswrite(USED, $used, 16)					or die "can't write $usedFile: $!";
    flock(USED, LOCK_UN)					or die "can't unlock $usedFile: $!";
    close USED							or die "can't close $usedFile: $!";
} else {
    die "*** ERROR: $named: cannot find env{HOME] or open make .iC directory - system error";
}
if ($OopsFlag) {
    termQuit "To allow $named to work normally again, reboot the system and call $named -lF\n".
	     "once to reset the Oops bit 1 in u.oops of the locking file ~/.iC/gpios.used\n";
}

########################################################################
#
#	Detect and initialise DS18B20 digital thermometers
#
########################################################################

my $therm = `/bin/bash -c 'sudo modprobe w1-gpio; sudo modprobe w1-therm; for f in \$(ls /sys/bus/w1/devices/); do if [[ "\$f" =~ "28-" ]]; then echo \$f; fi; done'`;
chomp $therm;
unless ($therm) {
    termQuit "No DS18B20 digital thermometers detected - cannot measure tenperatues\n";
}
print STDERR "therm = '$therm'\n" if $opt_t;
$ix = 0;
foreach $tid ( split ' ', $therm ) {
    my $Rtx100 = \$Atx100[$ix];			# pointer to current average temperature
    $Apx100[$ix] = -27310;			# impossible temperature * 100 value
    my $Rpx100 = \$Apx100[$ix++];		# pointer to previous output temperature
    push @thermometers, [ $tid, 0, $Rtx100, $Rpx100, '' ]; # thermometer order for outputting temperature
}
$n_thermometers = scalar @thermometers;

$opt_r = 60	unless $opt_r;	# default measurement repetition time
$opt_r = $n_thermometers if $opt_r < $n_thermometers;	# give each thermometer 1 second to measure
print STDERR "Measurement repetition time = $opt_r seconds\n" if $opt_t;

foreach $thermometerRef (@thermometers) {
    ($tid, undef, undef, undef, undef) = @$thermometerRef;
    $thermometerIDs{$tid} = [ '', '' ];			# no IEC and ID assigned yet
    $thermometerCHs{$tid} = \$$thermometerRef[1];	# address for storing channel in registration
}

########################################################################
#
#	Analyse IEC parameters
#
#	IW3 IW7	generates only inputs IW3 and IW7
#
########################################################################

########################################################################
#	Generate default IEC IDs if none supplied
########################################################################

unless ($opt_w or $opt_l or @argv) {
    for ($ix = 0; $ix < $n_thermometers; $ix++) {
	push(@argv, "IW$ix");		# default parameters IW0 etc unless -w or -l
    }
}

########################################################################
#	First scan IEC arguments - check if thermometer is available
########################################################################

%IONames = ();
my ($argv);
while ($argv = shift @argv) {
    my ($n, $sn, $en, $ti, $si, $key, $iec1);
    if ($argv =~
	    /^
		IW( \d+ )			# $1 $sn IEC-1131 ID
		(
		    ( -IW( \d+ ) )		# $4 $en IEC-1131 ID range end
		|				#        or alternatively
		    ( :( (28-)?[\da-fA-F]+ ) )	# $6 $ti thermometer id or part of it
		)*?				#        either is optional but not both
		( -\d{1,3} )?			# $8 $si optional 1 to 3 digit instance
	    $/x
    ) {
	$sn = $1;				# IEC addr start of range
	$en = defined $4 ? $4 : $1;		# IEC addr end of range (same as start if not defined)
	$ti = defined $6 ? $6 : '';		# optional thermometer id or part of it
	$si = defined $8 ? $8 : $instance;	# optional instance id else use '' or -i <instance>
	if ($en < $sn) {
	    goto ARG_WARN;			# must be equal or increasing range
	}
      Arg:
	foreach $n ($sn .. $en) {
	    $iec = "IW$n$si";			# generate individual IEC with optional instance
	    if (defined $IONames{$iec}) {
		warn "*** WARNING: $named: $iec used twice - ignore second occurence\n";
		next;
	    }
	    $tid = '';
	    print STDERR "*** iec = $iec, ti = '$ti';" if $opt_t;
	    if ($ti) {
		foreach $key (%thermometerIDs) {
		    if ($key =~ m/$ti/) {	# find partial thermometer id
			print STDERR " key = $key, tid = '$tid';" if $opt_t;
			if (($iec1 = $thermometerIDs{$key}[0])) {
			    print STDERR "\n" if $opt_t;
			    warn "*** WARNING: $named: $iec:$ti already outputs on $iec1:$IONames{$iec1} - ignore $iec\n";
			    next Arg;
			} else {
			    $tid = $key;	# full thermometer id
			    last;
			}
		    }
		}
		unless ($tid) {
		    print STDERR "\n" if $opt_t;
		    warn "*** WARNING: $named: ignore $iec:$ti - thermometer $ti not available\n";
		    next;
		}
		$thermometerIDs{$tid}[0] = $iec;	# assign this IEC to a thermometer id if known
	    }
	    print STDERR "\n" if $opt_t;
	    $IONames{$iec} = $tid;			# mark valid IEC (thermometer known or unknown)
	    push @ArgNames, [ $iec, $tid];		# IEC parameter order for outputting temperature
	}
    } else {
	ARG_WARN: warn "*** WARNING: $named: $argv: badly formed IEC parameter - ignored\n";
    }
}

########################################################################
#	Check number of IEC arguments matches thermometers available
########################################################################

my $lenArgNames = scalar @ArgNames;

if ($lenArgNames > $n_thermometers) {
    termQuit "*** ERROR: $lenArgNames input arguments is greater than the number of thermometers ($n_thermometers) - cannot execute\n";
}
unless ($opt_w or ($opt_l and not $lenArgNames)) {
    if ($lenArgNames < $n_thermometers) {
	if ($lenArgNames == 0) {
	    unless ($opt_l) {
		termQuit "*** ERROR: $named: no valid IEC arguments - nothing to do!!\n";
	    }
	}
    }
}

########################################################################
#	Then  scan -I id arguments - check if thermometer is available
########################################################################

my ($option);
%IONames = ();
@plain_opt_I = ();
Option:
while ($option = shift @opt_I) {
    my ($ti, $key, $id1);
    if ($option =~
	    /^
		( [^:]+ )			# $1 $sn id string
		( :( (28-)?[\da-fA-F]+ ) ) ?	# $6 $ti thermometer id or part of it
	    $/x
    ) {
	$id = $1;				# -I id
	$ti = defined $3 ? $3 : '';		# optional thermometer id or part of it
	if (defined $IONames{$id}) {
	    warn "*** WARNING: $named: -I $id used twice - ignore second occurence\n";
	    next;
	}
	$tid = '';
	if ($ti) {
	    foreach $key (%thermometerIDs) {
		if ($key =~ m/$ti/) {	# find partial thermometer id
		    if (($id1 = $thermometerIDs{$key}[1])) {
			warn "*** WARNING: $named: $id:$ti already used on $id1:$IONames{$id1} - ignore -I $id\n";
			next Option;
		    } else {
			$tid = $key;	# full thermometer id
			last;
		    }
		}
	    }
	    unless ($tid) {
		warn "*** WARNING: $named: ignore -I $id:$ti - thermometer $ti not available\n";
		next;
	    }
	    $thermometerIDs{$tid}[1] = $id;	# assign this id to a thermometer id if known
	} else {
	    push(@plain_opt_I, $id);		# -I id without :tid
	}
	print STDERR "*** -I id = $id, ti = '$ti', tid = '$tid'\n" if $opt_t;
	$IONames{$id} = $tid;			# mark valid id (thermometer known or unknown)
	if ($tid) {
	    foreach $thermometerRef (@thermometers) {
		($ti, undef, undef, undef, undef) = @$thermometerRef;
		if ($ti eq $tid) {
		    $$thermometerRef[ 4 ] = $id;	# store id
		}
	    }
	}
    } else {
	warn "*** WARNING: $named: -I '$option' badly formed id parameter - ignored\n";
    }
}

########################################################################
#	Assign remaining thermometers to IDs not assigned above
#
#	If $opt_w there may also be some IEC arguments to output
#	Else there is an IEC argument for each thermometer
########################################################################

%IONames = ();
foreach $argNameRef (@ArgNames) {
    ($iec, $tid) = @$argNameRef;
    unless ($tid) {
	foreach $tid (sort keys %thermometerIDs) {
	    unless ($thermometerIDs{$tid}[0]) {
		$thermometerIDs{$tid}[0] = $iec;# assign this IEC to a thermometer id
		$IONames{$iec} = $tid;		# mark valid IEC with now known thermometer
		$$argNameRef[ 1 ] = $tid;	# supply thermometer ID for registration
		goto THERMOMETER_FOUND;		# unassigned thermometer found
	    }
	}
	termQuit "The number of IEC input arguments $lenArgNames is greater than the number of thermometers $n_thermometers - cannot execute\n";
    }
  THERMOMETER_FOUND:
    print STDERR " $tid:$iec\n" if $opt_t;
}

########################################################################
#	Assign remaining thermometers to -I id strings not assigned above
########################################################################

$ix = 0;
foreach $id (@plain_opt_I) {
    foreach $thermometerRef (@thermometers) {
	($tid, undef, undef, undef, $option) = @$thermometerRef;
	unless ($option) {
	    $$thermometerRef[ 4 ] = $id;	# store id
	    goto TID_FOUND;			# unassigned thermometer found
	}
    }
    warn "*** WARNING: $named: ignore excess -I id arguments '@{[splice(@plain_opt_I, $ix)]}'\n";
    last;
  TID_FOUND:
    $ix++;
    print STDERR " $id:$tid\n" if $opt_t;
}

########################################################################
#	Evaluate argument analysis
########################################################################

unless ($opt_w or ($opt_l and not $lenArgNames)) {
    foreach $tid (sort keys %thermometerIDs) {
	unless ($thermometerIDs{$tid}[0]) {
	    warn "*** WARNING: $named: ignore extra thermometer $tid\n";
	}
    }
}

if ($opt_t) {
    print STDERR "Thermometer	IEC\n";
    foreach $argNameRef (@ArgNames) {
	($iec, $tid) = @$argNameRef;
	print STDERR "$tid	$iec\n";
    }
}

if ($opt_l) {
    print STDERR "The following $n_thermometers DS18B20 digital thermometers were detected:\n";
    foreach $thermometerRef (@thermometers) {
	($tid, undef, undef, undef, $id) = @$thermometerRef;
	print STDERR "	$tid	$thermometerIDs{$tid}[0]	'$id'\n";
    }
}

if ($opt_x or ($opt_l and not ($opt_w or $lenArgNames))) {
    termQuit 0;			# deliberate exit with -x or -l option
}

my $conn;
my $register = 0;		# tested in rcvd_msg_from_server() for registration reply
my $ri = 0;			# registration index used in rcvd_msg_from_server()
my $thermometerCount = 0;	# number of thermometers to output to iCserver
my $server  = 0;

if ($lenArgNames) {
    ########################################################################
    #
    #	Connect to iCserver and register I/Os (start iCserver if not running)
    #	connection is maintained until iCtherm shuts down or iCserver disconnects
    #
    #	Inhibit Nagle's algorithm
    #
    ########################################################################

    my $host = defined $opt_s ? $opt_s : 'localhost';
    my $port = defined $opt_p ? $opt_p : 8778;
    my $name = untaint($opt_n ? "$opt_n$instance" : "$named$instance");
    $named = $name;			# use individual ID for warnings from now on
    $register = 1;
    my $i = 0;
    if ($server >= 0) {
	print "send = '@{[defined $opt_d and ($opt_d & 1)]}' recv = '@{[defined $opt_d and ($opt_d & 2)]}'\n" if $opt_T;
	Msg->inhibit_nagle(1,		# inhibit Nagle's algorithm for real time response
	    defined $opt_d && ($opt_d & 2),	# trace recv messages
	    defined $opt_d && ($opt_d & 1));	# trace send messages
	until ($conn) {
	    $conn = Msg->connect($host, $port, \&rcvd_msg_from_server, 1); # return imme if connect fails
	    if ($conn) {
		print STDERR "iCtherm '$named' connecting at server\n" unless $opt_q;
	    } elsif ($host ne "localhost" and $host ne "127.0.0.1") {
		print "$named: '$host:iCserver -p $port -aA' cannot be started here - start it on $host\n";
		$server = -1;		# no iCserver possible
		last;
	    } elsif ($server > 0) {
		if ($i++ < 4) {
		    print "$named: $i: wait 2 seconds for iCserver to start\n" if $opt_T;
		    select undef, undef, undef, 2;
		} else {
		    print "$named: waited 8 seconds for 'iCserver -p $port -aA' to start - give up\n";
		    $server = -1;	# something wrong with iCserver
		    last;
		}
	    } else {
		my @s = split(" ", $opt_S);
		print "\@s = '@s'\n" if $opt_T;
		splice(@s, 1, 0, "-p", "$port") unless $port eq "8778";
		splice(@s, 1, 0, "-z$opt_q",);	# block STDIN for chained iCserver
		print "\@s = '@s'\n" if $opt_T;
		fork_and_exec(@s);	# start iCserver
		$server = 1;		# remember that this iCtherm started iCserver
	    }				# try to connect immediately
	}
    }
    $conn or termQuit "Client '$named' could not connect to $host:$port\n";

    ############# send registration ############################

    my ($direction);
    $UnitRegistrations = "N$name";	# initiate registration string

    foreach $argNameRef (@ArgNames) {
	($iec, $tid) = @$argNameRef;
	$direction = '';
	if ($iec =~ /^IW/) {
	    $direction = 'S';
	} else {
	    die "*** ERROR: $named: invalid argument '$iec' - internal error";
	}
	if ((length($UnitRegistrations) + length($iec)) > 1396) {	# REPLY 1400 - (1+2+1) in tcpc.h
	    print STDERR "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
	    $conn->send_now($UnitRegistrations);
	    my ($tmsg, $terr) = $conn->rcv_now();
	    print STDERR "$named: Reply: $tmsg\n" if $opt_t;
	    rcvd_msg_from_server($conn, $tmsg, $terr);	# receive registration acknowledgment
	    $UnitRegistrations = '';
	}
	$UnitRegistrations .= ",$direction$iec";	# direction 1 ',Z' 2 term 1
	print STDERR "register: $direction$iec	thermometer = $tid\n" if $opt_t;
    }
    $UnitRegistrations .= ",Z";		# terminate registration string
    print STDERR "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
    $conn->send_now($UnitRegistrations);
    my ($tmsg, $terr) = $conn->rcv_now();
    print STDERR "$named: Reply: $tmsg\n" if $opt_t;
    rcvd_msg_from_server($conn, $tmsg, $terr);	# receive final registration acknowledgment

    ############# registration analysis ########################
    $ri == $lenArgNames or
	die "*** ERROR: $named: $ri: not enough registration replies from iCserver - system error";
    $thermometerCount != 0 or
	termQuit "*** ERROR: $named: no valid registrations - cannot output to iCserver\n";
    $register = 0;
    ############# correct number of registration replies #######
    if ($opt_t) {
	my $c;
	print STDERR "Report result of registration\n";
	foreach $thermometerRef (@thermometers) {
	    ($tid, $c, undef, undef, $id) = @$thermometerRef;
	    print STDERR "ti = $tid; channel = $c\n";
	}
    }
    ########################################################################
    #	Optionally run -R option
    ########################################################################
    if (@runArgs) {
	splice(@runArgs, 1, 0, "-s", "$host") unless $host eq "localhost" or $host eq "127.0.0.1";
	splice(@runArgs, 1, 0, "-p", "$port") unless $port eq "8778";
	splice(@runArgs, 1, 0, "-z$opt_q",);	# block STDIN for chained app
	fork_and_exec(@runArgs);
    }
} elsif (@runArgs) {
    warn("*** WARNING: $named: no IEC names registered\n".
	 "		      no use running '@runArgs'\n");
}

########################################################################
#
#	Start the temperature measurement loop
#
########################################################################

$SIG{ALRM} = \&measureTemperatures;	# signal 14 - Timer signal from alarm()
if ((defined $opt_d and $opt_d == 0) or ($lenArgNames and not @runArgs)) {
    printf(STDERR "Start measuring\t%s\n", scalar localtime());
}
if ($opt_o) {
    print STDERR "Output to '$opt_o'\n";
}
alarm(1, $opt_r);			# first measurement in 1 second

if ($conn) {
    ########################################################################
    #
    #	Register an event handler callback for STDIN to recognise
    #	q or ctrl+D from the keyboard to terminate the program
    #	unless $opt_ (lone -) which blocks STDIN if called in a chain.
    #
    #	Sit in an infinite loop dispatching incoming events.
    #	if connected to iCserver
    #
    ########################################################################
    Msg->set_event_handler(*STDIN, "read" => \&readStdin) unless $opt_;
    Msg->event_loop();	# NOTE: no iCserver events for this app
} else {		#       only SIG ALRM for timed measurements
    ########################################################################
    #
    #	Else waste time waiting for SIG ALRM if -w -d or -o and no iC output
    #	Check keyboard for q or ctrl+D to terminate the program (never blocked).
    #	With Linux this select() also wakes up for each SIG ALRM
    #	Code from Programming Perl 3rd ed, page 781 - 782
    #
    ########################################################################
    my ($rout, $rin, $nfound);
    $rin = "";
    vec($rin, fileno(STDIN), 1) = 1;
    while (1) {
	$nfound = select($rout = $rin, undef, undef, undef);
	if ($nfound and vec($rout, fileno(STDIN), 1)) {
	    readStdin();
	}
    }
}

####### End of main program ############################################

########################################################################
#
#	Read from STDIN
#
########################################################################

sub readStdin {
    my $line = readline(STDIN);
    if (not defined $line or $line =~ m/^q/) {	# ctrl+D (EOF) or q
	if ($server > 0) {
	    $conn->send_now("X$named") if $conn;	# iCtherm started iCserver - stop it
	}
	termQuit "$named: stopped from terminal\n";
    } else {
	warn("*** WARNING: $named: not recognised: $line");
    }
} # readStdin

########################################################################
#
#	Send input value to iCserver
#
########################################################################

sub send_input {
    my ($ch, $val) = @_;
    if ($val != $ChannelsIq[$ch]) {
	$ChannelsIq[$ch] = $val;		# always save latest value sent on this channel
	printMicroSeconds();
	print STDERR "$named: $ch:$val	> $ChannelNames[$ch]\n" if $opt_t;
	printf STDERR "%s	%2d:%d	>\n", $ChannelNames[$ch], $ch, $val if defined $opt_d and ($opt_d & 1);
	$conn->send_now("$ch:$val");		# send latest value
    } else {
	warn("*** WARNING: $named: hysteresis not working correctly for channel $ch\n");
    }
} # send_input

########################################################################
#
#	Receive ack registration message from server
#
#	NOTE: this app never receives any data values to output
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, undef) = @_;
    printMicroSeconds();
    if (defined $msg) {
        my $len = length $msg;
	print STDERR "($len)$msg<\n" if $opt_T;
	if ($len == 0) {
	    $conn->disconnect();
	    termQuit "$named: disconnected by server\n";
	}
	my ($msg1, $channel, $iec);
	foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
	    if ($register and $msg1 =~ /^(-?\d+)$/) {
		next if $1 eq '-0';		## null acknowledgment
		$channel = $1;			## receive channel of a registration acknowledgment
		($iec, $tid) = @{$ArgNames[$ri]};	# all argument values
		defined $iec or
		    die "*** ERROR: $named: too many registration acknowledgments from iCserver - system error";
		print STDERR "$named: $ri: registering '$iec' on channel '$channel'\n" if $opt_t;
		$ri++;
		my $dir = '';
		if ($iec =~ /IW/) {
		    if ($channel == 0) {
			warn "*** WARNING: $named: trying to register sender '$iec' twice - not allowed\n";
			next;
		    }
		    $dir = 'S';
		    $thermometerCount++;
		    $ChannelsIq[$channel] = -2731;	# impossible initial temperature value
		    ${$thermometerCHs{$tid}} = $channel;	# store channel in @thermometers
		} else {
		    goto WrongFormat;
		}
		if ($dir) {
		    $ChannelNames[$channel] = "$iec";
		    print STDERR "register: $dir$iec channel = $channel thermometer = '$tid'\n" if $opt_t;
		}
	    } else {
	      WrongFormat:
		warn "*** WARNING: $named: WARNING: '$msg1' out of '$msg' from iCserver has wrong format - ignored";
	    }
	}
    }
} # rcvd_msg_from_server

########################################################################
#
#	Make a set of temperature measurements
#
#	A temperature value from a DS18B20 thermometer is obtained
#	by executing the following from the correct directory:
#	    cat /sys/bus/w1/devices/28-0000062e8239/w1_slave
#	A string like the following is returned and split into @temp:
#	    98 01 4b 46 7f ff 08 10 22 : crc=22 YES
#	    98 01 4b 46 7f ff 08 10 22 t=25500
#	The measurement is good if YES is returned (NO on crc error).
#	The first 2 values are the measurement (least significant first)
#	interpreted as hex values in 1/16th degrees Centigrade.
#	    0x0198 ==> 408; 408/16 ==> 25.5 °C
#	The converted value is also reported in the last token, but it
#	is not quite accurate (misses a final digit 5 for odd 16ths).
#
#	It seems appropriate to do a moving average with a factor of
#	6.25 (16 * 6.25 ==> 100).
#	Multiply the initial value by 6.25 ==> value in 1/100th degrees C.
#	For each new value multply old value by 1 - 1/6.25 (0.84); add
#	new value (* 6.25/6.25) ==> moving average in 1/100th degrees C.
#
#	The extra smoothing takes care of a slight jitter observed in the
#	measurements and gives a good result accurate to 2 decimal places.
#
#	iC output is degrees Centigrade or Fahrenheit (rounded to 1/10
#	degree) * 10 transmitted to iCserver as a 16 bit signed integer
#
#	-w -o <out> -d
#	default output is in in degrees Centigrade rounded to 1/10 degree C.
#	-F output is degrees Fahrenhet rounded to 1/10 degree F. This is
#	1/18 degree C, which is close to the measurement accuracy of 1/16.
#
#	Repeat for each thermometer.
#
########################################################################

sub measureTemperatures {
    my ($tid, $id, $channel, $Rtx100, $Rpx100, @temp, $tx16, $tx100, $tx10);
    print STDERR "measureTemperatures\n" if $opt_T;
    READING:
    foreach $thermometerRef (@thermometers) {
	($tid, $channel, $Rtx100, $Rpx100, $id) = @$thermometerRef;
	while (1) {
	    @temp = split ' ', `/bin/bash -c 'f="/sys/bus/w1/devices/$tid/w1_slave"; if [ -f \$f ]; then cat \$f; fi'`;
	    if (scalar @temp != 22) {
		print STDERR "*** WARNING: $tid:", join(' ', @temp), ": Faulty measurement ???\n";
		next READING;
	    }
	    print STDERR "$tid:", join(' ', @temp), "\n" if $opt_T;
	    last if $temp[11] eq "YES"
	}
	$tx16 = oct("0x$temp[1]$temp[0]");
	if (defined $$Rtx100) {
	    $$Rtx100 *= 0.84;
	    $$Rtx100 += $tx16;			# moving average
	} else {
	    $$Rtx100 = $tx16 * 6.25;		# initial value degrees Centigrade * 100
	}
	$tx100 = $opt_F ? $$Rtx100 * 1.8 + 3200 : $$Rtx100;
	printf(STDERR "%s	%3d	%3.6f °%s\n", scalar localtime(), $tx16, $tx100/100, $opt_F ? "F" : "C") if $opt_t;
	if ($tx100 >= $$Rpx100 + 6 || $tx100 < $$Rpx100 - 6) {	# hysteresis +- .01 <== (6-5)/100
	    $tx10 = int(($tx100 + 5) / 10);	# round to degrees (C or F) * 10
	    $$Rpx100 = $tx10 * 10;		# previous output value for comparison
	    if ($channel) {
		send_input($channel, $tx10);	# send temperature value to iCserver
	    }
	    if ($opt_w) {
		if ($id) {
		    printf("%s\t", $id);	# command line -I <id>
		}
		elsif ($n_thermometers > 1) {
		    printf("%s\t", $tid);	# thermometer id
		}
		printf("%3.1f °%s", $tx10/10, $opt_F ? "F" : "C");	# print temperature
		if (defined $opt_d and $opt_d == 0) {
		    printf("\t%s\n", scalar localtime()); # standard date and time string
		} else {
		    printf("\n");
		}
	    }
	}
    }
} # measureTemperatures

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    select undef, undef, undef, 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    print STDERR "\$ @_\n" unless $opt_q;
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "*** WARNING: forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    if ($opt_m) {
	my ($sec, $usec);
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf STDERR "T%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf STDERR "T%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
	$t0 = $t1;
    } elsif ($opt_t) {
	print STDERR "T: ";
    }
} # printMicroSeconds

########################################################################
#
#	Untaint a string for executing from a setuid program
#
########################################################################

sub untaint {
    my ($string) = @_;
    if ($string =~ m/^([-\@\w.\/\\]+)$/) {
	return $1;		# now untainted
    } else {
	die "Bad data in $string\n";
    }
} # untaint

########################################################################
#
#	Quit this program
#	Clear bit for GPIO 4 ($opt_W) in $usedString
#	Write $usedString to ~/.iC/gpios.used
#
########################################################################

sub termQuit ($) {
    my ($sig) = @_;
    if ($usedFile) {
	open USED, "+< $usedFile"				or die "can't open $usedFile: $!";
	flock(USED, LOCK_EX)					or die "can't lock $usedFile: $!";
	sysread(USED, $used, 16)				or die "can't read $usedFile: $!";
	$usedString = unpack("b128", $used);			print STDERR "usedString = $usedString\n" if $opt_T;
	$usedString &= $usedMask ^ "\1" x 128;			print STDERR "usedString = $usedString\n" if $opt_T;
	$used = pack("b128", $usedString);
	seek(USED, 0, 0)					or die "can't seek to start of $usedFile: $!";
	syswrite(USED, $used, 16)				or die "can't write $usedFile: $!";
	flock(USED, LOCK_UN)					or die "can't unlock $usedFile: $!";
	close USED						or die "can't close $usedFile: $!";
	if ($usedString !~ m/1/) {
	    unlink($usedFile) == 1				or die "can't remove $usedFile: $!";
	}
    } else {
	die "*** ERROR: $named: cannot find env{HOME] or open make .iC directory - system error";
    }
    if ($sig) {
	if ($sig eq "INT") {
	    $sig = 2;			# ctrl-C interrupt from keyboard
	    print STDERR "\nInterrupt from keyboard\n";
	} else {
	    $sig = 0;
	    print STDERR $sig unless $opt_q;
	}
    }
    exit $sig;
} # termQuit
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCtherm - an iC driver or standalone program supplying temperature values

=head1 SYNOPSIS

 iCtherm [-wdlCFmtTxqzh][ -s <host>][ -p <port>][ -n <name>][ -i <inst>]
         [ -o <out>][ -r <time>][ -W <GPIO>][ -I <id[:tid]> ...][ -d <i>]
         [ <IEC>[-<IEC>|:<tid>][-<inst>] ...]
         [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    DIRECT OUTPUT OPTIONS (default no iC output unless IEC's are specified)
        -w      write temperatures to terminal
        -o<out> write temperatures to file <out>
        -d      write date and time with output
        -I <id> write id before new temperature eg 'inside' or 'outside'
            alternatively
        -I <id:tid> individual ids may be followed by the thermometer id or
                part of it; eg -I inside:28-0000062e8239 or -I inside:239
                (default: thermometer ids in ascending numerical order).
                Note: any -I <id...> option implies -w
    COMMON OPTIONS
        -C      output temparature in 1/10th degrees Centigrade (default)
        -F      output temparature in 1/10th degrees Fahrenheit
        -r time measurement repetition <time> in seconds (default 60 sec)
        -W GPIO number used by the w1-gpio kernel module (default 4)
    iC OUTPUT OPTIONS
        IEC     IW0 IW1 IW2 ... (default IEC is IW0 etc unless -w -o -d -l)
                A range of IEC's can be specified with -; eg IW0-IW3
            alternatively
        IEC:tid individual IECs may be followed by the thermometer id or
                part of it; eg IW0:28-0000062e8239 or IW0:239
                (default: thermometers connected in ascending numerical order).
        IEC-inst Each IEC can be followed by -<inst>, where <inst> consists
                of up to 3 numeric digits (usually 1 digit).
                Such an appended instance code takes precedence over the
                general instance specified with the -i <inst> (see below).
        -S server +options+equivalences  (default 'iCserver -ak')
        -s host host name of iCserver    (default 'localhost')
        -p port service port of iCserver (default '8778')
        -n name registration name        (default first full IEC)
        -i inst instance ID for this iCtherm (1 to 3 numeric digits)
    DEBUG OPTIONS
        -l      list connected thermometer identifications
        -m      display elapsed time in seconds and microseconds
        -t      trace debug messages
	-d <i>  trace 1=send 2=rcv 3=both messages in Msg.pm
        -T      extra static debug messages
        -x      exit after analyzing input parameters
	-q      quiet - do not report clients connecting and disconnecting
	-z      block keyboard input
        -h      help, ouput this Usage text only
    AUXILIARY app
        -R <app ...> run auxiliary app followed by -z and its arguments
                     as a separate process; -R ... must be last arguments.

=head1 DESCRIPTION

The B<iCtherm> program measures temperature using one or more
B<DS18B20> 1-Wire digital thermometers normally connected to GPIO4
of a Raspberry Pi.

The DS18B20 digital thermometer provides 9-bit to 12-bit Centigrade
temperature measurements and has an alarm function with nonvolatile
user-programmable upper and lower trigger points.  It has an operating
temperature range of -55°C to +125°C and is accurate to ±0.5°C
over the range of -10°C to +85°C.

Each DS18B20 has a unique 64-bit serial code, which allows multiple
DS18B20s to function on the same 1-Wire bus. Thus, it is simple to
use one processor to control many DS18B20s distributed over a
large area. Applications that can benefit from this feature include
HVAC environmental controls, temperature monitoring systems inside
buildings, equipment, or machinery, and process monitoring and
control systems.

B<iCtherm> uses 12-bits for maximum resolution and currently does
not use the alarm function. The program has been designed to be an
I/O client for an iC network supplying temperature values either in
degrees Centigrade or Fahrenheit in 1/10 degree steps. Each thermometer
supplies a 16 bit word value in the range -550 to +1250 on an IEC-1131
input IWx associated with a thermometer in the call.  These values are
to be interpreted in the range of -55.0°C to +125.0°C.  (Fahrenheit
values have a range of -670 to +2570 for the same temperatures -67.0°F
to +257.0°F).

Temperature values can also be printed directly to standard output
or to a file with the -w or -o options. With the -d option each
temperature output also has a date and time stamp.  With the -I
option each thermometer output can be given an individual id string eg
'inside' or 'outside'.  If no IEC parameters are given, the program
acts as a standalone temperature recorder.

Temperature readings are made at regular intervals - the default is
60 seconds. This can be altered in 1 second steps with the -r option.
These readings, which are in 1/16th°C  for 12 bit resolution are
smoothed with a moving average of 6.25. This gives values in 0.01°C
smoothed over approx 5 minutes. For output this value is rounded to
the nearest 0.1°C (or converted to Fahrenheit and rounded to the
nearest 0.1°F).  Output to the iC network (or to printed output) only
occurs when a value changes by at least 0.1° with a hysteresis of
±0.01°. In practice this means output only occurs every 15 minutes
or so - often longer if the temperature is stable.

 IEC parameters for the iC network

 IEC     IW0 IW1 IW2 ...  (default IEC is IW0 etc unless -w -o -d)
         A range of IEC's can be specified -  eg IW0-IW3
         alternatively
 IEC:tid individual IECs may be followed by the thermometer
         identification or part of it; eg IW0:28-0000062e8239 or IW0:239
         (default: thermometers connected in ascending numerical order).

The identification strings of connected thermometers are listed with
the -l option.

=head1 ELECTRICAL CONNECTIONS

B<DS18B20> 1-Wire digital thermometers are connected to the Raspberry
PI by connecting the the red wire (Vcc) to 3.3 volts, the green wire
(Gnd) to 0 volts and the yellow wire (DQ0 to GPIO4 (pin 7). A 4.7
kohm pull up resistor must also be connected from GPIO4 to Vcc. The
program was tested with 10 DS18B20 thermometers. All 3 wires are each
connected in parallel.

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<iCbox(1)>, L<immcc(1)>, L<iClive(1)>, L<iCserver(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2014  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
