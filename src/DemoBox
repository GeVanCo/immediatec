#!/usr/bin/perl -P
########################################################################
#
#	iC generic Demo Box
#	adapted from
#	Example 14-1 Simple UI Code
#	Sriram Srinivasan: Advanced Perl p. 224
#
#	For measuring reaction times the Module Time::HiRes may be used.
#	This activates the -m option.
#	Make sure you have downloaded and installed Time::HiRes from CPAN
#	Uncomment the C++ comment in the next line
#//define TIME_HIRES
#
########################################################################

use Tk;					# Slurp the module in
use Msg;
use strict;

my @inputs;
my @outputs;
my $inByte =	0;		# initialize to a number for correct OR
my $outByte =	0;		# initialize to a number for correct XOR

my @masks =	(1, 2, 4, 8, 16, 32, 64, 128);
my @invert =	(1, 0);		# invert logic sense
my @bitIndex =	(
    0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,	# 0x01 0x02 0x04 0x08
    4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	# 0x10
    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x40
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:	@<<<<<< [-eth] [-s <host>] [-p <port>] [-RrIiOo <num>] [-l <len>] [<unitID>]
	$named
	-s host	ID of server (default 'localhost')
	-p port	service port of server (default '8778')
	-R num	from for input and output (default 0)
	-I num	from for input only
	-O num	from for output only
	-r num	to for input and output (default 100)
	-i num	to for input only
	-o num	to for output only
	-l len	length of scales (default 170)
	-e	exit button
	-t	trace debug messages
	-m	display elapsed time in seconds and microseconds
	    (Requires Module Time::HiRes available from CPAN - see source)
	-h	help, ouput this Usage text only
	unitID	default is 'X0'
$Id: DemoBox,v 1.29 2001/03/01 13:12:11 jw Exp $
.

use vars qw($opt_e $opt_t $opt_m $opt_s $opt_p $opt_r $opt_i $opt_o $opt_R $opt_I $opt_O $opt_l $opt_h);
require "getopts.pl";
&Getopts('tmes:p:r:i:o:R:I:O:l:h');	# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
#ifdef TIME_HIRES 

my ($t0, $t1, $sec, $usec);
if ($opt_m) {
    use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
    $t0 = [gettimeofday];	# start of program
}
#endif

$opt_R = 0 unless $opt_R;	# default from 0
$opt_r = 100 unless $opt_r;	# default to 100
$opt_I = $opt_R unless $opt_I;	# from for input
$opt_O = $opt_R unless $opt_O;	# from for output
$opt_i = $opt_r unless $opt_i;	# to for input
$opt_o = $opt_r unless $opt_o;	# to for output
$opt_l = 170 unless $opt_l;	# default length 170

########################################################################
#
#	Connect to server
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my $unitID = (@ARGV >= 1) ? $ARGV[0] : 'X0';

my $conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
die "Client could not connect to $host:$port\n" unless $conn;

print "Connection $unitID at client.\n";
$conn->send_now($unitID);		# register I/O

########################################################################
#
#	Create main window and optional Exit button
#
########################################################################

my $mainWindow = MainWindow->new();
$mainWindow->title("iC");
$mainWindow->Label(-text => "iC Demo Box")->pack;

$mainWindow->Button(-text    => "Exit",
		    -command => sub { exit; },
		   )->pack(-side   => 'bottom', 
			   -expand => 1,
			   -fill   => 'x',
			  ) if $opt_e;

########################################################################
#
#	Generate an input and an output frame
#
########################################################################

my $inLabel = "input";
my $outLabel = "output";
if ($unitID !~ /^X/) {
    $inLabel = "in I$unitID";
    $outLabel = "out Q$unitID";
}

my $inFrame  = $mainWindow->Frame(-label       => $inLabel,
				  -relief      => 'groove',
				  -borderwidth => 2,
				 )->pack(-side   => 'left', 
				         -expand => 'y',
				         -fill   => 'y',
				        );

my $outFrame = $mainWindow->Frame(-label       => $outLabel,
				  -relief      => 'groove',
				  -borderwidth => 2,
				 )->pack(-side   => 'right', 
				         -expand => 'y',
				         -fill   => 'y',
				        );

########################################################################
#
#	Generate 8 input checkbuttons and 8 output checkbuttons
#
########################################################################

if ($unitID =~ /^X/) {
    for my $index (0 .. 7) {
	my $input = "I$unitID.$index";
	my $makeCheckbutton = "\
	    \$inFrame->Checkbutton(\
		-text        => \$input,\
		-variable    => \\\$inputs[\$index],\
		-selectcolor => 'green',\
		-command     => sub {\
				     if (\$inputs[$index]) {\
					 \$inByte |= $masks[$index];	# set bit\n\
				     } else {\
					 \$inByte &= ~$masks[$index];	# clear bit\n\
				     }\
				     "
#ifdef TIME_HIRES 
				   ."\&printMicroSeconds if \$opt_m;"
#endif
				   ."print \"I$unitID.$index --> \$inputs[$index] (\$inByte)\\n\" if \$opt_t;\
				     \$conn->send_now(\"\$inByte\");\
				    },\
	    )->pack(-side   => 'top',\
		    -expand => 1,\
	    );\
	";
	eval $makeCheckbutton;
	print $@;
    }

    for my $index (0 .. 7) {
	my $output = "Q$unitID.$index";
	my $makeCheckbutton = "\
	    \$outFrame->Checkbutton(\
		-text        => \$output,\
		-variable    => \\\$outputs[\$index],\
		-selectcolor => 'red',\
		-takefocus   => 0,\
		-command     => sub {\
				     print \"Inverting output $index on Q$unitID\\n\" if \$opt_t;\
				     \$outputs[$index] = \$invert[\$outputs[$index]];\
				    },\
	    )->pack(-side   => 'top',\
		    -expand => 1,\
	    );\
	";
	eval $makeCheckbutton;
	print $@;
	$outputs[$index] = 0;
    }
}

########################################################################
#
#	Generate 1 input analog scale and 1 output analog scale
#
########################################################################

elsif ($unitID =~ /^[BW]/) {

    $inFrame->Scale(
	-from        => $opt_I,
	-to          => $opt_i,
	-length      => $opt_l,
	-variable    => \$inByte,
	-command     => sub {
			     if (length $inByte) {
#ifdef TIME_HIRES 
				 &printMicroSeconds if $opt_m;
#endif
				 print "I$unitID --> $inByte\n" if $opt_t;
				 $conn->send_now("$inByte");
			     }
			    },
    )->pack(-side   => 'top',
	    -expand => 1,
    );

    $outFrame->Scale(
	-from        => $opt_O,
	-to          => $opt_o,
	-length      => $opt_l,
	-variable    => \$outputs[0],
	-state       => 'disabled',
	-takefocus   => 0,
    )->pack(-side   => 'top',
	    -expand => 1,
    );

    $outputs[0] = 0;
}

########################################################################
#
#	Register read events
#
########################################################################

else {
    die "DemoBox $unitID could not be made\n";
}

$mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });

########################################################################
#
#	Sit in an infinite loop dispatching incoming events.
#
########################################################################

MainLoop;

########################################################################
#
#	Receive message from server - adjust outputs
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, $err) = @_;
    my ($len, $diff, $mask, $index, $value);
#ifdef TIME_HIRES 
    &printMicroSeconds if $opt_m;
#endif
    if (defined $msg) {
        $len = length $msg;
	if ($len == 0) {
	    $conn->disconnect();
	    print "DemoBox $unitID disconnected by server\n";
	    exit;
	}
	if ($unitID =~ /^X/) {
	    if ($msg eq "R") {
		print "$unitID rcvd R - reset from ICS\n" if $opt_t;
		for $index (0 .. 7) {
		    if ($outputs[$index]) {
			print "init Q$unitID.$index 0 <-- 1\n" if $opt_t;
			$outputs[$index] = 0;
		    }
		}
		$outByte = 0;
		if ($inByte) {
		    print "send I$unitID 0 --> $inByte\n" if $opt_t;
		    $conn->send_now("$inByte");
		}
	    } elsif ($msg =~ /^\d+$/ and $msg < 256) {
		$diff = $outByte ^ $msg;	# $outByte initialized to a number for correct XOR
		while ($diff) {			# age old algorithm from CSR days
		    $mask = $diff & -$diff;	# rightmost set bit from diff
		    $index = $bitIndex[$mask];
		    $value = ($msg & $mask) ? 1 : 0;
		    print "Q$unitID.$index $value <-- $outputs[$index] ($msg)\n" if $opt_t;
		    $outputs[$index] = $value;	# modify viewable output
		    $diff &= ~$mask;		# clear rightmost bit in diff
		}
		$outByte = $msg;		# ready for next message
	    } else {
		print "Q$unitID received spurious message: '$msg'\n";
	    }
	} elsif ($unitID =~ /^[BW]/) {
	    if ($msg eq "R") {
		print "$unitID rcvd R - reset from ICS\n" if $opt_t;
		if ($outputs[0]) {
		    print "init Q$unitID 0 <-- $outputs[0]\n" if $opt_t;
		    $outputs[0] = 0;
		}
		if (length $inByte and $inByte) {
		    print "send I$unitID 0 --> $inByte\n" if $opt_t;
		    $conn->send_now("$inByte");
		}
	    } elsif ($msg =~ /^-?\d+$/) {
		print "Q$unitID $msg <-- $outputs[0]\n" if $opt_t;
		$outputs[0] = $msg;
	    } else {
		print "Q$unitID received spurious message: '$msg'\n";
	    }
	}
    }
}
#ifdef TIME_HIRES 

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    my ($sec, $usec);
    $t1 = [gettimeofday];
    $sec =  $t1->[0] - $t0->[0];
    $usec = $t1->[1] - $t0->[1];
    if ($usec < 0) {
	$sec--;
	$usec += 1000000;
    }
    if ($opt_t) {
	printf "%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
    } else {
	printf "%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
    }
    $t0 = $t1;
}
#endif
