#! /usr/bin/perl

#################################################################
#
#	Copyright (C) 2000-2005  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	pplstfix
#   Fix iC listing, eliminating aliases and other discrepencies
#   which are soooo much easier in Perl than in C
#
#   Aliases appear in the listing because of one pass compiler
#   limitations. Aliases are completely eliminated from the
#   executable code, and should therefore not confuse readers
#   of the listings. This correction is now no longer necessary
#   as it was for V1.1, which corrected real naming errors, but
#   it is a neat feature, which is easy to maintain.
#
#   Author: John E. Wulff
#   V1.1:  02.01.01 Written in the car between Siegen and Eisingen
#   V1.4:  11.01.01 Major rewrite to handle new algorithm
#   V1.7:  14.08.02 Change in header line
#   V1.9:  12.12.03 Change IX0_0 etc to IX0.0 and _1 to 1 in C CODE
#   V1.10: 07.01.04 Be more precise - do not change QX0_0t to  QX0.0t
#		    Allow Alias of numbers (NCONST =)
#		    Change Alias in C CODE listing line
#   V1.11: 27.01.04 Re-format listing using longest identifier
#
#################################################################

use strict;

my $named = $0;
$named =~ s#.*[/\\]##;		# delete directory names in path
format STDERR =
Usage:	@<<<<<<< [file ...]
	$named
	-h	help, ouput this Usage text only
	called from icc or ict compiler to adjust listing output
$Id: pplstfix,v 1.13 2004/12/22 16:59:00 jw Exp $
.

use vars qw($opt_h);
# print STDERR "pplstfix: $named @ARGV\n";
require "getopts.pl";
&Getopts('h');			# sets $opt_h if -h etc

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my (%inv);
%inv = ("~", " ", " ", "~");	# inversion symbols in listing

my $OPS  = "[-.+\"&|%*#^/({=[<:!@?;twi]";	# DEBUG display of types from icc.h
my $LOPS = "[UA EVsrHISRDFGCTWX:!~]";		# DEBUG display of ftypes or negation
my $FOPS = "[UA EVsrHISRDFGCTWX:!]";		# DEBUG display of ftypes from icc.h
my $logic    = qr/^\t([A-Za-z_][\w.\$]*)\t($LOPS)[< ]---($OPS)(\t([A-Za-z_][\w.\$]*)(\t($FOPS))?)?/;
my $topology = qr/^([A-Za-z_][\w.\$]*)\t($OPS)  ($FOPS)(\t([ ~])(\w[\w.\$]*).+)?/;
my $target   = qr/($OPS)\t([A-Za-z_][\w.\$]*)(\t($FOPS))?/;

while ($ARGV = shift @ARGV) {
    unless (open (IN, $ARGV)) {
	warn "can't open input $ARGV";
	next;
    }
    processFile();
    close(IN);
}

####################################################################
#
#	process one file
#
#	QX1.7	|  X	 v5@
#	i7_7	@   	 IX7.7<
#	v5	@   	~v5_1#
#
####################################################################

sub processFile {
    my ($line, $alias, $xlate, $type, $ftype, $inver, %symbols);
    my ($empty, $removed, $count, $ar, $word, $pos, @array, $cFlag);
    my ($maxLength, $len, $firstWord, $spaces);
    $maxLength = 7;			# one standard tab size - 1
    %symbols = ();

    # Pass 1: scan file for ALIAS definitions
    #         also determine length of longest variable name

    while (<IN>) {
	if (/\bNET TOPOLOGY\b/) {
	    last;
	}
	if (/$logic/) {
	    if (($len = length $1) > $maxLength) {
		$maxLength = $len;
	    }
	    if (($len = length $5) > $maxLength) {
		$maxLength = $len;
	    }
	}
    }

    while (<IN>) {
	if (/\bNET STATISTICS\b/) {
	    last;
	}
	# allow alias of numbers (change jw 040112)
	if (/$topology/) {
	    if ($2 eq '@') {
		# NET TOPOLOGY line found eg:QB0_0	@  A	~QB0_1*
		$line  = $.;
		$alias = $1;
		$type  = $2;
		$ftype = $3;
		$inver = ($5 eq '~') ? 1 : 0;
		$xlate = $6;
		if ($4 and $alias ne $xlate) {
		    $symbols{$alias} = [ $line, $xlate, $type, $ftype, $inver ];
		} else {
		    printf("Generate error line%d: ALIAS '%s' translates to itself '%s'\n", $line, $alias, $xlate);
		}
	    }
	    if (($len = length $1) > $maxLength) {
		$maxLength = $len;
	    }
	}
    }

    # Pass 2: resolve ALIAS occurences

    seek(IN, 0, 0);
    $. = 0;
    @array = ();
    $empty = 0;
    $removed = 0;
    $cFlag = 0;
  line:
    while (<IN>) {
	$cFlag = 1 if /\bC.CODE\b/;			# change ALIAS's in C CODE listing lines
	$cFlag = 2 if /\bNET TOPOLOGY\b/;
	if ($empty and /^$/) {
	    $empty = 0;
	    next line;
	}
	if (/^[\d*]/ and $cFlag < 2) {			# 001 listing or *** Error line
	    s/\b([IQT]X\d+)_(\d+(_\d+)?)\b/$1.$2/g;
	    s/\b_(\d+)\b/$1/g;
	    goto cCode if $cFlag == 1;
	} else {
	  cCode:
	    while (/([A-Za-z_][\w.\$]*)/g) {		# non listing line or C CODE
		if (defined($symbols{$1})) {
		    push @array, $1, length $`;		# $word and $pos
		}
	    }
	    while (@array) {
		# start with the last word found, so positions are correct
		$pos = pop @array;			# position of word
		$word = $xlate = pop @array;		# value of word
		$inver = 0;
		while (defined($ar = $symbols{$xlate})) {
		    $line  = $ar->[0];
		    $type  = $ar->[2];
		    if (/---_/ or $line == $. and $type eq '_') {
			@array = ();			# should be clear anyway
			next line;			# ignore type '_'
		    }
		    if (/---@/ or $line == $.) {
			if ($word !~ /Q.*_0/ or /^\$/) {# keep $x lines
			    if (/^\t*(\w[\w.\$]*)\t/) {
				$firstWord = $1;
				$len = $maxLength + 1 - length $firstWord;
				$len = 1 if $len < 1;	# should never happen
				$spaces = ' ' x $len;
				s/^(\t*\w[\w.\$]*)\t/$1$spaces/;
				m/$target/;
				if (length $3) {
				    $firstWord = $2;
				    $len = $maxLength + 1 - length $firstWord;
				    $len = 1 if $len < 1; # should never happen
				    $spaces = ' ' x $len;
				    s//$1  $2$spaces$4/;
				} else {
				    s//$1  $2/;
				}
			    }
			    print $_;			# keep type '@' except Q.._0
			} elsif (/^\t/) {
			    $empty = 1;			# delete ALIAS definition
			} else {
			    $removed++;			# reduce ALIAS count
			}
			@array = ();			# should be clear anyway
			next line;
		    }
		    $xlate = $ar->[1];
		    if ($ar->[3] eq ' ') {		# ftype is GATE
			$inver ^= $ar->[4];		# invert
		    }
		}
		substr($_, $pos, length $word) = $xlate;
	    }
	    if ($inver) {				# for first word in line
		s/([ ~]) ---/$inv{$1} ---/;		# swap ' ' and '~'
		$inver = 0;
	    }
	    if (/^\t*(\w[\w.\$]*)\t/ and $cFlag != 1) {
		$firstWord = $1;
		$len = $maxLength + 1 - length $firstWord;
		$len = 1 if $len < 1;			# should never happen
		$spaces = ' ' x $len;
		s/^(\t*\w[\w.\$]*)\t/$1$spaces/;
		m/$target/;
		if (length $3) {
		    $firstWord = $2;
		    $len = $maxLength + 1 - length $firstWord;
		    $len = 1 if $len < 1;		# should never happen
		    $spaces = ' ' x $len;
		    s//$1  $2$spaces$4/;
		} else {
		    s//$1  $2/;
		}
	    }
	}
	if (/^ALIAS\t@ +(\d+)$/) {
	    if (($count = $1 - $removed) > 0) {
		s/\d+/$count/;
	    } else {
		next line;
	    }
	}
	print $_;
    }
} # processFile
